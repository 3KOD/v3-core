
// owner = caller
archetype UniswapV3Factory(owner: address)

// import UniswapV3PoolDeployer from "./UniswapV3PoolDeployer.tz"
// import NoDelegateCall from "./NoDelegateCall.tz"
// import UniswapV3Pool from "./UniswapV3Pool.tz"

constant  original: address = self_address

event OwnerChanged {
    oldOwner: address;
    newOwner: address
}

event PoolCreated {
    token0: address;
    token1: address;
    fee: nat;
    tickSpacing: int;
    pool: address
}

event FeeAmountEnabled {
    fee: nat;
    tickSpacing: int
}

/// @inheritdoc IUniswapV3Factory
asset feeAmountTickSpacing identified by fee to big_map {
    fee : nat;
    tickSpacing : int = 0;
} initialized by {
    { fee = 500; tickSpacing = 10 };
    { fee = 3000; tickSpacing = 60 };
    { fee = 10000; tickSpacing = 200 }
}

asset getPool identified by token0 token1 feeOfGetPool to big_map {
    token0: address;
    token1: address;
    feeOfGetPool: nat;
    pool: address;
}

record Parameters {
    para_factory: address;
    para_token0: address;
    para_token1: address;
    para_fee: nat;
    para_tickSpacing: int;
}

variable parameters: Parameters = {
    @0;
    @0;
    @0;
    0;
    0
}

entry deploy(
    factory_: address, 
    token0_: address, 
    token1_: address, 
    fee_: nat,
    tickSpacing_: int
) /* internal */ {}

function noDelegateCall() : bool {
    do_fail_if(self_address = original, "");
    return true
}

entry createPool(tokenA: address, tokenB: address, fee_: nat, callback : contract<address>) {
    require {
        createPool1: noDelegateCall();
        createPool2: tokenA <> tokenB;
    }

    effect {
        var token0_cp = tokenA < tokenB ? tokenA : tokenB;
        var token1_cp = tokenA < tokenB ? tokenB : tokenA;
        do_require(token0_cp <> @0, ("INVALID_ADDRESS", token0_cp));
        var tickSpacing_cp = feeAmountTickSpacing[fee_].tickSpacing;
        do_require(tickSpacing_cp <> 0, ("INVALID_TICK_SPACING", tickSpacing_cp));
        // do_require(getPool[token0_cp][token1_cp][fee_].pool <> 0, ("INVALID_GET_POOL", getPool));
        transfer transferred to entry callback(original)
    }
}

entry setOwner(owner_: address) {
    called by owner

    effect {
        emit<OwnerChanged>({owner; owner_});
        owner := owner_
    }
}

entry enableFeeAmount(fee_: nat, tickSpacing_: int) {
    called by owner

    require {
        enableFeeAmount1: fee_ < 1000000;
        enableFeeAmount2: tickSpacing_ > 0;
        enableFeeAmount3: tickSpacing_ < 16384;
        enableFeeAmount4: feeAmountTickSpacing[fee_].tickSpacing = 0;
    }

    effect {
        feeAmountTickSpacing.add_update(fee_, { tickSpacing := tickSpacing_ });
        emit<FeeAmountEnabled>({fee_; tickSpacing_})
    }

}