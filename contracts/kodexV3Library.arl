archetype kodexV3Library(mathLib: address)

constant INVALID_OPERATION: string = "INVALID"

constant MIN_TICK: int = -887272
constant MAX_TICK: int = -MIN_TICK
/// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
constant Q128: nat = 1 <<| 128
constant UNIX_START_TIME: date = 1970-01-01

record PoolKey {
    token0_poolKey: address;
    token1_poolKey: address;
    fee_poolKey: nat
} as (((token0, token1), fee))

record MintCallbackData {
    poolKey: PoolKey;
    payer: address; 
}

record SwapCallbackData {
    path_SwapCallbackData: bytes;
    payer_SwapCallbackData: address;
}

/// @inheritdoc IkodexV3PoolState
record Slot0 {
    // the current price
    // the current tick
    sqrtPriceX96: nat;
    tick: int;
    // the most-recently updated index of the observations array
    observationIndex: nat;
    // the current maximum number of observations that are being stored
    observationCardinality: nat;
    // the next maximum number of observations to store, triggered in observations.write
    observationCardinalityNext: nat;
    // the current protocol fee as a percentage of the swap fee taken on withdrawal
    // represented as an integer denominator (1/x)%
    feeProtocol: nat;
    // whether the pool is locked
    unlocked: bool;
}

// accumulated protocol fees in token0/token1 units
record ProtocolFees {
    token0_fees: nat;
    token1_fees: nat;
} as ((token0, token1))

// info stored for each initialized individual tick
record TickInfo {
    // the total position liquidity that references this tick
    liquidityGross: nat;
    // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),
    liquidityNet: int;
    // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    feeGrowthOutside0X128: nat;
    feeGrowthOutside1X128: nat;
    // the cumulative tick value on the other side of the tick
    tickCumulativeOutside: int;
    // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    secondsPerLiquidityOutsideX128: nat;
    // the seconds spent on the other side of the tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    secondsOutside: nat;
    // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross <> 0
    // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks
    %initialized: bool;
}

record PositionInfo {
    // the amount of liquidity owned by this position
    liquidity_PosInfo: nat;
    // fee growth per unit of liquidity as of the last update to liquidity or fees owed
    feeGrowthInside0LastX128_PosInfo: nat;
    feeGrowthInside1LastX128_PosInfo: nat;
    // the fees owed to the position owner in token0/token1
    tokensOwed0_PosInfo: nat;
    tokensOwed1_PosInfo: nat;
} as ((liquidity, (feeGrowthInside0LastX128, feeGrowthInside1LastX128), (tokensOwed0, tokensOwed1)))
record Observation {
    // the block timestamp of the observation
    blockTimestamp_Obs: nat;
    // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized
    tickCumulative_Obs: int;
    // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized
    secondsPerLiquidityCumulativeX128_Obs: nat;
    // whether or not the observation is initialized
    initialized_Obs: bool;
} as ((blockTimestamp, (tickCumulative, secondsPerLiquidityCumulativeX128, %initialized)))

view tickSpacingToMaxLpPerTick(tickSpacing_: int): nat {
    const minTick = (MIN_TICK div tickSpacing_) * tickSpacing_;
    const maxTick = (MAX_TICK div tickSpacing_) * tickSpacing_;
    const numTicks: int = (maxTick - minTick) div tickSpacing_ + 1;
    const retVal = int_to_nat((Q128 - 1) div numTicks) ? the : 0;
    return retVal
}

/// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.
view blockTimestamp_(): nat {
    const timestamp ?= int_to_nat((now - UNIX_START_TIME) div 1s) : INVALID_OPERATION;
    return timestamp
    // return uint32(block.timestamp); // truncation is desired
}

view tickMathGetSqrtRatioAtTick(tick_tickMathGetSqrtRatioAtTick: int) : nat {
    const retVal ?= call_view<nat>(mathLib, "tickMathGetSqrtRatioAtTick", tick_tickMathGetSqrtRatioAtTick) : INVALID_OPERATION;
    return retVal
}

view tickMathGetTickAtSqrtRatio(sqrtPriceX96_getTickAtSqrtRatio: nat) : int {
    const retVal ?= call_view<int>(mathLib, "tickMathGetTickAtSqrtRatio", sqrtPriceX96_getTickAtSqrtRatio) : INVALID_OPERATION;
    return retVal
}

view lte_tickBmpNITWOW(
    time: nat,
    a: nat,
    b: nat
) : bool {
    const retVal ?= call_view<bool>(mathLib, "lte_tickBmpNITWOW", (time, a, b)) : INVALID_OPERATION;
    return retVal
}

/// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.
/// The result may be the same observation, or adjacent observations.
/// @dev The answer must be contained in the array, used when the target is located within the stored observation
/// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation
/// @param self The stored oracle array
/// @param time The current block.timestamp
/// @param target The timestamp at which the reserved observation should be for
/// @param index The index of the observation that was most recently written to the observations array
/// @param cardinality The number of populated elements in the oracle array
/// @return beforeOrAt The observation recorded before, or at, the target
/// @return atOrAfter The observation recorded at, or after, the target
view binarySearch(
    poolAddress: address,
    time_binarySearch: nat,
    target_binarySearch: nat,
    index_binarySearch: nat,
    cardinality_binarySearch: nat
) : Observation * Observation {
    var l = (index_binarySearch + 1) % cardinality_binarySearch; // oldest observation
    var r = l + cardinality_binarySearch - 1; // newest observation
    var beforeOrAt: Observation = {0; 0; 0; false};
    var atOrAfter: Observation = {0; 0; 0; false};
    var i = 0;
    var condWhile = true;
    while condWhile do 
        i ?:= int_to_nat((l + r) div 2) : INVALID_OPERATION;

        beforeOrAt ?:= call_view<Observation>(poolAddress, "getObservation", (i % cardinality_binarySearch)) : INVALID_OPERATION;

        // we've landed on an uninitialized tick, keep searching higher (more recently)
        if (beforeOrAt.initialized_Obs = false) then
            l := i + 1
        else begin
            atOrAfter ?:= call_view<Observation>(poolAddress, "getObservation", ((i + 1) % cardinality_binarySearch)) : INVALID_OPERATION;

            var targetAtOrAfter ?= call_view<bool>(self_address, "lte_tickBmpNITWOW", (time_binarySearch, beforeOrAt.blockTimestamp_Obs, target_binarySearch)) : INVALID_OPERATION;
            const cond_val ?= call_view<bool>(self_address, "lte_tickBmpNITWOW", (time_binarySearch, target_binarySearch, atOrAfter.blockTimestamp_Obs)) : INVALID_OPERATION;

            // check if we've found the answer!
            if (targetAtOrAfter and cond_val) then
                condWhile := false;

            if (targetAtOrAfter = false) then r := i - 1
            else l := i + 1
        end
    done;
    return ((beforeOrAt, atOrAfter))
}

view transform(
    last_transform_param: Observation,
    blockTimestamp_transform_param: nat,
    tick_transform_param: int,
    liquidity_transform_param: nat
) : Observation {
    const delta ?= int_to_nat(blockTimestamp_transform_param - last_transform_param.blockTimestamp_Obs) : INVALID_OPERATION;
    const tickCumulative_val = last_transform_param.tickCumulative_Obs + tick_transform_param * delta;
    const secondsPerLiquidityCumulativeX128_val = 
        last_transform_param.secondsPerLiquidityCumulativeX128_Obs + ((delta <<| 128) div (liquidity_transform_param > 0 ? liquidity_transform_param : 1));

    const retVal: Observation = {
        blockTimestamp_transform_param;
        tickCumulative_val;
        secondsPerLiquidityCumulativeX128_val;
        true
    };

    return retVal
}

view getSurroundingObservations(
    poolAddress: address,
    time_getSurroundingObservations: nat,
    target_getSurroundingObservations: nat,
    tick_getSurroundingObservations: int,
    index_getSurroundingObservations: nat,
    liquidity_getSurroundingObservations: nat,
    cardinality_getSurroundingObservations: nat
) : Observation * Observation {
    // optimistically set before to the newest observation
    var beforeOrAt: Observation ?= call_view<Observation>(poolAddress, "getObservation", index_getSurroundingObservations) : INVALID_OPERATION;
    var atOrAfter: Observation = {0; 0; 0; false};

    const cond_val ?= call_view<bool>(
        self_address, 
        "lte_tickBmpNITWOW", 
        (time_getSurroundingObservations, beforeOrAt.blockTimestamp_Obs, target_getSurroundingObservations)) : INVALID_OPERATION;
    // if the target is chronologically at or after the newest observation, we can early return
    if (cond_val) then begin
        if (beforeOrAt.blockTimestamp_Obs = target_getSurroundingObservations) then
            // if newest observation equals target, we're in the same block, so we can ignore atOrAfter
            return ((beforeOrAt, atOrAfter))
        else begin
            const ret_Val ?= call_view<Observation>(
                self_address, 
                "transform", 
                (beforeOrAt, target_getSurroundingObservations, tick_getSurroundingObservations, liquidity_getSurroundingObservations)) : INVALID_OPERATION;
            // otherwise, we need to transform
            return ((beforeOrAt, ret_Val))
        end
    end else begin
        // now, set before to the oldest observation
        beforeOrAt ?:= call_view<Observation>(
            poolAddress, 
            "getObservation", ((index_getSurroundingObservations + 1) % cardinality_getSurroundingObservations)
        ) : INVALID_OPERATION;
        if (beforeOrAt.initialized_Obs = false) then
            beforeOrAt ?:= call_view<Observation>(self_address, "getObservation", 0) : INVALID_OPERATION;

        const require_cond ?= call_view<bool>(
            self_address, 
            "lte_tickBmpNITWOW", 
            (time_getSurroundingObservations, beforeOrAt.blockTimestamp_Obs, target_getSurroundingObservations)
        ) : INVALID_OPERATION;
        // ensure that the target is chronologically at or after the oldest observation
        do_require(require_cond, "OLD");

        const binarySearch_ret ?= call_view<Observation * Observation>(
            self_address, 
            "binarySearch",
            (poolAddress, time_getSurroundingObservations, target_getSurroundingObservations, index_getSurroundingObservations, cardinality_getSurroundingObservations)
        ) : INVALID_OPERATION;
        // if we've reached this point, we have to binary search
        return binarySearch_ret
    end
}

view observationsObserveSingle(
    poolAddress: address,
    time_observeSingle: nat,
    secondsAgo_observeSingle: nat,
    tick_observeSingle: int,
    index_observeSingle: nat,
    liquidity_observeSingle: nat,
    cardinality_observeSingle: nat
) : int * nat {
    if (secondsAgo_observeSingle = 0) then begin
        var last: Observation ?= call_view<Observation>(self_address, "getObservation", index_observeSingle) : INVALID_OPERATION;
        if (last.blockTimestamp_Obs <> time_observeSingle) then 
            last ?:= call_view<Observation>(self_address, "transform", (last, time_observeSingle, tick_observeSingle, liquidity_observeSingle)) : INVALID_OPERATION;
        const val1 = last.tickCumulative_Obs;
        const val2 = last.secondsPerLiquidityCumulativeX128_Obs;
        return ((val1, val2))
    end else begin

        var target ?= int_to_nat(time_observeSingle - secondsAgo_observeSingle) : INVALID_OPERATION;

        const retVal ?= call_view<Observation * Observation>(self_address, "getSurroundingObservations", (
            poolAddress,
            time_observeSingle,
            target,
            tick_observeSingle,
            index_observeSingle,
            liquidity_observeSingle,
            cardinality_observeSingle
        )) : INVALID_OPERATION;
        const beforeOrAt = retVal[0];
        const atOrAfter = retVal[1];

        if (target = beforeOrAt.blockTimestamp_Obs) then 
            // we're at the left boundary
            return ((beforeOrAt.tickCumulative_Obs, beforeOrAt.secondsPerLiquidityCumulativeX128_Obs))
        else if (target = atOrAfter.blockTimestamp_Obs) then
            // we're at the right boundary
            return ((atOrAfter.tickCumulative_Obs, atOrAfter.secondsPerLiquidityCumulativeX128_Obs))
        else begin
            // we're in the middle
            const observationTimeDelta = atOrAfter.blockTimestamp_Obs - beforeOrAt.blockTimestamp_Obs;
            const targetDelta = target - beforeOrAt.blockTimestamp_Obs;
            const retVal1 = beforeOrAt.tickCumulative_Obs + ((atOrAfter.tickCumulative_Obs - beforeOrAt.tickCumulative_Obs) div observationTimeDelta) * targetDelta;
            const retVal2_int = 
                beforeOrAt.secondsPerLiquidityCumulativeX128_Obs + 
                (atOrAfter.secondsPerLiquidityCumulativeX128_Obs - beforeOrAt.secondsPerLiquidityCumulativeX128_Obs) * targetDelta div observationTimeDelta;
            const retVal2 ?= int_to_nat(retVal2_int) : INVALID_OPERATION;
            return ((retVal1, retVal2))
        end
    end
}

/// @notice Retrieves fee growth data
/// @param self The mapping containing all tick information for initialized ticks
/// @param tickLower The lower tick boundary of the position
/// @param tickUpper The upper tick boundary of the position
/// @param tickCurrent The current tick
/// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
/// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
/// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
/// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
view getFeeGrowthInside(
    lower: TickInfo,
    upper: TickInfo,
    tickLower_getFeeGrowthInside: int,
    tickUpper_getFeeGrowthInside: int,
    tickCurrent_getFeeGrowthInside: int,
    feeGrowthGlobal0X128_getFeeGrowthInside: nat,
    feeGrowthGlobal1X128_getFeeGrowthInside: nat
) : nat * nat {
    // calculate fee growth below
    var feeGrowthBelow0X128 = 0;
    var feeGrowthBelow1X128 = 0;
    if (tickCurrent_getFeeGrowthInside >= tickLower_getFeeGrowthInside) then begin
        feeGrowthBelow0X128 := lower.feeGrowthOutside0X128;
        feeGrowthBelow1X128 := lower.feeGrowthOutside1X128;
    end else begin
        feeGrowthBelow0X128 ?:= int_to_nat(feeGrowthGlobal0X128_getFeeGrowthInside - lower.feeGrowthOutside0X128) : INVALID_OPERATION;
        feeGrowthBelow1X128 ?:= int_to_nat(feeGrowthGlobal1X128_getFeeGrowthInside - lower.feeGrowthOutside1X128) : INVALID_OPERATION;
    end;

    // calculate fee growth above
    var feeGrowthAbove0X128 = 0;
    var feeGrowthAbove1X128 = 0;
    if (tickCurrent_getFeeGrowthInside < tickUpper_getFeeGrowthInside) then begin
        feeGrowthAbove0X128 := upper.feeGrowthOutside0X128;
        feeGrowthAbove1X128 := upper.feeGrowthOutside1X128;
    end else begin
        feeGrowthAbove0X128 ?:= int_to_nat(feeGrowthGlobal0X128_getFeeGrowthInside - upper.feeGrowthOutside0X128) : INVALID_OPERATION;
        feeGrowthAbove1X128 ?:= int_to_nat(feeGrowthGlobal1X128_getFeeGrowthInside - upper.feeGrowthOutside1X128) : INVALID_OPERATION;
    end;

    const feeGrowthInside0X128 ?= int_to_nat(feeGrowthGlobal0X128_getFeeGrowthInside - feeGrowthBelow0X128 - feeGrowthAbove0X128) : INVALID_OPERATION;
    const feeGrowthInside1X128 ?= int_to_nat(feeGrowthGlobal1X128_getFeeGrowthInside - feeGrowthBelow1X128 - feeGrowthAbove1X128) : INVALID_OPERATION;
    return ((feeGrowthInside0X128, feeGrowthInside1X128))
}

view sqrtPriceMathGetAmount0D_rd(
    sqrtRatioAX96_sPMGA0D: nat,
    sqrtRatioBX96_sPMGA0D: nat,
    liquidity_sPMGA0D: nat,
    roundUp_sPMGA0D: bool
) : nat {
    const retVal ?= call_view<nat>(mathLib, "sqrtPriceMathGetAmount0D_rd", (sqrtRatioAX96_sPMGA0D, sqrtRatioBX96_sPMGA0D, liquidity_sPMGA0D, roundUp_sPMGA0D)) : INVALID_OPERATION;
    return retVal
}

view sqrtPriceMathGetAmount0Delta(
    sqrtRatioAX96_sPMGA0D: nat,
    sqrtRatioBX96_sPMGA0D: nat,
    liquidity_sPMGA0D: int
) : int {
    const retVal ?= call_view<int>(mathLib, "sqrtPriceMathGetAmount0Delta", (sqrtRatioAX96_sPMGA0D, sqrtRatioBX96_sPMGA0D, liquidity_sPMGA0D)) : INVALID_OPERATION;
    return retVal
}

view sqrtPriceMathGetAmount1D_rd(
    sqrtRatioAX96_sPMGA1D: nat,
    sqrtRatioBX96_sPMGA1D: nat,
    liquidity_sPMGA1D: nat,
    roundUp_sPMGA1D: bool
) : nat {
    const retVal ?= call_view<nat>(mathLib, "sqrtPriceMathGetAmount1D_rd", (sqrtRatioAX96_sPMGA1D, sqrtRatioBX96_sPMGA1D, liquidity_sPMGA1D, roundUp_sPMGA1D)) : INVALID_OPERATION;
    return retVal
}

view sqrtPriceMathGetAmount1Delta(
    sqrtRatioAX96_sPMGA1D: nat,
    sqrtRatioBX96_sPMGA1D: nat,
    liquidity_sPMGA1D: int
) : int {
    const retVal ?= call_view<int>(mathLib, "sqrtPriceMathGetAmount1Delta", (sqrtRatioAX96_sPMGA1D, sqrtRatioBX96_sPMGA1D, liquidity_sPMGA1D)) : INVALID_OPERATION;
    return retVal
}

view bitMathMostSignificantBit(xx: nat) : nat {
    const retVal ?= call_view<nat>(mathLib, "bitMathMostSignificantBit", (xx)) : INVALID_OPERATION;
    return retVal
}

view bitMathLeastSignificantBit(xx: nat) : nat {
    const retVal ?= call_view<nat>(mathLib, "bitMathLeastSignificantBit", (xx)) : INVALID_OPERATION;
    return retVal
}

view tickBmpNextInitTickWithOneW(
    poolAddress: address,
    tick_tickBmpNITWOWord: int,
    tickSpacing_tickBmpNITWOWord: int,
    lte_tickBmpNITWOWord: bool
) : int * bool {
    const retVal ?= call_view<int * bool>(
        mathLib, 
        "tickBmpNextInitTickWithOneW", 
        (poolAddress, tick_tickBmpNITWOWord, tickSpacing_tickBmpNITWOWord, lte_tickBmpNITWOWord)
    ) : INVALID_OPERATION;
    return retVal
}

view sqrtPMathGetNSqrtPFromA0RUp(
    sqrtPX96_sqrtPMGNSPFromA0RU: nat,
    liquidity_sqrtPMGNSPFromA0RU: nat,
    amount_sqrtPMGNSPFromA0RU: nat,
    add_sqrtPMGNSPFromA0RU: bool
) : nat {
    const retVal ?= call_view<nat>(
        mathLib, 
        "sqrtPMathGetNSqrtPFromA0RUp", 
        (sqrtPX96_sqrtPMGNSPFromA0RU, liquidity_sqrtPMGNSPFromA0RU, amount_sqrtPMGNSPFromA0RU, add_sqrtPMGNSPFromA0RU)
    ) : INVALID_OPERATION;
    return retVal
}

view sqrtPMathGetNSqrtPFromA1RDown(
    sqrtPX96_sqrtPMGNSPFromA1RD: nat,
    liquidity_sqrtPMGNSPFromA1RD: nat,
    amount_sqrtPMGNSPFromA1RD: nat,
    add_sqrtPMGNSPFromA1RD: bool
) : nat {
    const retVal ?= call_view<nat>(
        mathLib, 
        "sqrtPMathGetNSqrtPFromA1RDown", 
        (sqrtPX96_sqrtPMGNSPFromA1RD, liquidity_sqrtPMGNSPFromA1RD, amount_sqrtPMGNSPFromA1RD, add_sqrtPMGNSPFromA1RD)
    ) : INVALID_OPERATION;
    return retVal
}

view sqrtPMathGetNSqrtPFromIn(
    sqrtPX96_sqrlPriceMathGNSPFI: nat,
    liquidity_sqrlPriceMathGNSPFI: nat,
    amountIn_sqrlPriceMathGNSPFI: nat,
    zeroForOne_sqrlPriceMathGNSPFI: bool
) : nat {
    const retVal ?= call_view<nat>(
        mathLib, 
        "sqrtPMathGetNSqrtPFromIn", 
        (sqrtPX96_sqrlPriceMathGNSPFI, liquidity_sqrlPriceMathGNSPFI, amountIn_sqrlPriceMathGNSPFI, zeroForOne_sqrlPriceMathGNSPFI)
    ) : INVALID_OPERATION;
    return retVal
}

view sqrtPMathGetNSqrtPFromOut(
    sqrtPX96_sqrlPriceMathGNSPFO: nat,
    liquidity_sqrlPriceMathGNSPFO: nat,
    amountOut_sqrlPriceMathGNSPFO: nat,
    zeroForOne_sqrlPriceMathGNSPFO: bool
) : nat {
    const retVal ?= call_view<nat>(
        mathLib, 
        "sqrtPMathGetNSqrtPFromOut", 
        (sqrtPX96_sqrlPriceMathGNSPFO, liquidity_sqrlPriceMathGNSPFO, amountOut_sqrlPriceMathGNSPFO, zeroForOne_sqrlPriceMathGNSPFO)
    ) : INVALID_OPERATION;
    return retVal
}

view swapMathComputeSwapStep(
    sqrtRatioCurrentX96: nat,
    sqrtRatioTargetX96: nat,
    liquidity_swapMathComputeSwapStep: nat,
    amountRemaining: int,
    feePips: nat
) : nat * nat * nat * nat {
    const retVal ?= call_view<nat * nat * nat * nat>(
        mathLib, 
        "swapMathComputeSwapStep", 
        (sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity_swapMathComputeSwapStep, amountRemaining, feePips)
    ) : INVALID_OPERATION;
    return retVal
}

/// @inheritdoc IkodexV3PoolDerivedState
view snapshotCumulativesInside(lower: TickInfo, upper: TickInfo, tickLower: int, tickUpper: int, slot0: Slot0, liquidity: nat): int * nat * nat
{
    do_require(tickLower < tickUpper, "TLU");
    do_require(tickLower >= MIN_TICK, "TLM");
    do_require(tickUpper <= MAX_TICK, "TUM");

    var tickCumulativeInside: int = 0;
    var secondsPerLiquidityInsideX128: nat = 0;
    var secondsInside: nat = 0;

    var tickCumulativeLower: int = 0;
    var tickCumulativeUpper: int = 0;
    var secondsPerLiquidityOutsideLowerX128: nat = 0;
    var secondsPerLiquidityOutsideUpperX128: nat = 0;
    var secondsOutsideLower: nat = 0;
    var secondsOutsideUpper: nat = 0;

    tickCumulativeLower := lower.tickCumulativeOutside;
    secondsPerLiquidityOutsideLowerX128 := lower.secondsPerLiquidityOutsideX128;
    secondsOutsideLower :=  lower.secondsOutside;
    do_require(lower.%initialized, "ERR");

    tickCumulativeUpper := upper.tickCumulativeOutside;
    secondsPerLiquidityOutsideUpperX128 := upper.secondsPerLiquidityOutsideX128;
    secondsOutsideUpper := upper.secondsOutside;
    do_require(upper.%initialized, "ERR");

    if (slot0.tick < tickLower) then begin
        tickCumulativeInside := tickCumulativeLower - tickCumulativeUpper;
        secondsPerLiquidityInsideX128 ?:= int_to_nat(secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128) : INVALID_OPERATION;
        secondsInside ?:= int_to_nat(secondsOutsideLower - secondsOutsideUpper) : INVALID_OPERATION;
        return ((tickCumulativeInside, secondsPerLiquidityInsideX128, secondsInside))
    end else if (slot0.tick < tickUpper) then begin
        var time ?= call_view<nat>(self_address, "blockTimestamp_", Unit) : INVALID_OPERATION;
        const retVal ?= call_view<int * nat>(self_address, "observationsObserveSingle", (
            self_address,
            time,
            0,
            slot0.tick,
            slot0.observationIndex,
            liquidity,
            slot0.observationCardinality
        )) : INVALID_OPERATION;
        const tickCumulative: int = retVal[0];
        const secondsPerLiquidityCumulativeX128: nat = retVal[1];
        tickCumulativeInside := tickCumulative - tickCumulativeLower - tickCumulativeUpper;
        secondsPerLiquidityInsideX128 ?:= int_to_nat(secondsPerLiquidityCumulativeX128 - secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128) : INVALID_OPERATION;
        secondsInside ?:= int_to_nat(time - secondsOutsideLower - secondsOutsideUpper) : INVALID_OPERATION;
        return ((tickCumulativeInside, secondsPerLiquidityInsideX128, secondsInside))
    end else begin
        tickCumulativeInside := tickCumulativeUpper - tickCumulativeLower;
        secondsPerLiquidityInsideX128 ?:= int_to_nat(secondsPerLiquidityOutsideUpperX128 - secondsPerLiquidityOutsideLowerX128) : INVALID_OPERATION;
        secondsInside ?:= int_to_nat(secondsOutsideUpper - secondsOutsideLower) : INVALID_OPERATION;
        return ((tickCumulativeInside, secondsPerLiquidityInsideX128, secondsInside))
    end
}

/// @inheritdoc IkodexV3PoolDerivedState
view observe(secondsAgos: list<nat>, slot0: Slot0, liquidity: nat) : list<int> * list<nat> {
    do_require(slot0.observationCardinality > 0, "I");

    const time_val ?= call_view<nat>(self_address, "blockTimestamp_", Unit) : INVALID_OPERATION;
    var tickCumulatives: list<int> = [];
    var secondsPerLiquidityCumulativeX128s: list<nat> = [];
    var i = 0;
    while (i < length(secondsAgos)) do
        const retVal ?= call_view<int * nat>(self_address, "observationsObserveSingle", (
            time_val,
            (nth(secondsAgos, i) ? the : 0),
            slot0.tick,
            slot0.observationIndex,
            liquidity,
            slot0.observationCardinality
        )) : INVALID_OPERATION;
        tickCumulatives := concat(tickCumulatives, [retVal[0]]);
        secondsPerLiquidityCumulativeX128s := concat(secondsPerLiquidityCumulativeX128s, [retVal[1]]);
        i += 1
    done;
    return ((tickCumulatives, secondsPerLiquidityCumulativeX128s))
}

/// @inheritdoc IkodexV3PoolActions
view burn(
    /* int24 */ tickLower_burn: int,
    /* int24 */ tickUpper_burn: int,
    /* uint128 */ amount_burn: nat,
    poolAddress: address
): nat * nat
{
    const slot0_ ?= call_view<Slot0>(poolAddress, "getSlot0", Unit) : INVALID_OPERATION;
    do_require(slot0_.unlocked, "LOK");

    const checkTicks_retVal ?= call_view<bool>(self_address, "checkTicks", (tickLower_burn, tickUpper_burn)) : INVALID_OPERATION;
    do_require(checkTicks_retVal, "ERR");

    var amount0: int = 0;
    var amount1: int = 0;

    if (amount_burn <> 0) then begin
        if (slot0_.tick < tickLower_burn) then begin
            // current tick is below the passed range; liquidity can only become in range by crossing from left to
            // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it
            const sqrtPriceMathGetAmount0Delta_param0 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickLower_burn) : INVALID_OPERATION;
            const sqrtPriceMathGetAmount0Delta_param1 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickUpper_burn) : INVALID_OPERATION;
            amount0 ?:= call_view<int>(self_address, "sqrtPriceMathGetAmount0Delta", (
                sqrtPriceMathGetAmount0Delta_param0,
                sqrtPriceMathGetAmount0Delta_param1,
                amount_burn
            )) : INVALID_OPERATION;
        end else begin 
            if (slot0_.tick < tickUpper_burn) then begin
                // early return if we've already written an observation this block
                const sqrtPriceMathGetAmount0Delta_param1 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickUpper_burn) : INVALID_OPERATION;
                amount0 ?:= call_view<int>(self_address, "sqrtPriceMathGetAmount0Delta", (
                    slot0_.sqrtPriceX96,
                    sqrtPriceMathGetAmount0Delta_param1,
                    amount_burn
                )) : INVALID_OPERATION;
                const sqrtPriceMathGetAmount1Delta_param0 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickLower_burn) : INVALID_OPERATION;
                amount1 ?:= call_view<int>(self_address, "sqrtPriceMathGetAmount1Delta", (
                    sqrtPriceMathGetAmount1Delta_param0,
                    slot0_.sqrtPriceX96,
                    amount_burn
                )) : INVALID_OPERATION
            end else begin
                // current tick is above the passed range; liquidity can only become in range by crossing from right to
                // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it
                const sqrtPriceMathGetAmount1Delta_param0 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickLower_burn) : INVALID_OPERATION;
                const sqrtPriceMathGetAmount1Delta_param1 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickUpper_burn) : INVALID_OPERATION;
                amount1 ?:= call_view<int>(self_address, "sqrtPriceMathGetAmount1Delta", (
                    sqrtPriceMathGetAmount1Delta_param0,
                    sqrtPriceMathGetAmount1Delta_param1,
                    amount_burn
                )) : INVALID_OPERATION
            end
        end
    end;

    const amount0_nat ?= int_to_nat(-amount0) : INVALID_OPERATION;
    const amount1_nat ?= int_to_nat(-amount1) : INVALID_OPERATION;
    return ((amount0_nat, amount1_nat))
}

/// @inheritdoc IkodexV3PoolActions
view burn_PositionInfo_view(
    amount_burn: nat,
    caller_address: address,
    poolAddress: address,
    tickLower_burn: int,
    tickUpper_burn: int,
    feeGrowthGlobal0X128_: nat,
    feeGrowthGlobal1X128_: nat,
    info_flippedLower: TickInfo,
    info_flippedUpper: TickInfo
) : PositionInfo
{
    const slot0_ ?= call_view<Slot0>(poolAddress, "getSlot0", Unit) : INVALID_OPERATION;
    do_require(slot0_.unlocked, "LOK");
    const checkTicks_retVal ?= call_view<bool>(self_address, "checkTicks", (tickLower_burn, tickUpper_burn)) : INVALID_OPERATION;
    do_require(checkTicks_retVal, "ERR");

    var position ?= call_view<PositionInfo>(
        poolAddress, 
        "getPositionInfo", 
        (caller_address, tickLower_burn, tickUpper_burn)
    ): INVALID_OPERATION;

    const retVal_getFeeGrowthInside: (nat * nat) ?= call_view<(nat * nat)>(self_address, "getFeeGrowthInside", (
        info_flippedLower,
        info_flippedUpper,
        tickLower_burn,
        tickUpper_burn,
        slot0_.tick,
        feeGrowthGlobal0X128_,
        feeGrowthGlobal1X128_
    )) : INVALID_OPERATION;

    const feeGrowthInside0X128 = retVal_getFeeGrowthInside[0];
    const feeGrowthInside1X128 = retVal_getFeeGrowthInside[1];

    var liquidityNext = 0;
    if (amount_burn = 0) then begin
        do_require(position.liquidity_PosInfo > 0, "NP"); // disallow pokes for 0 liquidity positions
        liquidityNext := position.liquidity_PosInfo
    end else begin
        liquidityNext := position.liquidity_PosInfo + amount_burn
    end;

    // calculate accumulated fees // TOOD + fullMath 512 bit operatoin
    var tokensOwed0: nat ?= int_to_nat((feeGrowthInside0X128 - position.feeGrowthInside0LastX128_PosInfo) * position.liquidity_PosInfo div Q128) : INVALID_OPERATION;
    var tokensOwed1: nat ?= int_to_nat((feeGrowthInside1X128 - position.feeGrowthInside1LastX128_PosInfo) * position.liquidity_PosInfo div Q128) : INVALID_OPERATION;

    // update the position
    if (amount_burn <> 0) then position.liquidity_PosInfo := liquidityNext;
    position.feeGrowthInside0LastX128_PosInfo := feeGrowthInside0X128;
    position.feeGrowthInside1LastX128_PosInfo := feeGrowthInside1X128;
    if ((tokensOwed0 > 0) or (tokensOwed1 > 0)) then begin
        // overflow is acceptable, have to withdraw before you hit type(uint128).max fees
        position.tokensOwed0_PosInfo += tokensOwed0;
        position.tokensOwed1_PosInfo += tokensOwed1
    end;
    // }

    var amount0: int = 0;
    var amount1: int = 0;

    if (amount_burn <> 0) then begin
        if (slot0_.tick < tickLower_burn) then begin
            // current tick is below the passed range; liquidity can only become in range by crossing from left to
            // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it
            const sqrtPriceMathGetAmount0Delta_param0 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickLower_burn) : INVALID_OPERATION;
            const sqrtPriceMathGetAmount0Delta_param1 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickUpper_burn) : INVALID_OPERATION;
            amount0 ?:= call_view<int>(self_address, "sqrtPriceMathGetAmount0Delta", (
                sqrtPriceMathGetAmount0Delta_param0,
                sqrtPriceMathGetAmount0Delta_param1,
                amount_burn
            )) : INVALID_OPERATION;
        end else begin 
            if (slot0_.tick < tickUpper_burn) then begin
                const sqrtPriceMathGetAmount0Delta_param1 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickUpper_burn) : INVALID_OPERATION;
                amount0 ?:= call_view<int>(self_address, "sqrtPriceMathGetAmount0Delta", (
                    slot0_.sqrtPriceX96,
                    sqrtPriceMathGetAmount0Delta_param1,
                    amount_burn
                )) : INVALID_OPERATION;
                const sqrtPriceMathGetAmount1Delta_param0 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickLower_burn) : INVALID_OPERATION;
                amount1 ?:= call_view<int>(self_address, "sqrtPriceMathGetAmount1Delta", (
                    sqrtPriceMathGetAmount1Delta_param0,
                    slot0_.sqrtPriceX96,
                    amount_burn
                )) : INVALID_OPERATION;
            end else begin
                // current tick is above the passed range; liquidity can only become in range by crossing from right to
                // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it
                const sqrtPriceMathGetAmount1Delta_param0 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickLower_burn) : INVALID_OPERATION;
                const sqrtPriceMathGetAmount1Delta_param1 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickUpper_burn) : INVALID_OPERATION;
                amount1 ?:= call_view<int>(self_address, "sqrtPriceMathGetAmount1Delta", (
                    sqrtPriceMathGetAmount1Delta_param0,
                    sqrtPriceMathGetAmount1Delta_param1,
                    amount_burn
                )) : INVALID_OPERATION
            end
        end
    end;

    const amount0_nat ?= int_to_nat(-amount0) : INVALID_OPERATION;
    const amount1_nat ?= int_to_nat(-amount1) : INVALID_OPERATION;

    if (amount0_nat > 0 or amount1_nat > 0) then begin
        position.tokensOwed0_PosInfo := position.tokensOwed0_PosInfo + amount0_nat;
        position.tokensOwed1_PosInfo := position.tokensOwed1_PosInfo + amount1_nat
    end;

    return position
}

view mint_PositionInfo_view(
    amount_mint: nat,
    recipient_mint: address,
    poolAddress: address,
    tickLower_mint: int,
    tickUpper_mint: int,
    feeGrowthGlobal0X128_: nat,
    feeGrowthGlobal1X128_: nat,
    info_flippedLower_: TickInfo,
    info_flippedUpper_: TickInfo
) : PositionInfo
{
    const slot0_ ?= call_view<Slot0>(poolAddress, "getSlot0", Unit) : INVALID_OPERATION;
    do_require(slot0_.unlocked, "LOK");
    do_require(amount_mint > 0, "ERR");

    const checkTicks_retVal ?= call_view<bool>(self_address, "checkTicks", (tickLower_mint, tickUpper_mint)) : INVALID_OPERATION;
    do_require(checkTicks_retVal, "ERR");

    var position ?= call_view<PositionInfo>(
        poolAddress, 
        "getPositionInfo", 
        (recipient_mint, tickLower_mint, tickUpper_mint)
    ): INVALID_OPERATION;

    const retVal_getFeeGrowthInside: (nat * nat) ?= call_view<(nat * nat)>(self_address, "getFeeGrowthInside", (
        info_flippedLower_,
        info_flippedUpper_,
        tickLower_mint,
        tickUpper_mint,
        slot0_.tick,
        feeGrowthGlobal0X128_,
        feeGrowthGlobal1X128_
    )) : INVALID_OPERATION;

    const feeGrowthInside0X128 = retVal_getFeeGrowthInside[0];
    const feeGrowthInside1X128 = retVal_getFeeGrowthInside[1];

    var liquidityNext = 0;
    if (amount_mint = 0) then begin
        do_require(position.liquidity_PosInfo > 0, "NP"); // disallow pokes for 0 liquidity positions
        liquidityNext := position.liquidity_PosInfo
    end else begin
        liquidityNext := position.liquidity_PosInfo + amount_mint
    end;

    // calculate accumulated fees // TOOD + fullMath 512 bit operatoin
    var tokensOwed0: nat ?= int_to_nat((feeGrowthInside0X128 - position.feeGrowthInside0LastX128_PosInfo) * position.liquidity_PosInfo div Q128) : INVALID_OPERATION;
    var tokensOwed1: nat ?= int_to_nat((feeGrowthInside1X128 - position.feeGrowthInside1LastX128_PosInfo) * position.liquidity_PosInfo div Q128) : INVALID_OPERATION;

    // update the position
    if (amount_mint <> 0) then position.liquidity_PosInfo := liquidityNext;
    position.feeGrowthInside0LastX128_PosInfo := feeGrowthInside0X128;
    position.feeGrowthInside1LastX128_PosInfo := feeGrowthInside1X128;
    if ((tokensOwed0 > 0) or (tokensOwed1 > 0)) then begin
        // overflow is acceptable, have to withdraw before you hit type(uint128).max fees
        position.tokensOwed0_PosInfo += tokensOwed0;
        position.tokensOwed1_PosInfo += tokensOwed1
    end;

    return position
}