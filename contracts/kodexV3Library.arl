archetype kodexV3Library(const mathLib: address)

constant INVALID_OPERATION: string = "ERR"

constant MIN_TICK: int = -887272
constant MAX_TICK: int = -MIN_TICK
/// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
constant Q128: nat = 1 <<| 128
constant UNIX_START_TIME: date = 1970-01-01
/// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
constant MIN_SQRT_RATIO: nat = 4295128739
/// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
constant MAX_SQRT_RATIO: nat = 1461446703485210103287273052203988822378723970342
constant MAX_UINT256: nat = 115792089237316195423570985008687907853269984665640564039457584007913129639935

enum token_type = 
| tez_token<unit>
| fa12<address>
| fa20<address * nat>

/**
** Valid compare cases:
**     tez <=> fa12
**     tez <=> fa20
**     fa12 <=> fa12
**     fa12 <=> fa20
**     fa20 <=> fa20
**
** Invalid compare cases:
**     tez <=> tez
**
** Results of compare:
**        A : B
**      tez : tez  => 2
**      tez : fa12 => 1
**      tez : fa20 => 1
**
**     fa12 : tez  => -1
**     fa12 : fa12 => -1, 0, 1
**     fa12 : fa20 => 1
**
**     fa20 : tez  => -1
**     fa20 : fa12 => -1
**     fa20 : fa20 => -1, 0, 1
**
** Rule for FA20:
**     token_address < token_address => -1
**     token_address = token_address => 
**          token_id < token_id => -1
**          token_id = token_id =>  0
**          token_id > token_id =>  1
**     token_address > token_address =>  1
**
** Rule:
**     -1 when tokenA < tokenB
**      0 when tokenA = tokenB
**      1 when tokenA > tokenB
**      2 when Invalid Compare
**/
view tokenCompare(tokenA: token_type, tokenB: token_type) : int {
    match tokenA with
    | tez_token(tez_A_type) -> begin
        match tokenB with
        | tez_token(tez_B_type) -> return 2
        | fa12(fa12_B_type) -> return 1
        | fa20(fa20_B_type_address, fa20_B_type_id) -> return 1
        end
    end
    | fa12(fa12_A_type) -> begin
        match tokenB with
        | tez_token(tez_B_type) -> return (-1)
        | fa12(fa12_B_type) -> return (fa12_A_type <=> fa12_B_type)
        | fa20(fa20_B_type_address, fa20_B_type_id) -> return 1
        end
    end
    | fa20(fa20_A_type_address, fa20_A_type_id) -> begin
        match tokenB with
        | tez_token(tez_B_type) -> return (-1)
        | fa12(fa12_B_type) -> return (-1)
        | fa20(fa20_B_type_address, fa20_B_type_id) -> begin
            var ret: int = (fa20_A_type_address <=> fa20_B_type_address);
            if ret = 0 then ret := (fa20_A_type_id <=> fa20_B_type_id);
            return ret
        end
        end
    end
    end
}

view convertTokenType(x : token_type) : or<unit, or<address, (address * nat)>> {
    return (
        match x with
        | tez_token x -> left<unit, or<address, (address * nat)>>(Unit)
        | fa12 x -> right<unit, or<address, (address * nat)>>(left<address, (address * nat)>(x))
        | fa20 (x, y) -> right<unit, or<address, (address * nat)>>(right<address, (address * nat)>((x, y)))
        end
    )
}

record PoolKey {
    token0_poolKey: address;
    token1_poolKey: address;
    fee_poolKey: nat
} as (((token0, token1), fee))

// record SwapCallbackData {
//     path_SwapCallbackData: bytes;
//     payer_SwapCallbackData: address;
// }

/// @inheritdoc IkodexV3PoolState
record Slot0 {
    // the current price
    // the current tick
    sqrtPriceX96: nat;
    tick: int;
    // the most-recently updated index of the observations array
    observationIndex: nat;
    // the current maximum number of observations that are being stored
    observationCardinality: nat;
    // the next maximum number of observations to store, triggered in observations.write
    observationCardinalityNext: nat;
    // the current protocol fee as a percentage of the swap fee taken on withdrawal
    // represented as an integer denominator (1/x)%
    feeProtocol: nat;
    // whether the pool is locked
    unlocked: bool;
}

// accumulated protocol fees in token0/token1 units
record ProtocolFees {
    token0_fees: nat;
    token1_fees: nat;
} as ((token0, token1))

// info stored for each initialized individual tick
record TickInfo {
    // the total position liquidity that references this tick
    liquidityGross: nat;
    // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),
    liquidityNet: int;
    // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    feeGrowthOutside0X128: nat;
    feeGrowthOutside1X128: nat;
    // the cumulative tick value on the other side of the tick
    tickCumulativeOutside: int;
    // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    secondsPerLiquidityOutsideX128: nat;
    // the seconds spent on the other side of the tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    secondsOutside: nat;
    // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross <> 0
    // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks
    %initialized: bool;
}

record PositionInfo {
    // the amount of liquidity owned by this position
    liquidity_PosInfo: nat;
    // fee growth per unit of liquidity as of the last update to liquidity or fees owed
    feeGrowthInside0LastX128_PosInfo: nat;
    feeGrowthInside1LastX128_PosInfo: nat;
    // the fees owed to the position owner in token0/token1
    tokensOwed0_PosInfo: nat;
    tokensOwed1_PosInfo: nat;
} as ((liquidity, (feeGrowthInside0LastX128, feeGrowthInside1LastX128), (tokensOwed0, tokensOwed1)))

record Observation {
    // the block timestamp of the observation
    blockTimestamp_Obs: nat;
    // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized
    tickCumulative_Obs: int;
    // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized
    secondsPerLiquidityCumulativeX128_Obs: nat;
    // whether or not the observation is initialized
    initialized_Obs: bool;
} as ((blockTimestamp, (tickCumulative, secondsPerLiquidityCumulativeX128, %initialized)))

view checkTicks(tickLower: int, tickUpper: int): bool {
    do_require(tickLower < tickUpper, "TLU");
    do_require(tickLower >= MIN_TICK, "TLM");
    do_require(tickUpper <= MAX_TICK, "TUM");
    return true
}

view tickSpacingToMaxLpPerTick(tickSpacing_: int): nat {
    const minTick = (MIN_TICK div tickSpacing_) * tickSpacing_;
    const maxTick = (MAX_TICK div tickSpacing_) * tickSpacing_;
    const numTicks: int = (maxTick - minTick) div tickSpacing_ + 1;
    const retVal = int_to_nat((Q128 - 1) div numTicks) ? the : 0;
    return retVal
}

/// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.
view blockTimestamp_(): nat {
    const timestamp ?= int_to_nat((now - UNIX_START_TIME) div 1s) : INVALID_OPERATION;
    return timestamp
    // return uint32(block.timestamp); // truncation is desired
}

view tickMathGetSqrtRatioAtTick(tick_tickMathGetSqrtRatioAtTick: int) : nat {
    const retVal ?= call_view<nat>(mathLib, "tickMathGetSqrtRatioAtTick", tick_tickMathGetSqrtRatioAtTick) : INVALID_OPERATION;
    return retVal
}

view tickMathGetTickAtSqrtRatio(sqrtPriceX96_getTickAtSqrtRatio: nat) : int {
    const retVal ?= call_view<int>(mathLib, "tickMathGetTickAtSqrtRatio", sqrtPriceX96_getTickAtSqrtRatio) : INVALID_OPERATION;
    return retVal
}

view lte_tickBmpNITWOW(
    time: nat,
    a: nat,
    b: nat
) : bool {
    const retVal ?= call_view<bool>(mathLib, "lte_tickBmpNITWOW", (time, a, b)) : INVALID_OPERATION;
    return retVal
}

/// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.
/// The result may be the same observation, or adjacent observations.
/// @dev The answer must be contained in the array, used when the target is located within the stored observation
/// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation
/// @param self The stored oracle array
/// @param time The current block.timestamp
/// @param target The timestamp at which the reserved observation should be for
/// @param index The index of the observation that was most recently written to the observations array
/// @param cardinality The number of populated elements in the oracle array
/// @return beforeOrAt The observation recorded before, or at, the target
/// @return atOrAfter The observation recorded at, or after, the target
view binarySearch(
    poolAddress: address,
    time_binarySearch: nat,
    target_binarySearch: nat,
    index_binarySearch: nat,
    cardinality_binarySearch: nat
) : Observation * Observation {
    var l = (index_binarySearch + 1) % cardinality_binarySearch; // oldest observation
    var r = l + cardinality_binarySearch - 1; // newest observation
    var beforeOrAt: Observation = {0; 0; 0; false};
    var atOrAfter: Observation = {0; 0; 0; false};
    var i = 0;
    var condWhile = true;
    while condWhile do 
        i ?:= int_to_nat((l + r) div 2) : INVALID_OPERATION;

        beforeOrAt ?:= call_view<Observation>(poolAddress, "getObservation", (i % cardinality_binarySearch)) : INVALID_OPERATION;

        // we've landed on an uninitialized tick, keep searching higher (more recently)
        if (beforeOrAt.initialized_Obs = false) then
            l := i + 1
        else begin
            atOrAfter ?:= call_view<Observation>(poolAddress, "getObservation", ((i + 1) % cardinality_binarySearch)) : INVALID_OPERATION;

            var targetAtOrAfter ?= call_view<bool>(self_address, "lte_tickBmpNITWOW", (time_binarySearch, beforeOrAt.blockTimestamp_Obs, target_binarySearch)) : INVALID_OPERATION;
            const cond_val ?= call_view<bool>(self_address, "lte_tickBmpNITWOW", (time_binarySearch, target_binarySearch, atOrAfter.blockTimestamp_Obs)) : INVALID_OPERATION;

            // check if we've found the answer!
            if (targetAtOrAfter and cond_val) then
                condWhile := false;

            if (targetAtOrAfter = false) then r := i - 1
            else l := i + 1
        end
    done;
    return ((beforeOrAt, atOrAfter))
}

view transform(
    last_transform_param: Observation,
    blockTimestamp_transform_param: nat,
    tick_transform_param: int,
    liquidity_transform_param: nat
) : Observation {
    const delta ?= int_to_nat(blockTimestamp_transform_param - last_transform_param.blockTimestamp_Obs) : INVALID_OPERATION;
    const tickCumulative_val = last_transform_param.tickCumulative_Obs + tick_transform_param * delta;
    const secondsPerLiquidityCumulativeX128_val = 
        last_transform_param.secondsPerLiquidityCumulativeX128_Obs + ((delta <<| 128) div (liquidity_transform_param > 0 ? liquidity_transform_param : 1));

    const retVal: Observation = {
        blockTimestamp_transform_param;
        tickCumulative_val;
        secondsPerLiquidityCumulativeX128_val;
        true
    };

    return retVal
}

view getSurroundingObservations(
    poolAddress: address,
    time_getSurroundingObservations: nat,
    target_getSurroundingObservations: nat,
    tick_getSurroundingObservations: int,
    index_getSurroundingObservations: nat,
    liquidity_getSurroundingObservations: nat,
    cardinality_getSurroundingObservations: nat
) : Observation * Observation {
    // optimistically set before to the newest observation
    var beforeOrAt: Observation ?= call_view<Observation>(poolAddress, "getObservation", index_getSurroundingObservations) : INVALID_OPERATION;
    var atOrAfter: Observation = {0; 0; 0; false};

    const cond_val ?= call_view<bool>(
        self_address, 
        "lte_tickBmpNITWOW", 
        (time_getSurroundingObservations, beforeOrAt.blockTimestamp_Obs, target_getSurroundingObservations)) : INVALID_OPERATION;
    // if the target is chronologically at or after the newest observation, we can early return
    if (cond_val) then begin
        if (beforeOrAt.blockTimestamp_Obs = target_getSurroundingObservations) then
            // if newest observation equals target, we're in the same block, so we can ignore atOrAfter
            return ((beforeOrAt, atOrAfter))
        else begin
            const ret_Val ?= call_view<Observation>(
                self_address, 
                "transform", 
                (beforeOrAt, target_getSurroundingObservations, tick_getSurroundingObservations, liquidity_getSurroundingObservations)) : INVALID_OPERATION;
            // otherwise, we need to transform
            return ((beforeOrAt, ret_Val))
        end
    end else begin
        // now, set before to the oldest observation
        beforeOrAt ?:= call_view<Observation>(
            poolAddress, 
            "getObservation", ((index_getSurroundingObservations + 1) % cardinality_getSurroundingObservations)
        ) : INVALID_OPERATION;
        if (beforeOrAt.initialized_Obs = false) then
            beforeOrAt ?:= call_view<Observation>(poolAddress, "getObservation", 0) : INVALID_OPERATION;

        const require_cond ?= call_view<bool>(
            self_address, 
            "lte_tickBmpNITWOW", 
            (time_getSurroundingObservations, beforeOrAt.blockTimestamp_Obs, target_getSurroundingObservations)
        ) : INVALID_OPERATION;
        // ensure that the target is chronologically at or after the oldest observation
        do_require(require_cond, "OLD");

        const binarySearch_ret ?= call_view<Observation * Observation>(
            self_address, 
            "binarySearch",
            (poolAddress, time_getSurroundingObservations, target_getSurroundingObservations, index_getSurroundingObservations, cardinality_getSurroundingObservations)
        ) : INVALID_OPERATION;
        // if we've reached this point, we have to binary search
        return binarySearch_ret
    end
}

view observationsObserveSingle(
    poolAddress: address,
    time_observeSingle: nat,
    secondsAgo_observeSingle: nat,
    liquidity_observeSingle: nat
) : int * nat {
    const slot0 ?= call_view<Slot0>(poolAddress, "getSlot0", Unit) : INVALID_OPERATION;
    const tick_observeSingle = slot0.tick;
    const index_observeSingle = slot0.observationIndex;
    const cardinality_observeSingle = slot0.observationCardinality;
    if (secondsAgo_observeSingle = 0) then begin
        var last: Observation ?= call_view<Observation>(poolAddress, "getObservation", index_observeSingle) : INVALID_OPERATION;
        if (last.blockTimestamp_Obs <> time_observeSingle) then 
            last ?:= call_view<Observation>(self_address, "transform", (last, time_observeSingle, tick_observeSingle, liquidity_observeSingle)) : INVALID_OPERATION;
        const val1 = last.tickCumulative_Obs;
        const val2 = last.secondsPerLiquidityCumulativeX128_Obs;
        return ((val1, val2))
    end else begin

        var target ?= int_to_nat(time_observeSingle - secondsAgo_observeSingle) : INVALID_OPERATION;

        const retVal ?= call_view<Observation * Observation>(self_address, "getSurroundingObservations", (
            poolAddress,
            time_observeSingle,
            target,
            tick_observeSingle,
            index_observeSingle,
            liquidity_observeSingle,
            cardinality_observeSingle
        )) : INVALID_OPERATION;
        const beforeOrAt = retVal[0];
        const atOrAfter = retVal[1];

        if (target = beforeOrAt.blockTimestamp_Obs) then 
            // we're at the left boundary
            return ((beforeOrAt.tickCumulative_Obs, beforeOrAt.secondsPerLiquidityCumulativeX128_Obs))
        else if (target = atOrAfter.blockTimestamp_Obs) then
            // we're at the right boundary
            return ((atOrAfter.tickCumulative_Obs, atOrAfter.secondsPerLiquidityCumulativeX128_Obs))
        else begin
            // we're in the middle
            const observationTimeDelta = atOrAfter.blockTimestamp_Obs - beforeOrAt.blockTimestamp_Obs;
            const targetDelta = target - beforeOrAt.blockTimestamp_Obs;
            const retVal1 = beforeOrAt.tickCumulative_Obs + ((atOrAfter.tickCumulative_Obs - beforeOrAt.tickCumulative_Obs) div observationTimeDelta) * targetDelta;
            const retVal2_int = 
                beforeOrAt.secondsPerLiquidityCumulativeX128_Obs + 
                (atOrAfter.secondsPerLiquidityCumulativeX128_Obs - beforeOrAt.secondsPerLiquidityCumulativeX128_Obs) * targetDelta div observationTimeDelta;
            const retVal2 ?= int_to_nat(retVal2_int) : INVALID_OPERATION;
            return ((retVal1, retVal2))
        end
    end
}

/// @notice Retrieves fee growth data
/// @param self The mapping containing all tick information for initialized ticks
/// @param tickLower The lower tick boundary of the position
/// @param tickUpper The upper tick boundary of the position
/// @param tickCurrent The current tick
/// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
/// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
/// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
/// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
view getFeeGrowthInside(
    poolAddress: address,
    tickLower_getFeeGrowthInside: int,
    tickUpper_getFeeGrowthInside: int,
    feeGrowthGlobal0X128_getFeeGrowthInside: nat,
    feeGrowthGlobal1X128_getFeeGrowthInside: nat
) : nat * nat {
    const slot0 ?= call_view<Slot0>(poolAddress, "getSlot0", Unit) : INVALID_OPERATION;
    const tickCurrent_getFeeGrowthInside: int = slot0.tick;
    const lower ?= call_view<TickInfo>(poolAddress, "getTick", tickLower_getFeeGrowthInside): INVALID_OPERATION;
    const upper ?= call_view<TickInfo>(poolAddress, "getTick", tickUpper_getFeeGrowthInside): INVALID_OPERATION;
    // calculate fee growth below
    var feeGrowthBelow0X128 = 0;
    var feeGrowthBelow1X128 = 0;
    if (tickCurrent_getFeeGrowthInside >= tickLower_getFeeGrowthInside) then begin
        feeGrowthBelow0X128 := lower.feeGrowthOutside0X128;
        feeGrowthBelow1X128 := lower.feeGrowthOutside1X128;
    end else begin
        feeGrowthBelow0X128 ?:= int_to_nat(feeGrowthGlobal0X128_getFeeGrowthInside - lower.feeGrowthOutside0X128) : INVALID_OPERATION;
        feeGrowthBelow1X128 ?:= int_to_nat(feeGrowthGlobal1X128_getFeeGrowthInside - lower.feeGrowthOutside1X128) : INVALID_OPERATION;
    end;

    // calculate fee growth above
    var feeGrowthAbove0X128 = 0;
    var feeGrowthAbove1X128 = 0;
    if (tickCurrent_getFeeGrowthInside < tickUpper_getFeeGrowthInside) then begin
        feeGrowthAbove0X128 := upper.feeGrowthOutside0X128;
        feeGrowthAbove1X128 := upper.feeGrowthOutside1X128;
    end else begin
        feeGrowthAbove0X128 ?:= int_to_nat(feeGrowthGlobal0X128_getFeeGrowthInside - upper.feeGrowthOutside0X128) : INVALID_OPERATION;
        feeGrowthAbove1X128 ?:= int_to_nat(feeGrowthGlobal1X128_getFeeGrowthInside - upper.feeGrowthOutside1X128) : INVALID_OPERATION;
    end;

    const feeGrowthInside0X128 ?= int_to_nat(feeGrowthGlobal0X128_getFeeGrowthInside - feeGrowthBelow0X128 - feeGrowthAbove0X128) : INVALID_OPERATION;
    const feeGrowthInside1X128 ?= int_to_nat(feeGrowthGlobal1X128_getFeeGrowthInside - feeGrowthBelow1X128 - feeGrowthAbove1X128) : INVALID_OPERATION;
    return ((feeGrowthInside0X128, feeGrowthInside1X128))
}

view sqrtPriceMathGetAmount0D_rd(
    sqrtRatioAX96_sPMGA0D: nat,
    sqrtRatioBX96_sPMGA0D: nat,
    liquidity_sPMGA0D: nat,
    roundUp_sPMGA0D: bool
) : nat {
    const retVal ?= call_view<nat>(mathLib, "sqrtPriceMathGetAmount0D_rd", (sqrtRatioAX96_sPMGA0D, sqrtRatioBX96_sPMGA0D, liquidity_sPMGA0D, roundUp_sPMGA0D)) : INVALID_OPERATION;
    return retVal
}

view sqrtPriceMathGetAmount0Delta(
    sqrtRatioAX96_sPMGA0D: nat,
    sqrtRatioBX96_sPMGA0D: nat,
    liquidity_sPMGA0D: int
) : int {
    const retVal ?= call_view<int>(mathLib, "sqrtPriceMathGetAmount0Delta", (sqrtRatioAX96_sPMGA0D, sqrtRatioBX96_sPMGA0D, liquidity_sPMGA0D)) : INVALID_OPERATION;
    return retVal
}

view sqrtPriceMathGetAmount1D_rd(
    sqrtRatioAX96_sPMGA1D: nat,
    sqrtRatioBX96_sPMGA1D: nat,
    liquidity_sPMGA1D: nat,
    roundUp_sPMGA1D: bool
) : nat {
    const retVal ?= call_view<nat>(mathLib, "sqrtPriceMathGetAmount1D_rd", (sqrtRatioAX96_sPMGA1D, sqrtRatioBX96_sPMGA1D, liquidity_sPMGA1D, roundUp_sPMGA1D)) : INVALID_OPERATION;
    return retVal
}

view sqrtPriceMathGetAmount1Delta(
    sqrtRatioAX96_sPMGA1D: nat,
    sqrtRatioBX96_sPMGA1D: nat,
    liquidity_sPMGA1D: int
) : int {
    const retVal ?= call_view<int>(mathLib, "sqrtPriceMathGetAmount1Delta", (sqrtRatioAX96_sPMGA1D, sqrtRatioBX96_sPMGA1D, liquidity_sPMGA1D)) : INVALID_OPERATION;
    return retVal
}

view bitMathMostSignificantBit(xx: nat) : nat {
    const retVal ?= call_view<nat>(mathLib, "bitMathMostSignificantBit", (xx)) : INVALID_OPERATION;
    return retVal
}

view bitMathLeastSignificantBit(xx: nat) : nat {
    const retVal ?= call_view<nat>(mathLib, "bitMathLeastSignificantBit", (xx)) : INVALID_OPERATION;
    return retVal
}

view tickBmpNextInitTickWithOneW(
    poolAddress: address,
    tick_tickBmpNITWOWord: int,
    tickSpacing_tickBmpNITWOWord: int,
    lte_tickBmpNITWOWord: bool
) : int * bool {
    const retVal ?= call_view<int * bool>(
        mathLib, 
        "tickBmpNextInitTickWithOneW", 
        (poolAddress, tick_tickBmpNITWOWord, tickSpacing_tickBmpNITWOWord, lte_tickBmpNITWOWord)
    ) : INVALID_OPERATION;
    return retVal
}

view sqrtPMathGetNSqrtPFromA0RUp(
    sqrtPX96_sqrtPMGNSPFromA0RU: nat,
    liquidity_sqrtPMGNSPFromA0RU: nat,
    amount_sqrtPMGNSPFromA0RU: nat,
    add_sqrtPMGNSPFromA0RU: bool
) : nat {
    const retVal ?= call_view<nat>(
        mathLib, 
        "sqrtPMathGetNSqrtPFromA0RUp", 
        (sqrtPX96_sqrtPMGNSPFromA0RU, liquidity_sqrtPMGNSPFromA0RU, amount_sqrtPMGNSPFromA0RU, add_sqrtPMGNSPFromA0RU)
    ) : INVALID_OPERATION;
    return retVal
}

view sqrtPMathGetNSqrtPFromA1RDown(
    sqrtPX96_sqrtPMGNSPFromA1RD: nat,
    liquidity_sqrtPMGNSPFromA1RD: nat,
    amount_sqrtPMGNSPFromA1RD: nat,
    add_sqrtPMGNSPFromA1RD: bool
) : nat {
    const retVal ?= call_view<nat>(
        mathLib, 
        "sqrtPMathGetNSqrtPFromA1RDown", 
        (sqrtPX96_sqrtPMGNSPFromA1RD, liquidity_sqrtPMGNSPFromA1RD, amount_sqrtPMGNSPFromA1RD, add_sqrtPMGNSPFromA1RD)
    ) : INVALID_OPERATION;
    return retVal
}

view sqrtPMathGetNSqrtPFromIn(
    sqrtPX96_sqrlPriceMathGNSPFI: nat,
    liquidity_sqrlPriceMathGNSPFI: nat,
    amountIn_sqrlPriceMathGNSPFI: nat,
    zeroForOne_sqrlPriceMathGNSPFI: bool
) : nat {
    const retVal ?= call_view<nat>(
        mathLib, 
        "sqrtPMathGetNSqrtPFromIn", 
        (sqrtPX96_sqrlPriceMathGNSPFI, liquidity_sqrlPriceMathGNSPFI, amountIn_sqrlPriceMathGNSPFI, zeroForOne_sqrlPriceMathGNSPFI)
    ) : INVALID_OPERATION;
    return retVal
}

view sqrtPMathGetNSqrtPFromOut(
    sqrtPX96_sqrlPriceMathGNSPFO: nat,
    liquidity_sqrlPriceMathGNSPFO: nat,
    amountOut_sqrlPriceMathGNSPFO: nat,
    zeroForOne_sqrlPriceMathGNSPFO: bool
) : nat {
    const retVal ?= call_view<nat>(
        mathLib, 
        "sqrtPMathGetNSqrtPFromOut", 
        (sqrtPX96_sqrlPriceMathGNSPFO, liquidity_sqrlPriceMathGNSPFO, amountOut_sqrlPriceMathGNSPFO, zeroForOne_sqrlPriceMathGNSPFO)
    ) : INVALID_OPERATION;
    return retVal
}

view swapMathComputeSwapStep(
    sqrtRatioCurrentX96: nat,
    sqrtRatioTargetX96: nat,
    liquidity_swapMathComputeSwapStep: nat,
    amountRemaining: int,
    feePips: nat
) : nat * nat * nat * nat {
    const retVal ?= call_view<nat * nat * nat * nat>(
        mathLib, 
        "swapMathComputeSwapStep", 
        (sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity_swapMathComputeSwapStep, amountRemaining, feePips)
    ) : INVALID_OPERATION;
    return retVal
}

/// @inheritdoc IkodexV3PoolDerivedState
view snapshotCumulativesInside(poolAddress: address, tickLower: int, tickUpper: int, liquidity: nat): int * nat * nat
{
    const lower ?= call_view<TickInfo>(poolAddress, "getTick", tickLower): INVALID_OPERATION;
    const upper ?= call_view<TickInfo>(poolAddress, "getTick", tickUpper): INVALID_OPERATION;
    do_require(tickLower < tickUpper, "TLU");
    do_require(tickLower >= MIN_TICK, "TLM");
    do_require(tickUpper <= MAX_TICK, "TUM");

    var tickCumulativeInside: int = 0;
    var secondsPerLiquidityInsideX128: nat = 0;
    var secondsInside: nat = 0;

    var tickCumulativeLower: int = 0;
    var tickCumulativeUpper: int = 0;
    var secondsPerLiquidityOutsideLowerX128: nat = 0;
    var secondsPerLiquidityOutsideUpperX128: nat = 0;
    var secondsOutsideLower: nat = 0;
    var secondsOutsideUpper: nat = 0;

    tickCumulativeLower := lower.tickCumulativeOutside;
    secondsPerLiquidityOutsideLowerX128 := lower.secondsPerLiquidityOutsideX128;
    secondsOutsideLower :=  lower.secondsOutside;
    do_require(lower.%initialized, INVALID_OPERATION);

    tickCumulativeUpper := upper.tickCumulativeOutside;
    secondsPerLiquidityOutsideUpperX128 := upper.secondsPerLiquidityOutsideX128;
    secondsOutsideUpper := upper.secondsOutside;
    do_require(upper.%initialized, INVALID_OPERATION);

    const slot0 ?= call_view<Slot0>(poolAddress, "getSlot0", Unit) : INVALID_OPERATION;
    if (slot0.tick < tickLower) then begin
        tickCumulativeInside := tickCumulativeLower - tickCumulativeUpper;
        secondsPerLiquidityInsideX128 ?:= int_to_nat(secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128) : INVALID_OPERATION;
        secondsInside ?:= int_to_nat(secondsOutsideLower - secondsOutsideUpper) : INVALID_OPERATION;
        return ((tickCumulativeInside, secondsPerLiquidityInsideX128, secondsInside))
    end else if (slot0.tick < tickUpper) then begin
        var time ?= call_view<nat>(self_address, "blockTimestamp_", Unit) : INVALID_OPERATION;
        const retVal ?= call_view<int * nat>(self_address, "observationsObserveSingle", (
            self_address,
            time,
            0,
            liquidity
        )) : INVALID_OPERATION;
        const tickCumulative: int = retVal[0];
        const secondsPerLiquidityCumulativeX128: nat = retVal[1];
        tickCumulativeInside := tickCumulative - tickCumulativeLower - tickCumulativeUpper;
        secondsPerLiquidityInsideX128 ?:= int_to_nat(secondsPerLiquidityCumulativeX128 - secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128) : INVALID_OPERATION;
        secondsInside ?:= int_to_nat(time - secondsOutsideLower - secondsOutsideUpper) : INVALID_OPERATION;
        return ((tickCumulativeInside, secondsPerLiquidityInsideX128, secondsInside))
    end else begin
        tickCumulativeInside := tickCumulativeUpper - tickCumulativeLower;
        secondsPerLiquidityInsideX128 ?:= int_to_nat(secondsPerLiquidityOutsideUpperX128 - secondsPerLiquidityOutsideLowerX128) : INVALID_OPERATION;
        secondsInside ?:= int_to_nat(secondsOutsideUpper - secondsOutsideLower) : INVALID_OPERATION;
        return ((tickCumulativeInside, secondsPerLiquidityInsideX128, secondsInside))
    end
}

/// @inheritdoc IkodexV3PoolDerivedState
view observe(poolAddress: address, secondsAgos: list<nat>, liquidity: nat) : list<int> * list<nat> {
    const slot0 ?= call_view<Slot0>(poolAddress, "getSlot0", Unit) : INVALID_OPERATION;
    do_require(slot0.observationCardinality > 0, "I");

    const time_val ?= call_view<nat>(self_address, "blockTimestamp_", Unit) : INVALID_OPERATION;
    var tickCumulatives: list<int> = [];
    var secondsPerLiquidityCumulativeX128s: list<nat> = [];
    var i = 0;
    while (i < length(secondsAgos)) do
        const retVal ?= call_view<int * nat>(self_address, "observationsObserveSingle", (
            time_val,
            (nth(secondsAgos, i) ? the : 0),
            liquidity
        )) : INVALID_OPERATION;
        tickCumulatives := concat(tickCumulatives, [retVal[0]]);
        secondsPerLiquidityCumulativeX128s := concat(secondsPerLiquidityCumulativeX128s, [retVal[1]]);
        i += 1
    done;
    return ((tickCumulatives, secondsPerLiquidityCumulativeX128s))
}

/// @inheritdoc IkodexV3PoolActions
view burn(
    tickLower: int,
    tickUpper: int,
    amount: nat,
    poolAddress: address
): nat * nat
{
    const slot0_ ?= call_view<Slot0>(poolAddress, "getSlot0", Unit) : INVALID_OPERATION;
    do_require(slot0_.unlocked, "LOK");

    const checkTicks_retVal ?= call_view<bool>(self_address, "checkTicks", (tickLower, tickUpper)) : INVALID_OPERATION;
    do_require(checkTicks_retVal, INVALID_OPERATION);
    var amount0: int = 0i;
    var amount1: int = 0i;

    if (amount <> 0) then begin
        if (slot0_.tick < tickLower) then begin
            // current tick is below the passed range; liquidity can only become in range by crossing from left to
            // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it
            const sqrtPriceMathGetAmount0Delta_param0 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickLower) : INVALID_OPERATION;
            const sqrtPriceMathGetAmount0Delta_param1 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickUpper) : INVALID_OPERATION;
            amount0 ?:= call_view<int>(self_address, "sqrtPriceMathGetAmount0Delta", (
                sqrtPriceMathGetAmount0Delta_param0,
                sqrtPriceMathGetAmount0Delta_param1,
                (amount-0)
            )) : INVALID_OPERATION;
        end else begin 
            if (slot0_.tick < tickUpper) then begin
                // early return if we've already written an observation this block
                const sqrtPriceMathGetAmount0Delta_param1 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickUpper) : INVALID_OPERATION;
                amount0 ?:= call_view<int>(self_address, "sqrtPriceMathGetAmount0Delta", (
                    slot0_.sqrtPriceX96,
                    sqrtPriceMathGetAmount0Delta_param1,
                    (amount-0)
                )) : INVALID_OPERATION;
                const sqrtPriceMathGetAmount1Delta_param0 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickLower) : INVALID_OPERATION;
                amount1 ?:= call_view<int>(self_address, "sqrtPriceMathGetAmount1Delta", (
                    sqrtPriceMathGetAmount1Delta_param0,
                    slot0_.sqrtPriceX96,
                    (amount - 0)
                )) : INVALID_OPERATION
            end else begin
                // current tick is above the passed range; liquidity can only become in range by crossing from right to
                // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it
                const sqrtPriceMathGetAmount1Delta_param0 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickLower) : INVALID_OPERATION;
                const sqrtPriceMathGetAmount1Delta_param1 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickUpper) : INVALID_OPERATION;
                amount1 ?:= call_view<int>(self_address, "sqrtPriceMathGetAmount1Delta", (
                    sqrtPriceMathGetAmount1Delta_param0,
                    sqrtPriceMathGetAmount1Delta_param1,
                    (amount - 0)
                )) : INVALID_OPERATION
            end
        end
    end;
    // process when amount0 and amount1 is less than 0
    if amount0 < 0 then begin
        amount0 := MAX_UINT256 - amount0 + 1; 
    end;

    if amount1 < 0 then begin
        amount1 := MAX_UINT256 - amount1 + 1; 
    end;

    // var amount0_nat: nat ?= int_to_nat(-amount0) : INVALID_OPERATION;
    var amount0_nat: nat ?= int_to_nat(amount0) : INVALID_OPERATION;

    // const amount1_nat: nat ?= int_to_nat(-amount1) : INVALID_OPERATION;
    const amount1_nat: nat ?= int_to_nat(amount1) : INVALID_OPERATION;

    return ((amount0_nat, amount1_nat))
}

/// @inheritdoc IkodexV3PoolActions
view burn_PositionInfo_view(
    amount: nat,
    caller_address: address,
    poolAddress: address,
    tickLower: int,
    tickUpper: int,
    feeGrowthGlobal0X128_: nat,
    feeGrowthGlobal1X128_: nat
) : PositionInfo
{
    const slot0_ ?= call_view<Slot0>(poolAddress, "getSlot0", Unit) : INVALID_OPERATION;
    do_require(slot0_.unlocked, "LOK");
    const checkTicks_retVal ?= call_view<bool>(self_address, "checkTicks", (tickLower, tickUpper)) : INVALID_OPERATION;
    do_require(checkTicks_retVal, INVALID_OPERATION);

    var position ?= call_view<PositionInfo>(
        poolAddress, 
        "getPositionInfo", 
        (caller_address, tickLower, tickUpper)
    ): INVALID_OPERATION;

    const retVal_getFeeGrowthInside: (nat * nat) ?= call_view<(nat * nat)>(self_address, "getFeeGrowthInside", (
        poolAddress,
        tickLower,
        tickUpper,
        feeGrowthGlobal0X128_,
        feeGrowthGlobal1X128_
    )) : INVALID_OPERATION;

    const feeGrowthInside0X128 = retVal_getFeeGrowthInside[0];
    const feeGrowthInside1X128 = retVal_getFeeGrowthInside[1];

    var liquidityNext = 0;
    if (amount = 0) then begin
        do_require(position.liquidity_PosInfo > 0, "NP"); // disallow pokes for 0 liquidity positions
        liquidityNext := position.liquidity_PosInfo
    end else begin
        liquidityNext := position.liquidity_PosInfo + amount
    end;

    // calculate accumulated fees // TOOD + fullMath 512 bit operatoin
    var tokensOwed0: nat ?= int_to_nat((feeGrowthInside0X128 - position.feeGrowthInside0LastX128_PosInfo) * position.liquidity_PosInfo div Q128) : INVALID_OPERATION;
    var tokensOwed1: nat ?= int_to_nat((feeGrowthInside1X128 - position.feeGrowthInside1LastX128_PosInfo) * position.liquidity_PosInfo div Q128) : INVALID_OPERATION;

    // update the position
    if (amount <> 0) then position.liquidity_PosInfo := liquidityNext;
    position.feeGrowthInside0LastX128_PosInfo := feeGrowthInside0X128;
    position.feeGrowthInside1LastX128_PosInfo := feeGrowthInside1X128;
    if ((tokensOwed0 > 0) or (tokensOwed1 > 0)) then begin
        // overflow is acceptable, have to withdraw before you hit type(uint128).max fees
        position.tokensOwed0_PosInfo += tokensOwed0;
        position.tokensOwed1_PosInfo += tokensOwed1
    end;
    // }

    var amount0: int = 0;
    var amount1: int = 0;

    if (amount <> 0) then begin
        if (slot0_.tick < tickLower) then begin
            // current tick is below the passed range; liquidity can only become in range by crossing from left to
            // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it
            const sqrtPriceMathGetAmount0Delta_param0 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickLower) : INVALID_OPERATION;
            const sqrtPriceMathGetAmount0Delta_param1 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickUpper) : INVALID_OPERATION;
            amount0 ?:= call_view<int>(self_address, "sqrtPriceMathGetAmount0Delta", (
                sqrtPriceMathGetAmount0Delta_param0,
                sqrtPriceMathGetAmount0Delta_param1,
                (amount - 0)
            )) : INVALID_OPERATION;
        end else begin 
            if (slot0_.tick < tickUpper) then begin
                const sqrtPriceMathGetAmount0Delta_param1 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickUpper) : INVALID_OPERATION;
                amount0 ?:= call_view<int>(self_address, "sqrtPriceMathGetAmount0Delta", (
                    slot0_.sqrtPriceX96,
                    sqrtPriceMathGetAmount0Delta_param1,
                    (amount - 0)
                )) : INVALID_OPERATION;
                const sqrtPriceMathGetAmount1Delta_param0 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickLower) : INVALID_OPERATION;
                amount1 ?:= call_view<int>(self_address, "sqrtPriceMathGetAmount1Delta", (
                    sqrtPriceMathGetAmount1Delta_param0,
                    slot0_.sqrtPriceX96,
                    (amount - 0)
                )) : INVALID_OPERATION;
            end else begin
                // current tick is above the passed range; liquidity can only become in range by crossing from right to
                // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it
                const sqrtPriceMathGetAmount1Delta_param0 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickLower) : INVALID_OPERATION;
                const sqrtPriceMathGetAmount1Delta_param1 ?= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", tickUpper) : INVALID_OPERATION;
                amount1 ?:= call_view<int>(self_address, "sqrtPriceMathGetAmount1Delta", (
                    sqrtPriceMathGetAmount1Delta_param0,
                    sqrtPriceMathGetAmount1Delta_param1,
                    (amount - 0)
                )) : INVALID_OPERATION
            end
        end
    end;

    if amount0 < 0 then begin
        amount0 := MAX_UINT256 - amount0 + 1; 
    end;

    if amount1 < 0 then begin
        amount1 := MAX_UINT256 - amount1 + 1; 
    end;

    const amount0_nat ?= int_to_nat(amount0) : INVALID_OPERATION;
    const amount1_nat ?= int_to_nat(amount1) : INVALID_OPERATION;

    if (amount0_nat > 0 or amount1_nat > 0) then begin
        position.tokensOwed0_PosInfo := position.tokensOwed0_PosInfo + amount0_nat;
        position.tokensOwed1_PosInfo := position.tokensOwed1_PosInfo + amount1_nat
    end;

    return position
}

view mint_PositionInfo_view(
    amount: nat,
    recipient: address,
    poolAddress: address,
    tickLower: int,
    tickUpper: int,
    feeGrowthGlobal0X128_: nat,
    feeGrowthGlobal1X128_: nat
) : PositionInfo
{
    const slot0_ ?= call_view<Slot0>(poolAddress, "getSlot0", Unit) : INVALID_OPERATION;
    do_require(slot0_.unlocked, "LOK");
    do_require(amount > 0, INVALID_OPERATION);

    const checkTicks_retVal ?= call_view<bool>(self_address, "checkTicks", (tickLower, tickUpper)) : INVALID_OPERATION;
    do_require(checkTicks_retVal, INVALID_OPERATION);

    var position ?= call_view<PositionInfo>(
        poolAddress, 
        "getPositionInfo", 
        (recipient, tickLower, tickUpper)
    ): INVALID_OPERATION;

    const retVal_getFeeGrowthInside: (nat * nat) ?= call_view<(nat * nat)>(self_address, "getFeeGrowthInside", (
        poolAddress,
        tickLower,
        tickUpper,
        feeGrowthGlobal0X128_,
        feeGrowthGlobal1X128_
    )) : INVALID_OPERATION;

    const feeGrowthInside0X128 = retVal_getFeeGrowthInside[0];
    const feeGrowthInside1X128 = retVal_getFeeGrowthInside[1];

    var liquidityNext = 0;
    if (amount = 0) then begin
        do_require(position.liquidity_PosInfo > 0, "NP"); // disallow pokes for 0 liquidity positions
        liquidityNext := position.liquidity_PosInfo
    end else begin
        liquidityNext := position.liquidity_PosInfo + amount
    end;

    // calculate accumulated fees // TOOD + fullMath 512 bit operatoin
    var tokensOwed0: nat ?= int_to_nat((feeGrowthInside0X128 - position.feeGrowthInside0LastX128_PosInfo) * position.liquidity_PosInfo div Q128) : INVALID_OPERATION;
    var tokensOwed1: nat ?= int_to_nat((feeGrowthInside1X128 - position.feeGrowthInside1LastX128_PosInfo) * position.liquidity_PosInfo div Q128) : INVALID_OPERATION;

    // update the position
    if (amount <> 0) then position.liquidity_PosInfo := liquidityNext;
    position.feeGrowthInside0LastX128_PosInfo := feeGrowthInside0X128;
    position.feeGrowthInside1LastX128_PosInfo := feeGrowthInside1X128;
    if ((tokensOwed0 > 0) or (tokensOwed1 > 0)) then begin
        // overflow is acceptable, have to withdraw before you hit type(uint128).max fees
        position.tokensOwed0_PosInfo += tokensOwed0;
        position.tokensOwed1_PosInfo += tokensOwed1
    end;

    return position
}

// the top level state of the swap, the results of which are recorded in storage at the end
record SwapState {
    // the amount remaining to be swapped in/out of the input/output asset
    amountSpecifiedRemaining_swapState: int;
    // the amount already swapped out/in of the output/input asset
    amountCalculated_swapState: int;
    // current sqrt(price)
    sqrtPriceX96_swapState: nat;
    // the tick associated with the current price
    tick_swapState: int;
    // the global fee growth of the input token
    feeGrowthGlobalX128_swapState: nat;
    // amount of input token paid as protocol fee
    protocolFee_swapState: nat;
    // the current liquidity in range
    liquidity_swapState: nat;
} as ((amountSpecifiedRemaining, amountCalculated, sqrtPriceX96, tick, feeGrowthGlobalX128, protocolFee, liquidity))

record StepComputations {
    // the price at the beginning of the step
    sqrtPriceStartX96_stepComputations: nat;
    // the next tick to swap to from the current tick in the swap direction
    tickNext_stepComputations: int;
    // whether tickNext is initialized or not
    initialized_stepComputations: bool;
    // sqrt(price) for the next tick (1/0)
    sqrtPriceNextX96_stepComputations: nat;
    // how much is being swapped in in this step
    amountIn_stepComputations: nat;
    // how much is being swapped out
    amountOut_stepComputations: nat;
    // how much fee is being paid in
    feeAmount_stepComputations: nat;
} as ((sqrtPriceStartX96, tickNext, %initialized, sqrtPriceNextX96, amountIn, amountOut, feeAmount))

/// @inheritdoc IkodexV3PoolActions
view swap(
    zeroForOne: bool,
    amountSpecified: int,
    sqrtPriceLimitX96: nat,
    liquidity: nat,
    feeGrowthGlobal0X128: nat,
    feeGrowthGlobal1X128: nat,
    poolAddress: address,
    tickSpacing: int,
    fee: nat
): int * int {
    do_require(amountSpecified <> 0, "AS");
    const slot0Start: Slot0 ?= call_view<Slot0>(poolAddress, "getSlot0", Unit) : INVALID_OPERATION;
    do_require(slot0Start.unlocked, "LOK");
    do_require(
        zeroForOne
            ? ((sqrtPriceLimitX96 < slot0Start.sqrtPriceX96) and (sqrtPriceLimitX96 > MIN_SQRT_RATIO))
            : ((sqrtPriceLimitX96 > slot0Start.sqrtPriceX96) and (sqrtPriceLimitX96 < MAX_SQRT_RATIO)),
        "SPL"
    );

    const exactInput = amountSpecified > 0;

    var state_swap_param: SwapState = {
        amountSpecified;
        0;
        slot0Start.sqrtPriceX96;
        slot0Start.tick;
        (zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128);
        0;
        liquidity
    };

    // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit
    while ((state_swap_param.amountSpecifiedRemaining_swapState <> 0) and (state_swap_param.sqrtPriceX96_swapState <> sqrtPriceLimitX96)) do
        // memory is not storage
        var step: StepComputations = {0; 0; false; 0; 0; 0; 0};

        step.sqrtPriceStartX96_stepComputations := state_swap_param.sqrtPriceX96_swapState;

        const retVal ?= call_view<int * bool>(self_address, "tickBmpNextInitTickWithOneW", (
            poolAddress,
            state_swap_param.tick_swapState,
            tickSpacing,
            zeroForOne
        )) : INVALID_OPERATION;

        step.tickNext_stepComputations := retVal[0];
        step.initialized_stepComputations := retVal[1];

        // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds
        if (step.tickNext_stepComputations < MIN_TICK) then
            step.tickNext_stepComputations := MIN_TICK
        else begin
            if (step.tickNext_stepComputations > MAX_TICK) then
                step.tickNext_stepComputations := MAX_TICK
        end;

        // get the price for the next tick
        step.sqrtPriceNextX96_stepComputations ?:= call_view<nat>(self_address, "tickMathGetSqrtRatioAtTick", (step.tickNext_stepComputations)) : INVALID_OPERATION;

        // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted
        const retVal_computeSwapStep ?= call_view<nat * nat * nat * nat>(self_address, "swapMathComputeSwapStep", (
            state_swap_param.sqrtPriceX96_swapState,
            (zeroForOne ? step.sqrtPriceNextX96_stepComputations < sqrtPriceLimitX96 : step.sqrtPriceNextX96_stepComputations > sqrtPriceLimitX96)
                ? sqrtPriceLimitX96
                : step.sqrtPriceNextX96_stepComputations,
            state_swap_param.liquidity_swapState,
            state_swap_param.amountSpecifiedRemaining_swapState,
            fee
        )) : INVALID_OPERATION;
        state_swap_param.sqrtPriceX96_swapState := retVal_computeSwapStep[0];
        step.amountIn_stepComputations := retVal_computeSwapStep[1];
        step.amountOut_stepComputations := retVal_computeSwapStep[2];
        step.feeAmount_stepComputations := retVal_computeSwapStep[3];

        if (exactInput) then begin
            state_swap_param.amountSpecifiedRemaining_swapState -= (step.amountIn_stepComputations + step.feeAmount_stepComputations);
            state_swap_param.amountCalculated_swapState := state_swap_param.amountCalculated_swapState - step.amountOut_stepComputations
        end else begin
            state_swap_param.amountSpecifiedRemaining_swapState += step.amountOut_stepComputations;
            state_swap_param.amountCalculated_swapState := state_swap_param.amountCalculated_swapState + step.amountIn_stepComputations + step.feeAmount_stepComputations
        end;

        // shift tick if we reached the next price
        if (state_swap_param.sqrtPriceX96_swapState = step.sqrtPriceNextX96_stepComputations) then begin
            // if the tick is initialized, run the tick transition
            if (step.initialized_stepComputations) then begin

                const tick_param: int = step.tickNext_stepComputations;
                var tickInfo ?= call_view<TickInfo>(poolAddress, "getTick", tick_param) : INVALID_OPERATION;
                var liquidityNet_param: int = tickInfo.liquidityNet;

                // if we're moving leftward, we interpret liquidityNet as the opposite sign
                // safe because liquidityNet cannot be type(int128).min
                if (zeroForOne) then
                    liquidityNet_param := -liquidityNet_param;

                state_swap_param.liquidity_swapState ?:= int_to_nat(state_swap_param.liquidity_swapState + liquidityNet_param) : INVALID_OPERATION
            end;

            state_swap_param.tick_swapState := zeroForOne ? (step.tickNext_stepComputations - 1) : step.tickNext_stepComputations
        end else begin 
            if (state_swap_param.sqrtPriceX96_swapState <> step.sqrtPriceStartX96_stepComputations) then
                // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved
                state_swap_param.tick_swapState ?:= call_view<int>(self_address, "tickMathGetTickAtSqrtRatio", (state_swap_param.sqrtPriceX96_swapState)) : INVALID_OPERATION;
        end
    done;

    const amount0: int = (zeroForOne = exactInput)
        ? (amountSpecified - state_swap_param.amountSpecifiedRemaining_swapState)
        : state_swap_param.amountCalculated_swapState;
    const amount1: int = (zeroForOne = exactInput)
        ? state_swap_param.amountCalculated_swapState
        : (amountSpecified - state_swap_param.amountSpecifiedRemaining_swapState);
    return ((amount0, amount1))
}
