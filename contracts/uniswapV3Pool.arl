archetype uniswapV3Pool(factory: address, token0: address, token1: address)

// import LowGasSafeMath from "./libraries/LowGasSafeMath.tz"
// import SafeCast from "./libraries/SafeCast.tz"
// import Tick from "./libraries/Tick.tz"
// import TickBitmap from "./libraries/TickBitmap.tz"
// import Position from "./libraries/Position.tz"
// import Oracle from "./libraries/Oracle.tz"
// import FullMath from "./libraries/FullMath.tz"
// import FixedPoint128 from "./libraries/FixedPoint128.tz"
// import TransferHelper from "./libraries/TransferHelper.tz"
// import TickMath from "./libraries/TickMath.tz"
// import LiquidityMath from "./libraries/LiquidityMath.tz"
// import SqrtPriceMath from "./libraries/SqrtPriceMath.tz"
// import SwapMath from "./libraries/SwapMath.tz"
// import IUniswapV3PoolDeployer from "./interfaces/IUniswapV3PoolDeployer.tz"
// import IUniswapV3Factory from "./interfaces/IUniswapV3Factory.tz"
// import IERC20Minimal from "./interfaces/IERC20Minimal.tz"
// import IUniswapV3MintCallback from "./interfaces/callback/IUniswapV3MintCallback.tz"
// import IUniswapV3SwapCallback from "./interfaces/callback/IUniswapV3SwapCallback.tz"
// import IUniswapV3FlashCallback from "./interfaces/callback/IUniswapV3FlashCallback.tz"

constant INVALID_NAT             : string = "INVALID_NAT"
constant INVALID_RECORD          : string = "INVALID_RECORD"

constant TickMathMIN_TICK: int = -887272
constant TickMathMAX_TICK: int = -TickMathMIN_TICK
constant UnixStartTime: date = 1970-01-01
constant original: address = self_address

function noDelegateCall() : bool {
    do_fail_if(self_address <> original, ("DelegateCall", original));
    return true
}

variable fee: nat = 0
variable tickSpacing: int = 0
variable maxLiquidityPerTick: nat = 0

// using LowGasSafeMath for uint256;
// using LowGasSafeMath for int256;
// using SafeCast for uint256;
// using SafeCast for int256;
// using Tick for mapping(int24 => Tick.Info);
// using TickBitmap for mapping(int16 => uint256);
// using Position for mapping(bytes32 => Position.Info);
// using Position for Position.Info;
// using Oracle for Oracle.Observation[65535];

/// @inheritdoc IUniswapV3PoolState
record Slot0 {
    // the current price
    sqrtPriceX96: nat;
    // the current tick
    tick: int;
    // the most-recently updated index of the observations array
    observationIndex: nat;
    // the current maximum number of observations that are being stored
    observationCardinality: nat;
    // the next maximum number of observations to store, triggered in observations.write
    observationCardinalityNext: nat;
    // the current protocol fee as a percentage of the swap fee taken on withdrawal
    // represented as an integer denominator (1/x)%
    feeProtocol: nat;
    // whether the pool is locked
    unlocked: bool;
}

variable slot0: Slot0 = {
    sqrtPriceX96                = 0;
    tick                        = 0;
    observationIndex            = 0;
    observationCardinality      = 0;
    observationCardinalityNext  = 0;
    feeProtocol                 = 0;
    unlocked                    = false
}

/// @inheritdoc IUniswapV3PoolState
variable feeGrowthGlobal0X128 : nat = 0
/// @inheritdoc IUniswapV3PoolState
variable feeGrowthGlobal1X128 : nat = 0

// accumulated protocol fees in token0/token1 units
record ProtocolFees {
    token0_fees: nat;
    token1_fees: nat;
} as ((token0, token1))
/// @inheritdoc IUniswapV3PoolState
variable protocolFees: ProtocolFees = {
    token0_fees = 0;
    token1_fees = 0
}

/// @inheritdoc IUniswapV3PoolState
variable liquidity : nat = 0

// info stored for each initialized individual tick
record TickInfo {
    // the total position liquidity that references this tick
    liquidityGross: nat;
    // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),
    liquidityNet: int;
    // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    feeGrowthOutside0X128: nat;
    feeGrowthOutside1X128: nat;
    // the cumulative tick value on the other side of the tick
    tickCumulativeOutside: int;
    // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    secondsPerLiquidityOutsideX128: nat;
    // the seconds spent on the other side of the tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    secondsOutside: nat;
    // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0
    // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks
    %initialized: bool;
}

/// @inheritdoc IUniswapV3PoolState
asset ticks identified by tickId to big_map {
    tickId: int;
    info: TickInfo;
}
/// @inheritdoc IUniswapV3PoolState
asset tickBitmap identified by tick_tickBmp to big_map {
    tick_tickBmp : int;
    tickSpacing_tickBmp: nat = 0;
}
record PositionInfo {
    // the amount of liquidity owned by this position
    liquidity_PosInfo: nat;
    // fee growth per unit of liquidity as of the last update to liquidity or fees owed
    feeGrowthInside0LastX128_PosInfo: nat;
    feeGrowthInside1LastX128_PosInfo: nat;
    // the fees owed to the position owner in token0/token1
    tokensOwed0_PosInfo: nat;
    tokensOwed1_PosInfo: nat;
} as ((liquidity, (feeGrowthInside0LastX128, feeGrowthInside1LastX128), (tokensOwed0, tokensOwed1)))
/// @inheritdoc IUniswapV3PoolState
asset positions identified by positionId_owner positionId_tickLower positionId_tickUpper to big_map {
    positionId_owner: address;
    positionId_tickLower: int;
    positionId_tickUpper: int;
    positionInfo: PositionInfo;
}
record Observation {
    // the block timestamp of the observation
    blockTimestamp_Obs: nat;
    // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized
    tickCumulative_Obs: int;
    // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized
    secondsPerLiquidityCumulativeX128_Obs: nat;
    // whether or not the observation is initialized
    initialized_Obs: bool;
} as ((blockTimestamp, (tickCumulative, secondsPerLiquidityCumulativeX128, %initialized)))
/// @inheritdoc IUniswapV3PoolState
// Oracle.Observation[65535] public override observations;
variable observations: list<Observation> = []

/// @dev Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance
/// to a function before the pool is initialized. The reentrancy guard is required throughout the contract because
/// we use balance checks to determine the payment status of interactions such as mint, swap and flash.
// function lock() {
//     // do_require(slot0.unlocked, ("LOK", slot0.unlocked));
//     // slot0.unlocked := false;
//     // _;
//     // slot0.unlocked := true;
// }

/// @dev Prevents calling a function from anyone except the address returned by IUniswapV3Factory#owner()
function onlyFactoryOwner(): bool {
    const factoryOwner ?= call_view<address>(factory, "getOwner", Unit) : "VIEW_OWNER_ERR";
    do_require(caller = factoryOwner, "ONLY_FACTORY_OWNER_ERR");
    return true
}

/// @dev Common checks for valid tick inputs.
function checkTicks(tickLower: int, tickUpper: int): bool {
    do_require(tickLower < tickUpper, "TLU");
    do_require(tickLower >= TickMathMIN_TICK, "TLM");
    do_require(tickUpper <= TickMathMAX_TICK, "TUM");
    return true
}

/// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.
view blockTimestamp_(): nat {
    const timestamp ?= int_to_nat((now - UnixStartTime) div 1s) : INVALID_NAT;
    return timestamp
    // return uint32(block.timestamp); // truncation is desired
}

/// @dev Get the pool's balance of token0
/// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
/// check
// view balance0() /* private view returns */ : nat {
//     // (bool success, bytes memory data) = token0.staticcall(
//     //     abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this))
//     // );
//     // require(success && data.length >= 32);
//     // return abi.decode(data, (uint256));
//     return 0
// }

// /// @dev Get the pool's balance of token1
// /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
// /// check
// view balance1() /* private view returns */ : nat {
//     // (bool success, bytes memory data) = token1.staticcall(
//     //     abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this))
//     // );
//     // require(success && data.length >= 32);
//     // return abi.decode(data, (uint256));
//     return 0
// }

/// @inheritdoc IUniswapV3PoolDerivedState
// view snapshotCumulativesInside(tickLower: int, tickUpper: int): (
//         /* tickCumulativeInside: */ int *
//         /* secondsPerLiquidityInsideX128: */ nat *
//         /* secondsInside: */ nat
// )
// {
//     var retVal: (int * nat * nat) = (0,0,0);
//     if noDelegateCall() = false then
//         return retVal
//     // return (0,0,0)
//     // if checkTicks(tickLower, tickUpper) = false then
//     //     return (0,0,0)

//     // tickCumulativeLower: int;
//     // tickCumulativeUpper: int;
//     // secondsPerLiquidityOutsideLowerX128: nat;
//     // secondsPerLiquidityOutsideUpperX128: nat;
//     // secondsOutsideLower: nat;
//     // secondsOutsideUpper: nat;

//     // {
//     //     var lower: TickInfo = ticks[tickLower];
//     //     var upper: TickInfo = ticks[tickUpper];
//     //     bool initializedLower;
//     //     (tickCumulativeLower, secondsPerLiquidityOutsideLowerX128, secondsOutsideLower, initializedLower) = (
//     //         lower.tickCumulativeOutside,
//     //         lower.secondsPerLiquidityOutsideX128,
//     //         lower.secondsOutside,
//     //         lower.initialized
//     //     );
//     //     require(initializedLower);

//     //     bool initializedUpper;
//     //     (tickCumulativeUpper, secondsPerLiquidityOutsideUpperX128, secondsOutsideUpper, initializedUpper) = (
//     //         upper.tickCumulativeOutside,
//     //         upper.secondsPerLiquidityOutsideX128,
//     //         upper.secondsOutside,
//     //         upper.initialized
//     //     );
//     //     require(initializedUpper);
//     // }

//     // Slot0 memory _slot0 = slot0;

//     // if (_slot0.tick < tickLower) {
//     //     return (
//     //         tickCumulativeLower - tickCumulativeUpper,
//     //         secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128,
//     //         secondsOutsideLower - secondsOutsideUpper
//     //     );
//     // } else if (_slot0.tick < tickUpper) {
//     //     uint32 time = blockTimestamp_();
//     //     (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(
//     //         time,
//     //         0,
//     //         _slot0.tick,
//     //         _slot0.observationIndex,
//     //         liquidity,
//     //         _slot0.observationCardinality
//     //     );
//     //     return (
//     //         tickCumulative - tickCumulativeLower - tickCumulativeUpper,
//     //         secondsPerLiquidityCumulativeX128 -
//     //             secondsPerLiquidityOutsideLowerX128 -
//     //             secondsPerLiquidityOutsideUpperX128,
//     //         time - secondsOutsideLower - secondsOutsideUpper
//     //     );
//     // } else {
//     //     return (
//     //         tickCumulativeUpper - tickCumulativeLower,
//     //         secondsPerLiquidityOutsideUpperX128 - secondsPerLiquidityOutsideLowerX128,
//     //         secondsOutsideUpper - secondsOutsideLower
//     //     );
//     // }
// }

// /// @inheritdoc IUniswapV3PoolDerivedState
// view observe(uint32[] calldata secondsAgos)
//     /* external
//     view
//     override
//     returns */ : {int[] /* int56[] memory tickCumulatives */, nat[] /* uint160[] memory secondsPerLiquidityCumulativeX128s */}
// {
//     require {observe: noDelegateCall();}
//     // return
//     //     observations.observe(
//     //         blockTimestamp_(),
//     //         secondsAgos,
//     //         slot0.tick,
//     //         slot0.observationIndex,
//     //         liquidity,
//     //         slot0.observationCardinality
//     //     );
// }

// /// @inheritdoc IUniswapV3PoolActions
// entry increaseObservationCardinalityNext(observationCardinalityNext: nat)
//     // external
//     // override
// {
//     do_require(slot0.unlocked, ("LOK", slot0.unlocked));
//     slot0.unlocked := false;
//     require {increaseObservationCardinalityNext: noDelegateCall();}
//     // uint16 observationCardinalityNextOld = slot0.observationCardinalityNext; // for the event
//     // uint16 observationCardinalityNextNew = observations.grow(
//     //     observationCardinalityNextOld,
//     //     observationCardinalityNext
//     // );
//     // slot0.observationCardinalityNext = observationCardinalityNextNew;
//     // if (observationCardinalityNextOld != observationCardinalityNextNew)
//     //     emit IncreaseObservationCardinalityNext(observationCardinalityNextOld, observationCardinalityNextNew);
//     slot0.unlocked := true;
// }

// // /// @inheritdoc IUniswapV3PoolActions
// // /// @dev not locked because it initializes unlocked
// // entry initialize(sqrtPriceX96: nat) /* external override */ {
// //     // require(slot0.sqrtPriceX96 == 0, 'AI');

// //     // int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);

// //     // (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(blockTimestamp_());

// //     // slot0 = Slot0({
// //     //     sqrtPriceX96: sqrtPriceX96,
// //     //     tick: tick,
// //     //     observationIndex: 0,
// //     //     observationCardinality: cardinality,
// //     //     observationCardinalityNext: cardinalityNext,
// //     //     feeProtocol: 0,
// //     //     unlocked: true
// //     // });

// //     // emit Initialize(sqrtPriceX96, tick);
// // }

record ModifyPositionParams {
    // the address that owns the position
    owner_ModifyPosParam: address;
    // the lower and upper tick of the position
    tickLower_ModifyPosParam: int;
    tickUpper_ModifyPosParam: int;
    // any change in liquidity
    liquidityDelta_ModifyPosParam: int;
} as ((owner, tickLower, tickUpper, liquidityDelta))

/// @dev Effect some changes to a position
/// @param params the position details and the change to the position's liquidity to effect
/// @return position a storage pointer referencing the position with the given owner and tick range
/// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient
/// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient
// getter _modifyPosition(params: ModifyPositionParams)
//     // private
//     : {
//         PositionInfo, /* Position.Info storage position */,
//         nat, /* int256 amount0 */,
//         nat, /* int256 amount1 */
//     }
// {
//     require {_modifyPosition1: noDelegateCall();}
//     require {_modifyPosition2: checkTicks(params.tickLower, params.tickUpper);}

//     // Slot0 memory _slot0 = slot0; // SLOAD for gas optimization

//     // position = _updatePosition(
//     //     params.owner,
//     //     params.tickLower,
//     //     params.tickUpper,
//     //     params.liquidityDelta,
//     //     _slot0.tick
//     // );

//     // if (params.liquidityDelta != 0) {
//     //     if (_slot0.tick < params.tickLower) {
//     //         // current tick is below the passed range; liquidity can only become in range by crossing from left to
//     //         // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it
//     //         amount0 = SqrtPriceMath.getAmount0Delta(
//     //             TickMath.getSqrtRatioAtTick(params.tickLower),
//     //             TickMath.getSqrtRatioAtTick(params.tickUpper),
//     //             params.liquidityDelta
//     //         );
//     //     } else if (_slot0.tick < params.tickUpper) {
//     //         // current tick is inside the passed range
//     //         uint128 liquidityBefore = liquidity; // SLOAD for gas optimization

//     //         // write an oracle entry
//     //         (slot0.observationIndex, slot0.observationCardinality) = observations.write(
//     //             _slot0.observationIndex,
//     //             blockTimestamp_(),
//     //             _slot0.tick,
//     //             liquidityBefore,
//     //             _slot0.observationCardinality,
//     //             _slot0.observationCardinalityNext
//     //         );

//     //         amount0 = SqrtPriceMath.getAmount0Delta(
//     //             _slot0.sqrtPriceX96,
//     //             TickMath.getSqrtRatioAtTick(params.tickUpper),
//     //             params.liquidityDelta
//     //         );
//     //         amount1 = SqrtPriceMath.getAmount1Delta(
//     //             TickMath.getSqrtRatioAtTick(params.tickLower),
//     //             _slot0.sqrtPriceX96,
//     //             params.liquidityDelta
//     //         );

//     //         liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);
//     //     } else {
//     //         // current tick is above the passed range; liquidity can only become in range by crossing from right to
//     //         // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it
//     //         amount1 = SqrtPriceMath.getAmount1Delta(
//     //             TickMath.getSqrtRatioAtTick(params.tickLower),
//     //             TickMath.getSqrtRatioAtTick(params.tickUpper),
//     //             params.liquidityDelta
//     //         );
//     //     }
//     // }
// }

/// @dev Gets and updates a position with the given liquidity delta
/// @param owner the owner of the position
/// @param tickLower the lower tick of the position's tick range
/// @param tickUpper the upper tick of the position's tick range
/// @param tick the current tick, passed to avoid sloads
// getter _updatePosition(
//     owner: address,
//     tickLower: int,
//     tickUpper: int,
//     liquidityDelta: int,
//     tick: int
// ) /* private returns */ : PositionInfo /* storage position */ {
//     // position = positions.get(owner, tickLower, tickUpper);

//     // uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128; // SLOAD for gas optimization
//     // uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128; // SLOAD for gas optimization

//     // // if we need to update the ticks, do it
//     // bool flippedLower;
//     // bool flippedUpper;
//     // if (liquidityDelta != 0) {
//     //     uint32 time = blockTimestamp_();
//     //     (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(
//     //         time,
//     //         0,
//     //         slot0.tick,
//     //         slot0.observationIndex,
//     //         liquidity,
//     //         slot0.observationCardinality
//     //     );

//     //     flippedLower = ticks.update(
//     //         tickLower,
//     //         tick,
//     //         liquidityDelta,
//     //         _feeGrowthGlobal0X128,
//     //         _feeGrowthGlobal1X128,
//     //         secondsPerLiquidityCumulativeX128,
//     //         tickCumulative,
//     //         time,
//     //         false,
//     //         maxLiquidityPerTick
//     //     );
//     //     flippedUpper = ticks.update(
//     //         tickUpper,
//     //         tick,
//     //         liquidityDelta,
//     //         _feeGrowthGlobal0X128,
//     //         _feeGrowthGlobal1X128,
//     //         secondsPerLiquidityCumulativeX128,
//     //         tickCumulative,
//     //         time,
//     //         true,
//     //         maxLiquidityPerTick
//     //     );

//     //     if (flippedLower) {
//     //         tickBitmap.flipTick(tickLower, tickSpacing);
//     //     }
//     //     if (flippedUpper) {
//     //         tickBitmap.flipTick(tickUpper, tickSpacing);
//     //     }
//     // }

//     // (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = ticks.getFeeGrowthInside(
//     //     tickLower,
//     //     tickUpper,
//     //     tick,
//     //     _feeGrowthGlobal0X128,
//     //     _feeGrowthGlobal1X128
//     // );

//     // position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);

//     // // clear any tick data that is no longer needed
//     // if (liquidityDelta < 0) {
//     //     if (flippedLower) {
//     //         ticks.clear(tickLower);
//     //     }
//     //     if (flippedUpper) {
//     //         ticks.clear(tickUpper);
//     //     }
//     // }
// }

event Mint {
    sender_mint_event: address;
    owner_mint_event: address;
    tickLower_mint_event: int;
    tickUpper_mint_event: int;
    amount_mint_event: nat;
    amount0_mint_event: nat;
    amount1_mint_event: nat;
}

/// @notice comparator for 32-bit timestamps
/// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time
/// @param time A timestamp truncated to 32 bits
/// @param a A comparison timestamp from which to determine the relative position of `time`
/// @param b From which to determine the relative position of `time`
/// @return bool Whether `a` is chronologically <= `b`
function lte(
    time: nat,
    a: nat,
    b: nat
) : bool {
    var retVal = false;
    // if there hasn't been overflow, no need to adjust
    if (a <= time and b <= time) then begin
        retVal := a <= b;
        return retVal
    end;

    const aAdjusted = a > time ? a : a + 1 <<| 32;
    const bAdjusted = b > time ? b : b + 1 <<| 32;

    retVal := aAdjusted <= bAdjusted;
    return retVal
}

/// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.
/// The result may be the same observation, or adjacent observations.
/// @dev The answer must be contained in the array, used when the target is located within the stored observation
/// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation
/// @param self The stored oracle array
/// @param time The current block.timestamp
/// @param target The timestamp at which the reserved observation should be for
/// @param index The index of the observation that was most recently written to the observations array
/// @param cardinality The number of populated elements in the oracle array
/// @return beforeOrAt The observation recorded before, or at, the target
/// @return atOrAfter The observation recorded at, or after, the target
function binarySearch(
    time_binarySearch: nat,
    target_binarySearch: nat,
    index_binarySearch: nat,
    cardinality_binarySearch: nat
) : Observation * Observation {
    var l = (index_binarySearch + 1) % cardinality_binarySearch; // oldest observation
    var r = l + cardinality_binarySearch - 1; // newest observation
    var beforeOrAt: Observation = {0; 0; 0; false};
    var atOrAfter: Observation = {0; 0; 0; false};
    var i = 0;
    while true do 
        i ?:= int_to_nat((l + r) div 2) : INVALID_NAT;

        beforeOrAt ?:= nth(observations, i % cardinality_binarySearch) : INVALID_RECORD;

        // we've landed on an uninitialized tick, keep searching higher (more recently)
        if (beforeOrAt.initialized_Obs = false) then
            l := i + 1
        else begin
            atOrAfter ?:= nth(observations, (i + 1) % cardinality_binarySearch) : INVALID_RECORD;

            var targetAtOrAfter = lte(time_binarySearch, beforeOrAt.blockTimestamp_Obs, target_binarySearch);

            // check if we've found the answer!
            if (targetAtOrAfter and lte(time_binarySearch, target_binarySearch, atOrAfter.blockTimestamp_Obs)) then
                return ((beforeOrAt, atOrAfter));

            if (targetAtOrAfter = false) then r := i - 1
            else l := i + 1
        end;
    done
}

function transform(
    last_transform_param: Observation,
    blockTimestamp_transform_param: nat,
    tick_transform_param: int,
    liquidity_transform_param: nat
) : Observation {
    const delta ?= int_to_nat(blockTimestamp_transform_param - last_transform_param.blockTimestamp_Obs) : INVALID_NAT;
    const tickCumulative_val = last_transform_param.tickCumulative_Obs + tick_transform_param * delta;
    const secondsPerLiquidityCumulativeX128_val = 
        last_transform_param.secondsPerLiquidityCumulativeX128_Obs + ((delta <<| 128) div (liquidity_transform_param > 0 ? liquidity_transform_param : 1));

    const retVal: Observation = {
        blockTimestamp_transform_param;
        tickCumulative_val;
        secondsPerLiquidityCumulativeX128_val;
        true
    };

    return retVal
}

function getSurroundingObservations(
    time_getSurroundingObservations: nat,
    target_getSurroundingObservations: nat,
    tick_getSurroundingObservations: int,
    index_getSurroundingObservations: nat,
    liquidity_getSurroundingObservations: nat,
    cardinality_getSurroundingObservations: nat
) : Observation * Observation {
    // optimistically set before to the newest observation
    var beforeOrAt: Observation ?= nth(observations, index_getSurroundingObservations) : INVALID_RECORD;
    var atOrAfter: Observation = {0; 0; 0; false};

    // if the target is chronologically at or after the newest observation, we can early return
    if (lte(time_getSurroundingObservations, beforeOrAt.blockTimestamp_Obs, target_getSurroundingObservations)) then begin
        if (beforeOrAt.blockTimestamp_Obs = target_getSurroundingObservations) then
            // if newest observation equals target, we're in the same block, so we can ignore atOrAfter
            return ((beforeOrAt, atOrAfter))
        else
            // otherwise, we need to transform
            return ((beforeOrAt, transform(beforeOrAt, target_getSurroundingObservations, tick_getSurroundingObservations, liquidity_getSurroundingObservations)))
    end;

    // now, set before to the oldest observation
    beforeOrAt ?:= nth(observations, (index_getSurroundingObservations + 1) % cardinality_getSurroundingObservations) : INVALID_RECORD;
    if (beforeOrAt.initialized_Obs = false) then beforeOrAt ?:= nth(observations, 0) : INVALID_RECORD;

    // ensure that the target is chronologically at or after the oldest observation
    do_require(lte(time_getSurroundingObservations, beforeOrAt.blockTimestamp_Obs, target_getSurroundingObservations), "OLD");

    // if we've reached this point, we have to binary search
    return binarySearch(time_getSurroundingObservations, target_getSurroundingObservations, index_getSurroundingObservations, cardinality_getSurroundingObservations)
}

function observeSingle(
    time_observeSingle: nat,
    secondsAgo_observeSingle: nat,
    tick_observeSingle: int,
    index_observeSingle: nat,
    liquidity_observeSingle: nat,
    cardinality_observeSingle: nat
) : int * nat {
    if (secondsAgo_observeSingle = 0) then begin
        var last: Observation ?= nth(observations, index_observeSingle) : INVALID_RECORD;
        if (last.blockTimestamp_Obs <> time_observeSingle) then 
            last := transform(last, time_observeSingle, tick_observeSingle, liquidity_observeSingle);
        const val1 = last.tickCumulative_Obs;
        const val2 = last.secondsPerLiquidityCumulativeX128_Obs;
        return ((val1, val2))
    end;

    var target ?= int_to_nat(time_observeSingle - secondsAgo_observeSingle) : INVALID_NAT;

    const retVal = getSurroundingObservations(
        time_observeSingle,
        target,
        tick_observeSingle,
        index_observeSingle,
        liquidity_observeSingle,
        cardinality_observeSingle
    );
    const beforeOrAt = retVal[0];
    const atOrAfter = retVal[1];

    if (target = beforeOrAt.blockTimestamp_Obs) then 
        // we're at the left boundary
        return ((beforeOrAt.tickCumulative_Obs, beforeOrAt.secondsPerLiquidityCumulativeX128_Obs));
    if (target = atOrAfter.blockTimestamp_Obs) then
        // we're at the right boundary
        return ((atOrAfter.tickCumulative_Obs, atOrAfter.secondsPerLiquidityCumulativeX128_Obs));
    // we're in the middle
    const observationTimeDelta = atOrAfter.blockTimestamp_Obs - beforeOrAt.blockTimestamp_Obs;
    const targetDelta = target - beforeOrAt.blockTimestamp_Obs;
    const retVal1 = beforeOrAt.tickCumulative_Obs + ((atOrAfter.tickCumulative_Obs - beforeOrAt.tickCumulative_Obs) div observationTimeDelta) * targetDelta;
    const retVal2_int = 
        beforeOrAt.secondsPerLiquidityCumulativeX128_Obs + 
        (atOrAfter.secondsPerLiquidityCumulativeX128_Obs - beforeOrAt.secondsPerLiquidityCumulativeX128_Obs) * targetDelta div observationTimeDelta;
    const retVal2 ?= int_to_nat(retVal2_int) : INVALID_NAT;
    return ((retVal1, retVal2))
}

/// @inheritdoc IUniswapV3PoolActions
/// @dev noDelegateCall is applied indirectly via _modifyPosition
entry mint(
    /* address */ recipient_mint: address,
    /* int24 */ tickLower_mint: int,
    /* int24 */ tickUpper_mint: int,
    /* uint128 */ amount_mint: nat,
    /* bytes calldata */ data_mint: bytes
) 
// /* external override returns */ : (nat /* uint256 amount0 */ * nat /* uint256 amount1 */) 
{
    effect {
        do_require(slot0.unlocked, ("LOK", slot0.unlocked));
        slot0.unlocked := false;
        do_require(amount_mint > 0, ());

        // (, int256 amount0Int, int256 amount1Int) = _modifyPosition(
        //     ModifyPositionParams({
        //         owner: recipient,
        //         tickLower: tickLower,
        //         tickUpper: tickUpper,
        //         liquidityDelta: int256(amount).toInt128()
        //     })
        // );

        // getter _modifyPosition(params: ModifyPositionParams)
        // // private
        // : {
        //     PositionInfo, /* Position.Info storage position */,
        //     nat, /* int256 amount0 */,
        //     nat, /* int256 amount1 */
        // }
        do_require(noDelegateCall(), ());
        do_require(checkTicks(tickLower_mint, tickUpper_mint), ());
        const slot0_: Slot0 = slot0; // SLOAD for gas optimization
        // position := _updatePosition(
        //     recipient_mint,
        //     tickLower_mint,
        //     tickUpper_mint,
        //     amount_mint,
        //     _slot0.tick
        // );
        

        /// @dev Gets and updates a position with the given liquidity delta
        /// @param owner the owner of the position
        /// @param tickLower the lower tick of the position's tick range
        /// @param tickUpper the upper tick of the position's tick range
        /// @param tick the current tick, passed to avoid sloads
        // getter _updatePosition(
        //     owner: address,
        //     tickLower: int,
        //     tickUpper: int,
        //     liquidityDelta: int,
        //     tick: int
        // ) /* private returns */ : PositionInfo /* storage position */ {
        var position = positions[(recipient_mint, tickLower_mint, tickUpper_mint)]?.positionInfo;

        var feeGrowthGlobal0X128_: nat = feeGrowthGlobal0X128; // SLOAD for gas optimization
        var feeGrowthGlobal1X128_: nat = feeGrowthGlobal1X128; // SLOAD for gas optimization

        // if we need to update the ticks, do it
        var flippedLower: bool = false;
        var flippedUpper: bool = false;
        if (amount_mint <> 0) then begin
            const time: nat = blockTimestamp_();
            
            // (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observeSingle(
            //     time,
            //     0,
            //     slot0.tick,
            //     slot0.observationIndex,
            //     liquidity,
            //     slot0.observationCardinality
            // );

            // flippedLower = ticks.update(
            //     tickLower,
            //     tick,
            //     liquidityDelta,
            //     _feeGrowthGlobal0X128,
            //     _feeGrowthGlobal1X128,
            //     secondsPerLiquidityCumulativeX128,
            //     tickCumulative,
            //     time,
            //     false,
            //     maxLiquidityPerTick
            // );
            // flippedUpper = ticks.update(
            //     tickUpper,
            //     tick,
            //     liquidityDelta,
            //     _feeGrowthGlobal0X128,
            //     _feeGrowthGlobal1X128,
            //     secondsPerLiquidityCumulativeX128,
            //     tickCumulative,
            //     time,
            //     true,
            //     maxLiquidityPerTick
            // );

            // if (flippedLower) {
            //     tickBitmap.flipTick(tickLower, tickSpacing);
            // }
            // if (flippedUpper) {
            //     tickBitmap.flipTick(tickUpper, tickSpacing);
            // }
        end

    //     (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = ticks.getFeeGrowthInside(
    //         tickLower,
    //         tickUpper,
    //         tick,
    //         _feeGrowthGlobal0X128,
    //         _feeGrowthGlobal1X128
    //     );

    //     position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);

    //     // clear any tick data that is no longer needed
    //     if (liquidityDelta < 0) {
    //         if (flippedLower) {
    //             ticks.clear(tickLower);
    //         }
    //         if (flippedUpper) {
    //             ticks.clear(tickUpper);
    //         }
    //     }

    }



    // if (params.liquidityDelta != 0) {
    //     if (_slot0.tick < params.tickLower) {
    //         // current tick is below the passed range; liquidity can only become in range by crossing from left to
    //         // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it
    //         amount0 = SqrtPriceMath.getAmount0Delta(
    //             TickMath.getSqrtRatioAtTick(params.tickLower),
    //             TickMath.getSqrtRatioAtTick(params.tickUpper),
    //             params.liquidityDelta
    //         );
    //     } else if (_slot0.tick < params.tickUpper) {
    //         // current tick is inside the passed range
    //         uint128 liquidityBefore = liquidity; // SLOAD for gas optimization

    //         // write an oracle entry
    //         (slot0.observationIndex, slot0.observationCardinality) = observations.write(
    //             _slot0.observationIndex,
    //             blockTimestamp_(),
    //             _slot0.tick,
    //             liquidityBefore,
    //             _slot0.observationCardinality,
    //             _slot0.observationCardinalityNext
    //         );

    //         amount0 = SqrtPriceMath.getAmount0Delta(
    //             _slot0.sqrtPriceX96,
    //             TickMath.getSqrtRatioAtTick(params.tickUpper),
    //             params.liquidityDelta
    //         );
    //         amount1 = SqrtPriceMath.getAmount1Delta(
    //             TickMath.getSqrtRatioAtTick(params.tickLower),
    //             _slot0.sqrtPriceX96,
    //             params.liquidityDelta
    //         );

    //         liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);
    //     } else {
    //         // current tick is above the passed range; liquidity can only become in range by crossing from right to
    //         // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it
    //         amount1 = SqrtPriceMath.getAmount1Delta(
    //             TickMath.getSqrtRatioAtTick(params.tickLower),
    //             TickMath.getSqrtRatioAtTick(params.tickUpper),
    //             params.liquidityDelta
    //         );
    //     }
    // }

    // amount0 = uint256(amount0Int);
    // amount1 = uint256(amount1Int);

    // uint256 balance0Before;
    // uint256 balance1Before;
    // if (amount0 > 0) balance0Before = balance0();
    // if (amount1 > 0) balance1Before = balance1();
    // IUniswapV3MintCallback(caller).uniswapV3MintCallback(amount0, amount1, data);
    // if (amount0 > 0) require(balance0Before.add(amount0) <= balance0(), "M0");
    // if (amount1 > 0) require(balance1Before.add(amount1) <= balance1(), "M1");

    // slot0.unlocked := true;

    // emit<Mint>({caller; recipient; tickLower_mint; tickUpper_mint; amount_mint; amount0_mint; amount1_mint})
}

// /// @inheritdoc IUniswapV3PoolActions
// getter collect(
//     /* address */ recipient: address,
//     /* int24 */ tickLower: int,
//     /* int24 */ tickUpper: int,
//     /* uint128 */ amount0Requested: nat,
//     /* uint128 */ amount1Requested: nat
// ) /* external override returns */ : {nat, nat} /* (uint128 amount0, uint128 amount1) */ {
//     do_require(slot0.unlocked, ("LOK", slot0.unlocked));
//     slot0.unlocked := false;
//     // // we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}
//     // Position.Info storage position = positions.get(caller, tickLower, tickUpper);

//     // amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;
//     // amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;

//     // if (amount0 > 0) {
//     //     position.tokensOwed0 -= amount0;
//     //     TransferHelper.safeTransfer(token0, recipient, amount0);
//     // }
//     // if (amount1 > 0) {
//     //     position.tokensOwed1 -= amount1;
//     //     TransferHelper.safeTransfer(token1, recipient, amount1);
//     // }

//     // emit Collect(caller, recipient, tickLower, tickUpper, amount0, amount1);
//     slot0.unlocked := true;
// }

// /// @inheritdoc IUniswapV3PoolActions
// /// @dev noDelegateCall is applied indirectly via _modifyPosition
// getter burn(
//     /* int24 */ tickLower: int,
//     /* int24 */ tickUpper: int,
//     /* uint128 */ amount: nat
// ) /* external override returns */ : {nat, nat} /* (uint256 amount0, uint256 amount1) */ {
//     do_require(slot0.unlocked, ("LOK", slot0.unlocked));
//     slot0.unlocked := false;
//     // (Position.Info storage position, int256 amount0Int, int256 amount1Int) = _modifyPosition(
//     //     ModifyPositionParams({
//     //         owner: caller,
//     //         tickLower: tickLower,
//     //         tickUpper: tickUpper,
//     //         liquidityDelta: -int256(amount).toInt128()
//     //     })
//     // );

//     // amount0 = uint256(-amount0Int);
//     // amount1 = uint256(-amount1Int);

//     // if (amount0 > 0 || amount1 > 0) {
//     //     (position.tokensOwed0, position.tokensOwed1) = (
//     //         position.tokensOwed0 + uint128(amount0),
//     //         position.tokensOwed1 + uint128(amount1)
//     //     );
//     // }

//     // emit Burn(caller, tickLower, tickUpper, amount, amount0, amount1);
//     slot0.unlocked := true;
// }

// // record SwapCache {
// //     // the protocol fee for the input token
// //     feeProtocol: nat;
// //     // liquidity at the beginning of the swap
// //     liquidityStart: nat;
// //     // the timestamp of the current block
// //     blockTimestamp: nat;
// //     // the current value of the tick accumulator, computed only if we cross an initialized tick
// //     tickCumulative: int;
// //     // the current value of seconds per liquidity accumulator, computed only if we cross an initialized tick
// //     secondsPerLiquidityCumulativeX128: nat;
// //     // whether we've computed and cached the above two accumulators
// //     computedLatestObservation: bool;
// // }

// // // the top level state of the swap, the results of which are recorded in storage at the end
// // record SwapState {
// //     // the amount remaining to be swapped in/out of the input/output asset
// //     amountSpecifiedRemaining: int;
// //     // the amount already swapped out/in of the output/input asset
// //     amountCalculated: int;
// //     // current sqrt(price)
// //     sqrtPriceX96: nat;
// //     // the tick associated with the current price
// //     tick: int;
// //     // the global fee growth of the input token
// //     feeGrowthGlobalX128: nat;
// //     // amount of input token paid as protocol fee
// //     protocolFee: nat;
// //     // the current liquidity in range
// //     liquidity: nat;
// // }

// // record StepComputations {
// //     // the price at the beginning of the step
// //     sqrtPriceStartX96: nat;
// //     // the next tick to swap to from the current tick in the swap direction
// //     tickNext: int;
// //     // whether tickNext is initialized or not
// //     %initialized: bool;
// //     // sqrt(price) for the next tick (1/0)
// //     sqrtPriceNextX96: nat;
// //     // how much is being swapped in in this step
// //     amountIn: nat;
// //     // how much is being swapped out
// //     amountOut: nat;
// //     // how much fee is being paid in
// //     feeAmount: nat;
// // }

// /// @inheritdoc IUniswapV3PoolActions
// getter swap(
//     /* address */ recipient: address,
//     /* bool */ zeroForOne: bool,
//     /* int256 */ amountSpecified: int,
//     /* uint160 */ sqrtPriceLimitX96: nat,
//     /* bytes calldata */ data: bytes
// ) /* external override returns */ : {int, int} /* (int256 amount0, int256 amount1) */ {
//     require {swap: noDelegateCall();}
    
//     // require(amountSpecified != 0, 'AS');

//     // Slot0 memory slot0Start = slot0;

//     // require(slot0Start.unlocked, 'LOK');
//     // require(
//     //     zeroForOne
//     //         ? sqrtPriceLimitX96 < slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 > TickMath.MIN_SQRT_RATIO
//     //         : sqrtPriceLimitX96 > slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 < TickMath.MAX_SQRT_RATIO,
//     //     'SPL'
//     // );

//     // slot0.unlocked := false;

//     // SwapCache memory cache = SwapCache({
//     //     liquidityStart: liquidity,
//     //     blockTimestamp: blockTimestamp_(),
//     //     feeProtocol: zeroForOne ? (slot0Start.feeProtocol % 16) : (slot0Start.feeProtocol >> 4),
//     //     secondsPerLiquidityCumulativeX128: 0,
//     //     tickCumulative: 0,
//     //     computedLatestObservation: false
//     // });

//     // bool exactInput = amountSpecified > 0;

//     // SwapState memory state = SwapState({
//     //     amountSpecifiedRemaining: amountSpecified,
//     //     amountCalculated: 0,
//     //     sqrtPriceX96: slot0Start.sqrtPriceX96,
//     //     tick: slot0Start.tick,
//     //     feeGrowthGlobalX128: zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128,
//     //     protocolFee: 0,
//     //     liquidity: cache.liquidityStart
//     // });

//     // // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit
//     // while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != sqrtPriceLimitX96) {
//     //     StepComputations memory step;

//     //     step.sqrtPriceStartX96 = state.sqrtPriceX96;

//     //     (step.tickNext, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord(
//     //         state.tick,
//     //         tickSpacing,
//     //         zeroForOne
//     //     );

//     //     // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds
//     //     if (step.tickNext < TickMath.MIN_TICK) {
//     //         step.tickNext = TickMath.MIN_TICK;
//     //     } else if (step.tickNext > TickMath.MAX_TICK) {
//     //         step.tickNext = TickMath.MAX_TICK;
//     //     }

//     //     // get the price for the next tick
//     //     step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);

//     //     // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted
//     //     (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(
//     //         state.sqrtPriceX96,
//     //         (zeroForOne ? step.sqrtPriceNextX96 < sqrtPriceLimitX96 : step.sqrtPriceNextX96 > sqrtPriceLimitX96)
//     //             ? sqrtPriceLimitX96
//     //             : step.sqrtPriceNextX96,
//     //         state.liquidity,
//     //         state.amountSpecifiedRemaining,
//     //         fee
//     //     );

//     //     if (exactInput) {
//     //         state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();
//     //         state.amountCalculated = state.amountCalculated.sub(step.amountOut.toInt256());
//     //     } else {
//     //         state.amountSpecifiedRemaining += step.amountOut.toInt256();
//     //         state.amountCalculated = state.amountCalculated.add((step.amountIn + step.feeAmount).toInt256());
//     //     }

//     //     // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee
//     //     if (cache.feeProtocol > 0) {
//     //         uint256 delta = step.feeAmount / cache.feeProtocol;
//     //         step.feeAmount -= delta;
//     //         state.protocolFee += uint128(delta);
//     //     }

//     //     // update global fee tracker
//     //     if (state.liquidity > 0)
//     //         state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);

//     //     // shift tick if we reached the next price
//     //     if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {
//     //         // if the tick is initialized, run the tick transition
//     //         if (step.initialized) {
//     //             // check for the placeholder value, which we replace with the actual value the first time the swap
//     //             // crosses an initialized tick
//     //             if (!cache.computedLatestObservation) {
//     //                 (cache.tickCumulative, cache.secondsPerLiquidityCumulativeX128) = observations.observeSingle(
//     //                     cache.blockTimestamp,
//     //                     0,
//     //                     slot0Start.tick,
//     //                     slot0Start.observationIndex,
//     //                     cache.liquidityStart,
//     //                     slot0Start.observationCardinality
//     //                 );
//     //                 cache.computedLatestObservation = true;
//     //             }
//     //             int128 liquidityNet = ticks.cross(
//     //                 step.tickNext,
//     //                 (zeroForOne ? state.feeGrowthGlobalX128 : feeGrowthGlobal0X128),
//     //                 (zeroForOne ? feeGrowthGlobal1X128 : state.feeGrowthGlobalX128),
//     //                 cache.secondsPerLiquidityCumulativeX128,
//     //                 cache.tickCumulative,
//     //                 cache.blockTimestamp
//     //             );
//     //             // if we're moving leftward, we interpret liquidityNet as the opposite sign
//     //             // safe because liquidityNet cannot be type(int128).min
//     //             if (zeroForOne) liquidityNet = -liquidityNet;

//     //             state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);
//     //         }

//     //         state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
//     //     } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {
//     //         // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved
//     //         state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);
//     //     }
//     // }

//     // // update tick and write an oracle entry if the tick change
//     // if (state.tick != slot0Start.tick) {
//     //     (uint16 observationIndex, uint16 observationCardinality) = observations.write(
//     //         slot0Start.observationIndex,
//     //         cache.blockTimestamp,
//     //         slot0Start.tick,
//     //         cache.liquidityStart,
//     //         slot0Start.observationCardinality,
//     //         slot0Start.observationCardinalityNext
//     //     );
//     //     (slot0.sqrtPriceX96, slot0.tick, slot0.observationIndex, slot0.observationCardinality) = (
//     //         state.sqrtPriceX96,
//     //         state.tick,
//     //         observationIndex,
//     //         observationCardinality
//     //     );
//     // } else {
//     //     // otherwise just update the price
//     //     slot0.sqrtPriceX96 = state.sqrtPriceX96;
//     // }

//     // // update liquidity if it changed
//     // if (cache.liquidityStart != state.liquidity) liquidity = state.liquidity;

//     // // update fee growth global and, if necessary, protocol fees
//     // // overflow is acceptable, protocol has to withdraw before it hits type(uint128).max fees
//     // if (zeroForOne) {
//     //     feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;
//     //     if (state.protocolFee > 0) protocolFees.token0 += state.protocolFee;
//     // } else {
//     //     feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;
//     //     if (state.protocolFee > 0) protocolFees.token1 += state.protocolFee;
//     // }

//     // (amount0, amount1) = zeroForOne == exactInput
//     //     ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)
//     //     : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);

//     // // do the transfers and collect payment
//     // if (zeroForOne) {
//     //     if (amount1 < 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));

//     //     uint256 balance0Before = balance0();
//     //     IUniswapV3SwapCallback(caller).uniswapV3SwapCallback(amount0, amount1, data);
//     //     require(balance0Before.add(uint256(amount0)) <= balance0(), 'IIA');
//     // } else {
//     //     if (amount0 < 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0));

//     //     uint256 balance1Before = balance1();
//     //     IUniswapV3SwapCallback(caller).uniswapV3SwapCallback(amount0, amount1, data);
//     //     require(balance1Before.add(uint256(amount1)) <= balance1(), 'IIA');
//     // }

//     // emit Swap(caller, recipient, amount0, amount1, state.sqrtPriceX96, state.liquidity, state.tick);
//     // slot0.unlocked := true;
// }

// /// @inheritdoc IUniswapV3PoolActions
// entry flash(
//     /* address */ recipient: address,
//     /* uint256 */ amount0: nat,
//     /* uint256 */ amount1: nat,
//     /* bytes calldata */ data: bytes
// ) /* external override */ {
//     do_require(slot0.unlocked, ("LOK", slot0.unlocked));
//     slot0.unlocked := false;
//     require {flash: noDelegateCall();}
//     // uint128 _liquidity = liquidity;
//     // require(_liquidity > 0, 'L');

//     // uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e6);
//     // uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e6);
//     // uint256 balance0Before = balance0();
//     // uint256 balance1Before = balance1();

//     // if (amount0 > 0) TransferHelper.safeTransfer(token0, recipient, amount0);
//     // if (amount1 > 0) TransferHelper.safeTransfer(token1, recipient, amount1);

//     // IUniswapV3FlashCallback(caller).uniswapV3FlashCallback(fee0, fee1, data);

//     // uint256 balance0After = balance0();
//     // uint256 balance1After = balance1();

//     // require(balance0Before.add(fee0) <= balance0After, 'F0');
//     // require(balance1Before.add(fee1) <= balance1After, 'F1');

//     // // sub is safe because we know balanceAfter is gt balanceBefore by at least fee
//     // uint256 paid0 = balance0After - balance0Before;
//     // uint256 paid1 = balance1After - balance1Before;

//     // if (paid0 > 0) {
//     //     uint8 feeProtocol0 = slot0.feeProtocol % 16;
//     //     uint256 fees0 = feeProtocol0 == 0 ? 0 : paid0 / feeProtocol0;
//     //     if (uint128(fees0) > 0) protocolFees.token0 += uint128(fees0);
//     //     feeGrowthGlobal0X128 += FullMath.mulDiv(paid0 - fees0, FixedPoint128.Q128, _liquidity);
//     // }
//     // if (paid1 > 0) {
//     //     uint8 feeProtocol1 = slot0.feeProtocol >> 4;
//     //     uint256 fees1 = feeProtocol1 == 0 ? 0 : paid1 / feeProtocol1;
//     //     if (uint128(fees1) > 0) protocolFees.token1 += uint128(fees1);
//     //     feeGrowthGlobal1X128 += FullMath.mulDiv(paid1 - fees1, FixedPoint128.Q128, _liquidity);
//     // }

//     // emit Flash(caller, recipient, amount0, amount1, paid0, paid1);
//     slot0.unlocked := true;
// }

// /// @inheritdoc IUniswapV3PoolOwnerActions
// entry setFeeProtocol(feeProtocol0: nat, feeProtocol1: nat) /* external override */ {
//     do_require(slot0.unlocked, ("LOK", slot0.unlocked));
//     slot0.unlocked := false;
//     require {setFeeProtocol: onlyFactoryOwner();}
//     // require(
//     //     (feeProtocol0 == 0 || (feeProtocol0 >= 4 && feeProtocol0 <= 10)) &&
//     //         (feeProtocol1 == 0 || (feeProtocol1 >= 4 && feeProtocol1 <= 10))
//     // );
//     // uint8 feeProtocolOld = slot0.feeProtocol;
//     // slot0.feeProtocol = feeProtocol0 + (feeProtocol1 << 4);
//     // emit SetFeeProtocol(feeProtocolOld % 16, feeProtocolOld >> 4, feeProtocol0, feeProtocol1);
//     slot0.unlocked := true;
// }

// /// @inheritdoc IUniswapV3PoolOwnerActions
// getter collectProtocol(
//     /* address */ recipient: address,
//     /* uint128 */ amount0Requested: nat,
//     /* uint128 */ amount1Requested: nat
// ) /* external override returns (uint128 amount0, uint128 amount1) */ : {nat, nat} {
//     do_require(slot0.unlocked, ("LOK", slot0.unlocked));
//     slot0.unlocked := false;
//     require {collectProtocol: onlyFactoryOwner();}
//     // amount0 = amount0Requested > protocolFees.token0 ? protocolFees.token0 : amount0Requested;
//     // amount1 = amount1Requested > protocolFees.token1 ? protocolFees.token1 : amount1Requested;

//     // if (amount0 > 0) {
//     //     if (amount0 == protocolFees.token0) amount0--; // ensure that the slot is not cleared, for gas savings
//     //     protocolFees.token0 -= amount0;
//     //     TransferHelper.safeTransfer(token0, recipient, amount0);
//     // }
//     // if (amount1 > 0) {
//     //     if (amount1 == protocolFees.token1) amount1--; // ensure that the slot is not cleared, for gas savings
//     //     protocolFees.token1 -= amount1;
//     //     TransferHelper.safeTransfer(token1, recipient, amount1);
//     // }

//     // emit CollectProtocol(caller, recipient, amount0, amount1);
//     slot0.unlocked := true;
// }
