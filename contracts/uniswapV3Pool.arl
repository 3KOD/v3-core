archetype uniswapV3Pool(factory: address, token0: address, token1: address)

// import LowGasSafeMath from "./libraries/LowGasSafeMath.tz"
// import SafeCast from "./libraries/SafeCast.tz"
// import Tick from "./libraries/Tick.tz"
// import TickBitmap from "./libraries/TickBitmap.tz"
// import Position from "./libraries/Position.tz"
// import Oracle from "./libraries/Oracle.tz"
// import FullMath from "./libraries/FullMath.tz"
// import FixedPoint128 from "./libraries/FixedPoint128.tz"
// import TransferHelper from "./libraries/TransferHelper.tz"
// import TickMath from "./libraries/TickMath.tz"
// import LiquidityMath from "./libraries/LiquidityMath.tz"
// import SqrtPriceMath from "./libraries/SqrtPriceMath.tz"
// import SwapMath from "./libraries/SwapMath.tz"
// import IUniswapV3PoolDeployer from "./interfaces/IUniswapV3PoolDeployer.tz"
// import IUniswapV3Factory from "./interfaces/IUniswapV3Factory.tz"
// import IERC20Minimal from "./interfaces/IERC20Minimal.tz"
// import IUniswapV3MintCallback from "./interfaces/callback/IUniswapV3MintCallback.tz"
// import IUniswapV3SwapCallback from "./interfaces/callback/IUniswapV3SwapCallback.tz"
// import IUniswapV3FlashCallback from "./interfaces/callback/IUniswapV3FlashCallback.tz"

constant INVALID_NAT             : string = "INVALID_NAT"
constant INVALID_INT_NAT         : string = "INVALID_INT_NAT"
constant INVALID_UNPACK          : string = "INVALID_UNPACK"
constant INVALID_RECORD          : string = "INVALID_RECORD"

constant MIN_TICK: int = -887272
constant MAX_TICK: int = -MIN_TICK
/// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
constant MIN_SQRT_RATIO: nat = 4295128739
/// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
constant MAX_SQRT_RATIO: nat = 1461446703485210103287273052203988822378723970342
constant MAX_HISTORY: nat = 65536
constant RESOLUTION: nat = 96
constant Q64: nat = 1 <<| 64
constant Q96: nat = 1 <<| 96
constant Q128: nat = 1 <<| 128
constant Q160: nat = 1 <<| 160
constant Q256: nat = 1 <<| 256
constant UnixStartTime: date = 1970-01-01
constant original: address = self_address

event Mint {
    sender_mint_event: address;
    owner_mint_event: address;
    tickLower_mint_event: int;
    tickUpper_mint_event: int;
    amount_mint_event: nat;
    amount0_mint_event: nat;
    amount1_mint_event: nat;
}

event Burn {
    owner_burn_event: address;
    tickLower_burn_event: int;
    tickUpper_burn_event: int;
    amount_burn_event: nat;
    amount0_burn_event: nat;
    amount1_burn_event: nat;
}

event Collect {
    owner_collect_event: address;
    recipient_collect_event: address;
    tickLower_collect_event: int;
    tickUpper_collect_event: int;
    amount0_collect_event: nat;
    amount1_collect_event: nat;
}

event SetFeeProtocol {
    feeProtocol0Old_setFeeProtocol_event: nat; 
    feeProtocol1Old_setFeeProtocol_event: nat; 
    feeProtocol0New_setFeeProtocol_event: nat; 
    feeProtocol1New_setFeeProtocol_event: nat;
}

event CollectProtocol {
    sender_collectProtocol_event: address; 
    recipient_collectProtocol_event: address; 
    amount0_collectProtocol_event: nat; 
    amount1_collectProtocol_event: nat;
}

event Initialize {
    sqrtPriceX96_initialize_event : nat; 
    tick_initialize_event : int;
}

event Swap {
    sender_swap_event: address;
    recipient_swap_event: address;
    amount0_swap_event: int;
    amount1_swap_event: int;
    sqrtPriceX96_swap_event: nat;
    liquidity_swap_event: nat;
    tick_swap_event: int;
}

event Flash {
    sender_flash_event: address;
    recipient_flash_event: address;
    amount0_flash_event: nat;
    amount1_flash_event: nat;
    paid0_flash_event: nat;
    paid1_flash_event: nat;
}

event IncObsCardinalityNext{
    observationCardinalityNextOld_event: nat;
    observationCardinalityNextNew_event: nat;
}

record PoolKey {
    token0_poolKey: address;
    token1_poolKey: address;
    fee_poolKey: nat
} as (((token0, token1), fee))

record MintCallbackData {
    poolKey: PoolKey;
    payer: address; 
}

record SwapCallbackData {
    path_SwapCallbackData: bytes;
    payer_SwapCallbackData: address;
}

function noDelegateCall() : bool {
    do_fail_if(self_address <> original, ("DelegateCall", original));
    return true
}

variable fee: nat = 0
variable tickSpacing: int = 0
variable maxLiquidityPerTick: nat = 0

variable balance0: nat = 0
variable balance1: nat = 0

// using LowGasSafeMath for uint256;
// using LowGasSafeMath for int256;
// using SafeCast for uint256;
// using SafeCast for int256;
// using Tick for mapping(int24 => Tick.Info);
// using TickBitmap for mapping(int16 => uint256);
// using Position for mapping(bytes32 => Position.Info);
// using Position for Position.Info;
// using Oracle for Oracle.Observation[65535];

/// @inheritdoc IUniswapV3PoolState
record Slot0 {
    // the current price
    sqrtPriceX96: nat;
    // the current tick
    tick: int;
    // the most-recently updated index of the observations array
    observationIndex: nat;
    // the current maximum number of observations that are being stored
    observationCardinality: nat;
    // the next maximum number of observations to store, triggered in observations.write
    observationCardinalityNext: nat;
    // the current protocol fee as a percentage of the swap fee taken on withdrawal
    // represented as an integer denominator (1/x)%
    feeProtocol: nat;
    // whether the pool is locked
    unlocked: bool;
}

variable slot0: Slot0 = {
    sqrtPriceX96                = 0;
    tick                        = 0;
    observationIndex            = 0;
    observationCardinality      = 0;
    observationCardinalityNext  = 0;
    feeProtocol                 = 0;
    unlocked                    = false
}

/// @inheritdoc IUniswapV3PoolState
variable feeGrowthGlobal0X128 : nat = 0
/// @inheritdoc IUniswapV3PoolState
variable feeGrowthGlobal1X128 : nat = 0

// accumulated protocol fees in token0/token1 units
record ProtocolFees {
    token0_fees: nat;
    token1_fees: nat;
} as ((token0, token1))
/// @inheritdoc IUniswapV3PoolState
variable protocolFees: ProtocolFees = {
    token0_fees = 0;
    token1_fees = 0
}

/// @inheritdoc IUniswapV3PoolState
variable liquidity : nat = 0

// info stored for each initialized individual tick
record TickInfo {
    // the total position liquidity that references this tick
    liquidityGross: nat;
    // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),
    liquidityNet: int;
    // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    feeGrowthOutside0X128: nat;
    feeGrowthOutside1X128: nat;
    // the cumulative tick value on the other side of the tick
    tickCumulativeOutside: int;
    // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    secondsPerLiquidityOutsideX128: nat;
    // the seconds spent on the other side of the tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    secondsOutside: nat;
    // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross <> 0
    // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks
    %initialized: bool;
}

/// @inheritdoc IUniswapV3PoolState
asset ticks identified by tickId to big_map {
    tickId: int;
    info: TickInfo;
}
/// @inheritdoc IUniswapV3PoolState
asset tickBitmap identified by tick_tickBmp to big_map {
    tick_tickBmp : int;
    tickSpacing_tickBmp: nat = 0;
}
record PositionInfo {
    // the amount of liquidity owned by this position
    liquidity_PosInfo: nat;
    // fee growth per unit of liquidity as of the last update to liquidity or fees owed
    feeGrowthInside0LastX128_PosInfo: nat;
    feeGrowthInside1LastX128_PosInfo: nat;
    // the fees owed to the position owner in token0/token1
    tokensOwed0_PosInfo: nat;
    tokensOwed1_PosInfo: nat;
} as ((liquidity, (feeGrowthInside0LastX128, feeGrowthInside1LastX128), (tokensOwed0, tokensOwed1)))
/// @inheritdoc IUniswapV3PoolState
asset positions identified by positionId_owner positionId_tickLower positionId_tickUpper to big_map {
    positionId_owner: address;
    positionId_tickLower: int;
    positionId_tickUpper: int;
    positionInfo: PositionInfo;
}
record Observation {
    // the block timestamp of the observation
    blockTimestamp_Obs: nat;
    // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized
    tickCumulative_Obs: int;
    // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized
    secondsPerLiquidityCumulativeX128_Obs: nat;
    // whether or not the observation is initialized
    initialized_Obs: bool;
} as ((blockTimestamp, (tickCumulative, secondsPerLiquidityCumulativeX128, %initialized)))
/// @inheritdoc IUniswapV3PoolState
// Oracle.Observation[65535] public override observations;
asset observations identified by observation_key to big_map {
    observation_key: nat;
    observation_value: Observation;
}

/// @dev Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance
/// to a function before the pool is initialized. The reentrancy guard is required throughout the contract because
/// we use balance checks to determine the payment status of interactions such as mint, swap and flash.
// function lock() {
//     // do_require(slot0.unlocked, ("LOK", slot0.unlocked));
//     // slot0.unlocked := false;
//     // _;
//     // slot0.unlocked := true;
// }

/// @dev Prevents calling a function from anyone except the address returned by IUniswapV3Factory#owner()
function onlyFactoryOwner(): bool {
    const factoryOwner ?= call_view<address>(factory, "getOwner", Unit) : "VIEW_OWNER_ERR";
    do_require(caller = factoryOwner, "ONLY_FACTORY_OWNER_ERR");
    return true
}

/// @dev Common checks for valid tick inputs.
function checkTicks(tickLower: int, tickUpper: int): bool {
    do_require(tickLower < tickUpper, "TLU");
    do_require(tickLower >= MIN_TICK, "TLM");
    do_require(tickUpper <= MAX_TICK, "TUM");
    return true
}

/// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.
view blockTimestamp_view(): nat {
    const timestamp ?= int_to_nat((now - UnixStartTime) div 1s) : INVALID_NAT;
    return timestamp
    // return uint32(block.timestamp); // truncation is desired
}

/// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.
function blockTimestamp_(): nat {
    const timestamp ?= int_to_nat((now - UnixStartTime) div 1s) : INVALID_NAT;
    return timestamp
    // return uint32(block.timestamp); // truncation is desired
}

/// @dev Get the pool's balance of token0
/// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
/// check
// view balance0() /* private view returns */ : nat {
//     // (bool success, bytes memory data) = token0.staticcall(
//     //     abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this))
//     // );
//     // require(success and data.length >= 32);
//     // return abi.decode(data, (uint256));
//     return 0
// }

// /// @dev Get the pool's balance of token1
// /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
// /// check
// view balance1() /* private view returns */ : nat {
//     // (bool success, bytes memory data) = token1.staticcall(
//     //     abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this))
//     // );
//     // require(success and data.length >= 32);
//     // return abi.decode(data, (uint256));
//     return 0
// }

// / @inheritdoc IUniswapV3PoolDerivedState
view snapshotCumulativesInside(tickLower: int, tickUpper: int): int * nat * nat
// (
//         /* tickCumulativeInside: */ int *
//         /* secondsPerLiquidityInsideX128: */ nat *
//         /* secondsInside: */ nat
// )
{
    do_fail_if(self_address <> original, ("DelegateCall", original));
    do_require(tickLower < tickUpper, "TLU");
    do_require(tickLower >= MIN_TICK, "TLM");
    do_require(tickUpper <= MAX_TICK, "TUM");

    var tickCumulativeInside: int = 0;
    var secondsPerLiquidityInsideX128: nat = 0;
    var secondsInside: nat = 0;

    var tickCumulativeLower: int = 0;
    var tickCumulativeUpper: int = 0;
    var secondsPerLiquidityOutsideLowerX128: nat = 0;
    var secondsPerLiquidityOutsideUpperX128: nat = 0;
    var secondsOutsideLower: nat = 0;
    var secondsOutsideUpper: nat = 0;

    var lower: TickInfo = ticks[tickLower].info;
    var upper: TickInfo = ticks[tickUpper].info;
    tickCumulativeLower := lower.tickCumulativeOutside;
    secondsPerLiquidityOutsideLowerX128 := lower.secondsPerLiquidityOutsideX128;
    secondsOutsideLower :=  lower.secondsOutside;
    do_require(lower.%initialized, "ERR");

    tickCumulativeUpper := upper.tickCumulativeOutside;
    secondsPerLiquidityOutsideUpperX128 := upper.secondsPerLiquidityOutsideX128;
    secondsOutsideUpper := upper.secondsOutside;
    do_require(upper.%initialized, "ERR");

    // this is memory, so don't need storage
    var slot0_: Slot0 = slot0;

    if (slot0_.tick < tickLower) then begin
        tickCumulativeInside := tickCumulativeLower - tickCumulativeUpper;
        secondsPerLiquidityInsideX128 ?:= int_to_nat(secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128) : INVALID_NAT;
        secondsInside ?:= int_to_nat(secondsOutsideLower - secondsOutsideUpper) : INVALID_NAT;
        return ((tickCumulativeInside, secondsPerLiquidityInsideX128, secondsInside))
    end else if (slot0_.tick < tickUpper) then begin
        var time ?= call_view<nat>(self_address, "blockTimestamp_", Unit) : INVALID_NAT;
        const retVal ?= call_view<int * nat>(self_address, "observationsObserveSingle_view", (
            time,
            0,
            slot0_.tick,
            slot0_.observationIndex,
            liquidity,
            slot0_.observationCardinality
        )) : INVALID_RECORD;
        const tickCumulative: int = retVal[0];
        const secondsPerLiquidityCumulativeX128: nat = retVal[1];
        tickCumulativeInside := tickCumulative - tickCumulativeLower - tickCumulativeUpper;
        secondsPerLiquidityInsideX128 ?:= int_to_nat(secondsPerLiquidityCumulativeX128 - secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128) : INVALID_NAT;
        secondsInside ?:= int_to_nat(time - secondsOutsideLower - secondsOutsideUpper) : INVALID_NAT;
        return ((tickCumulativeInside, secondsPerLiquidityInsideX128, secondsInside))
    end else begin
        tickCumulativeInside := tickCumulativeUpper - tickCumulativeLower;
        secondsPerLiquidityInsideX128 ?:= int_to_nat(secondsPerLiquidityOutsideUpperX128 - secondsPerLiquidityOutsideLowerX128) : INVALID_NAT;
        secondsInside ?:= int_to_nat(secondsOutsideUpper - secondsOutsideLower) : INVALID_NAT;
        return ((tickCumulativeInside, secondsPerLiquidityInsideX128, secondsInside))
    end
}

/// @inheritdoc IUniswapV3PoolDerivedState
view observe(secondsAgos: list<nat>)
    /* external
    view
    override
    returns */ : list<int> /* int56[] memory tickCumulatives */ * list<nat> /* uint160[] memory secondsPerLiquidityCumulativeX128s */
{
    do_fail_if(self_address <> original, ("DelegateCall", original));
    // return
    //     observations.observe(
    //         blockTimestamp_(),
    //         secondsAgos,
    //         slot0.tick,
    //         slot0.observationIndex,
    //         liquidity,
    //         slot0.observationCardinality
    //     );
    /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`
    /// @dev Reverts if `secondsAgos` > oldest observation
    /// @param self The stored oracle array
    /// @param time The current block.timestamp
    /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation
    /// @param tick The current tick
    /// @param index The index of the observation that was most recently written to the observations array
    /// @param liquidity The current in-range pool liquidity
    /// @param cardinality The number of populated elements in the oracle array
    /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`
    /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`
    // function observe(
    //     Observation[65535] storage self,
    //     uint32 time, // blockTimestamp_(),
    //     uint32[] memory secondsAgos, // secondsAgos,
    //     int24 tick, // slot0.tick,
    //     uint16 index, // slot0.observationIndex,
    //     uint128 liquidity, // liquidity,
    //     uint16 cardinality //slot0.observationCardinality
    // ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {
    do_require(slot0.observationCardinality > 0, "I");

    var time_val ?= call_view<nat>(self_address, "blockTimestamp_", Unit) : INVALID_NAT;
    var tickCumulatives: list<int> = [];
    var secondsPerLiquidityCumulativeX128s: list<nat> = [];
    var i = 0;
    while (i < length(secondsAgos)) do
        const retVal ?= call_view<int * nat>(self_address, "observationsObserveSingle_view", (
            time_val,
            (nth(secondsAgos, i) ? the : 0),
            slot0.tick,
            slot0.observationIndex,
            liquidity,
            slot0.observationCardinality
        )) : INVALID_RECORD;
        tickCumulatives := concat(tickCumulatives, [retVal[0]]);
        secondsPerLiquidityCumulativeX128s := concat(secondsPerLiquidityCumulativeX128s, [retVal[1]]);
        i += 1
    done;
    // }
    return ((tickCumulatives, secondsPerLiquidityCumulativeX128s))
}

/// @inheritdoc IUniswapV3PoolActions
entry increaseObservationCardinalityNext(observationCardinalityNext_param: nat)
    // external
    // override
{
    require {
        increaseObservationCardinalityNext_c1: noDelegateCall();
    }

    effect {
        do_require(slot0.unlocked, ("LOK", slot0.unlocked));
        slot0.unlocked := false;
        const observationCardinalityNextOld: nat /* uint16 */ = slot0.observationCardinalityNext; // for the event
        var observationCardinalityNextNew: nat =0; /* uint16 */
        // = observationsGrow(
        //     observationCardinalityNextOld,
        //     observationCardinalityNext_param
        // );
        /// @notice Prepares the oracle array to store up to `next` observations
        /// @param self The stored oracle array
        /// @param current The current next cardinality of the oracle array
        /// @param next The proposed next cardinality which will be populated in the oracle array
        /// @return next The next cardinality which will be populated in the oracle array
        // function grow(
        //     Observation[65535] storage self,
        //     uint16 observationCardinalityNextOld,
        //     uint16 observationCardinalityNext_param
        // ) internal returns (uint16) {
        do_require(observationCardinalityNextOld > 0, "I");
        // no-op if the passed next value isn't greater than the current next value
        if (observationCardinalityNext_param <= observationCardinalityNextOld) then
            observationCardinalityNextNew := observationCardinalityNextOld
        else begin
            // store in each slot to prevent fresh SSTOREs in swaps
            // this data will not be used because the initialized boolean is still false
            // for (uint16 i = observationCardinalityNextOld; i < observationCardinalityNext_param; i++) observations[i].blockTimestamp_Obs := 1;
            var i = observationCardinalityNextOld;
            while (i < observationCardinalityNext_param) do
                observations[i].observation_value := {
                    observations[i].observation_value with
                    blockTimestamp_Obs = 1
                };
                i += 1
            done;
            observationCardinalityNextNew := observationCardinalityNext_param;
            // }
        end;

        slot0.observationCardinalityNext := observationCardinalityNextNew;
        if (observationCardinalityNextOld <> observationCardinalityNextNew) then
            emit<IncObsCardinalityNext>({observationCardinalityNextOld; observationCardinalityNextNew});
        slot0.unlocked := true
    }
}

/// @notice Calculates sqrt(1.0001^tick) * 2^96
/// @dev Throws if |tick| > max tick
/// @param tick The input tick for the above formula
/// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
/// at the given tick
function tickMathGetSqrtRatioAtTick(tick_tickMathGetSqrtRatioAtTick: int) : nat {
    var absTick = abs(tick_tickMathGetSqrtRatioAtTick);
    do_require(absTick <= MAX_TICK, "T");

    var ratio = absTick % 2 <> 0 ? 340265354078544963557816517032075149313 : 340282366920938463463374607431768211456;
    if ((absTick div (1 <<| 1)) % 2 <> 0) then ratio := (ratio * 340248342086729790484326174814286782778) |>> 128;
    if ((absTick div (1 <<| 2)) % 2 <> 0) then ratio := (ratio * 340214320654664324051920982716015181260) |>> 128;
    if ((absTick div (1 <<| 3)) % 2 <> 0) then ratio := (ratio * 340146287995602323631171512101879684304) |>> 128;
    if ((absTick div (1 <<| 4)) % 2 <> 0) then ratio := (ratio * 340010263488231146823593991679159461444) |>> 128;
    if ((absTick div (1 <<| 5)) % 2 <> 0) then ratio := (ratio * 339738377640345403697157401104375502016) |>> 128;
    if ((absTick div (1 <<| 6)) % 2 <> 0) then ratio := (ratio * 339195258003219555707034227454543997025) |>> 128;
    if ((absTick div (1 <<| 7)) % 2 <> 0) then ratio := (ratio * 338111622100601834656805679988414885971) |>> 128;
    if ((absTick div (1 <<| 8)) % 2 <> 0) then ratio := (ratio * 335954724994790223023589805789778977700) |>> 128;
    if ((absTick div (1 <<| 9)) % 2 <> 0) then ratio := (ratio * 331682121138379247127172139078559817300) |>> 128;
    if ((absTick div (1 <<| 10)) % 2 <> 0) then ratio := (ratio * 323299236684853023288211250268160618739) |>> 128;
    if ((absTick div (1 <<| 11)) % 2 <> 0) then ratio := (ratio * 307163716377032989948697243942600083929) |>> 128;
    if ((absTick div (1 <<| 12)) % 2 <> 0) then ratio := (ratio * 277268403626896220162999269216087595045) |>> 128;
    if ((absTick div (1 <<| 13)) % 2 <> 0) then ratio := (ratio * 225923453940442621947126027127485391333) |>> 128;
    if ((absTick div (1 <<| 14)) % 2 <> 0) then ratio := (ratio * 149997214084966997727330242082538205943) |>> 128;
    if ((absTick div (1 <<| 15)) % 2 <> 0) then ratio := (ratio * 66119101136024775622716233608466517926) |>> 128;
    if ((absTick div (1 <<| 16)) % 2 <> 0) then ratio := (ratio * 12847376061809297530290974190478138313) |>> 128;
    if ((absTick div (1 <<| 17)) % 2 <> 0) then ratio := (ratio * 485053260817066172746253684029974020) |>> 128;
    if ((absTick div (1 <<| 18)) % 2 <> 0) then ratio := (ratio * 691415978906521570653435304214168) |>> 128;
    if ((absTick div (1 <<| 19)) % 2 <> 0) then ratio := (ratio * 1404880482679654955896180642) |>> 128;

    if (tick_tickMathGetSqrtRatioAtTick > 0) then ratio := abs(Q256 - 1) div ratio;

    // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
    const sqrtPriceX96_val = (ratio |>> 32) + ((ratio % (1 <<| 32) = 0) ? 0 : 1);

    return sqrtPriceX96_val
}

/// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio
/// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
/// ever return.
/// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96
/// @return tick The greatest tick for which the ratio is less than or equal to the input ratio
function tickMathGetTickAtSqrtRatio(sqrtPriceX96_getTickAtSqrtRatio: nat) : int {
    // second inequality must be < because the price can never reach the price at the max tick
    do_require(sqrtPriceX96_getTickAtSqrtRatio >= MIN_SQRT_RATIO and sqrtPriceX96_getTickAtSqrtRatio < MAX_SQRT_RATIO, "R");
    var ratio: nat = sqrtPriceX96_getTickAtSqrtRatio <<| 32;

    var r: nat = ratio;
    var msb: nat = 0;

    var gt_val: nat = 0;
    var f: nat = 0;

    gt_val := ((r + 1) > Q128) ? 1 : 0;
    f := gt_val <<| 7;
    msb := msb or f;
    r := r |>> f;

    gt_val := ((r + 1) > Q64) ? 1 : 0;
    f := gt_val <<| 6;
    msb := msb or f;
    r := r |>> f;

    gt_val := ((r + 1) > (1 <<| 32)) ? 1 : 0;
    f := gt_val <<| 5;
    msb := msb or f;
    r := r |>> f;
    
    gt_val := ((r + 1) > (1 <<| 16)) ? 1 : 0;
    f := gt_val <<| 4;
    msb := msb or f;
    r := r |>> f;

    gt_val := ((r + 1) > (1 <<| 8)) ? 1 : 0;
    f := gt_val <<| 3;
    msb := msb or f;
    r := r |>> f;
    
    gt_val := ((r + 1) > (1 <<| 4)) ? 1 : 0;
    f := gt_val <<| 2;
    msb := msb or f;
    r := r |>> f;
    
    gt_val := ((r + 1) > (1 <<| 2)) ? 1 : 0;
    f := gt_val <<| 1;
    msb := msb or f;
    r := r |>> f;

    f := (r > 1) ? 1 : 0;
    msb := msb or f;
    
    if (msb >= 128) then begin
        const msb_nat ?= int_to_nat(msb - 127) : INVALID_NAT;
        r := ratio |>> msb_nat
    end else begin
        const msb_nat ?= int_to_nat(127 - msb) : INVALID_NAT;
        r := ratio <<| msb_nat
    end;

    var log_2: int = (msb - 128) * Q64;
    
    r := (r * r) |>> 127;
    f := r |>> 128;
    log_2 := (int_to_nat(log_2) ? the : 0) or (f <<| 63);
    r := r |>> f;

    r := (r * r) |>> 127;
    f := r |>> 128;
    log_2 := (int_to_nat(log_2) ? the : 0) or (f <<| 62);
    r := r |>> f;

    r := (r * r) |>> 127;
    f := r |>> 128;
    log_2 := (int_to_nat(log_2) ? the : 0) or (f <<| 61);
    r := r |>> f;

    r := (r * r) |>> 127;
    f := r |>> 128;
    log_2 := (int_to_nat(log_2) ? the : 0) or (f <<| 60);
    r := r |>> f;

    r := (r * r) |>> 127;
    f := r |>> 128;
    log_2 := (int_to_nat(log_2) ? the : 0) or (f <<| 59);
    r := r |>> f;

    r := (r * r) |>> 127;
    f := r |>> 128;
    log_2 := (int_to_nat(log_2) ? the : 0) or (f <<| 58);
    r := r |>> f;
    
    r := (r * r) |>> 127;
    f := r |>> 128;
    log_2 := (int_to_nat(log_2) ? the : 0) or (f <<| 57);
    r := r |>> f;
    
    r := (r * r) |>> 127;
    f := r |>> 128;
    log_2 := (int_to_nat(log_2) ? the : 0) or (f <<| 56);
    r := r |>> f;
    
    r := (r * r) |>> 127;
    f := r |>> 128;
    log_2 := (int_to_nat(log_2) ? the : 0) or (f <<| 55);
    r := r |>> f;
    
    r := (r * r) |>> 127;
    f := r |>> 128;
    log_2 := (int_to_nat(log_2) ? the : 0) or (f <<| 54);
    r := r |>> f;
    
    r := (r * r) |>> 127;
    f := r |>> 128;
    log_2 := (int_to_nat(log_2) ? the : 0) or (f <<| 53);
    r := r |>> f;
    
    r := (r * r) |>> 127;
    f := r |>> 128;
    log_2 := (int_to_nat(log_2) ? the : 0) or (f <<| 52);
    r := r |>> f;
    
    r := (r * r) |>> 127;
    f := r |>> 128;
    log_2 := (int_to_nat(log_2) ? the : 0) or (f <<| 51);
    r := r |>> f;
    
    r := (r * r) |>> 127;
    f := r |>> 128;
    log_2 := (int_to_nat(log_2) ? the : 0) or (f <<| 50);

    const log_sqrt10001: int = log_2 * 255738958999603826347141; // 128.128 number

    const tickLow: int = (log_sqrt10001 - 3402992956809132418596140100660247210) div Q128;
    const tickHi: int = (log_sqrt10001 + 291339464771989622907027621153398088495) div Q128;

    const tick_val: int = (tickLow = tickHi) ? tickLow : ((tickMathGetSqrtRatioAtTick(tickHi) <= sqrtPriceX96_getTickAtSqrtRatio) ? tickHi : tickLow);
    return tick_val
}

/// @inheritdoc IUniswapV3PoolActions
/// @dev not locked because it initializes unlocked
entry initialize(sqrtPriceX96_initialize: nat) /* external override */ {
    do_require(slot0.sqrtPriceX96 = 0, "AI");

    const tick_param = tickMathGetTickAtSqrtRatio(sqrtPriceX96_initialize);

    // const ret_Val = observationsInitialize(blockTimestamp_());
    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array
    /// @param self The stored oracle array
    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32
    /// @return cardinality The number of populated elements in the oracle array
    /// @return cardinalityNext The new length of the oracle array, independent of population
    // function observationsInitialize(time: nat) : nat * nat
    // {
    observations[0].observation_value := {blockTimestamp_(); 0; 0; true};
    // return ((1, 1))
    // }
    const cardinality = 1;
    const cardinalityNext = 1;

    slot0 := { sqrtPriceX96_initialize; tick_param; 0; cardinality; cardinalityNext; 0; true};

    emit<Initialize>({sqrtPriceX96_initialize; tick_param})
}

record ModifyPositionParams {
    // the address that owns the position
    owner_ModifyPosParam: address;
    // the lower and upper tick of the position
    tickLower_ModifyPosParam: int;
    tickUpper_ModifyPosParam: int;
    // any change in liquidity
    liquidityDelta_ModifyPosParam: int;
} as ((owner, tickLower, tickUpper, liquidityDelta))

/// @dev Effect some changes to a position
/// @param params the position details and the change to the position's liquidity to effect
/// @return position a storage pointer referencing the position with the given owner and tick range
/// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient
/// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient
// getter _modifyPosition(params: ModifyPositionParams)
//     // private
//     : {
//         PositionInfo, /* Position.Info storage position */,
//         nat, /* int256 amount0 */,
//         nat, /* int256 amount1 */
//     }
// {
//     require {_modifyPosition1: noDelegateCall();}
//     require {_modifyPosition2: checkTicks(params.tickLower, params.tickUpper);}

//     // Slot0 memory _slot0 = slot0; // SLOAD for gas optimization

//     // position = _updatePosition(
//     //     params.owner,
//     //     params.tickLower,
//     //     params.tickUpper,
//     //     params.liquidityDelta,
//     //     _slot0.tick
//     // );

//     // if (params.liquidityDelta <> 0) {
//     //     if (_slot0.tick < params.tickLower) {
//     //         // current tick is below the passed range; liquidity can only become in range by crossing from left to
//     //         // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it
//     //         amount0 = SqrtPriceMath.getAmount0Delta(
//     //             tickMathGetSqrtRatioAtTick(params.tickLower),
//     //             tickMathGetSqrtRatioAtTick(params.tickUpper),
//     //             params.liquidityDelta
//     //         );
//     //     } else if (_slot0.tick < params.tickUpper) {
//     //         // current tick is inside the passed range
//     //         uint128 liquidityBefore = liquidity; // SLOAD for gas optimization

//     //         // write an oracle entry
//     //         (slot0.observationIndex, slot0.observationCardinality) = observations.write(
//     //             _slot0.observationIndex,
//     //             blockTimestamp_(),
//     //             _slot0.tick,
//     //             liquidityBefore,
//     //             _slot0.observationCardinality,
//     //             _slot0.observationCardinalityNext
//     //         );

//     //         amount0 = SqrtPriceMath.getAmount0Delta(
//     //             _slot0.sqrtPriceX96,
//     //             tickMathGetSqrtRatioAtTick(params.tickUpper),
//     //             params.liquidityDelta
//     //         );
//     //         amount1 = SqrtPriceMath.getAmount1Delta(
//     //             tickMathGetSqrtRatioAtTick(params.tickLower),
//     //             _slot0.sqrtPriceX96,
//     //             params.liquidityDelta
//     //         );

//     //         liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);
//     //     } else {
//     //         // current tick is above the passed range; liquidity can only become in range by crossing from right to
//     //         // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it
//     //         amount1 = SqrtPriceMath.getAmount1Delta(
//     //             tickMathGetSqrtRatioAtTick(params.tickLower),
//     //             tickMathGetSqrtRatioAtTick(params.tickUpper),
//     //             params.liquidityDelta
//     //         );
//     //     }
//     // }
// }

/// @dev Gets and updates a position with the given liquidity delta
/// @param owner the owner of the position
/// @param tickLower the lower tick of the position's tick range
/// @param tickUpper the upper tick of the position's tick range
/// @param tick the current tick, passed to avoid sloads
// getter _updatePosition(
//     owner: address,
//     tickLower: int,
//     tickUpper: int,
//     liquidityDelta: int,
//     tick: int
// ) /* private returns */ : PositionInfo /* storage position */ {
//     // position = positions.get(owner, tickLower, tickUpper);

//     // uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128; // SLOAD for gas optimization
//     // uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128; // SLOAD for gas optimization

//     // // if we need to update the ticks, do it
//     // bool flippedLower;
//     // bool flippedUpper;
//     // if (liquidityDelta <> 0) {
//     //     uint32 time = blockTimestamp_();
//     //     (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(
//     //         time,
//     //         0,
//     //         slot0.tick,
//     //         slot0.observationIndex,
//     //         liquidity,
//     //         slot0.observationCardinality
//     //     );

//     //     flippedLower = ticks.update(
//     //         tickLower,
//     //         tick,
//     //         liquidityDelta,
//     //         _feeGrowthGlobal0X128,
//     //         _feeGrowthGlobal1X128,
//     //         secondsPerLiquidityCumulativeX128,
//     //         tickCumulative,
//     //         time,
//     //         false,
//     //         maxLiquidityPerTick
//     //     );
//     //     flippedUpper = ticks.update(
//     //         tickUpper,
//     //         tick,
//     //         liquidityDelta,
//     //         _feeGrowthGlobal0X128,
//     //         _feeGrowthGlobal1X128,
//     //         secondsPerLiquidityCumulativeX128,
//     //         tickCumulative,
//     //         time,
//     //         true,
//     //         maxLiquidityPerTick
//     //     );

//     //     if (flippedLower) {
//     //         tickBitmap.flipTick(tickLower, tickSpacing);
//     //     }
//     //     if (flippedUpper) {
//     //         tickBitmap.flipTick(tickUpper, tickSpacing);
//     //     }
//     // }

//     // (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = ticks.getFeeGrowthInside(
//     //     tickLower,
//     //     tickUpper,
//     //     tick,
//     //     _feeGrowthGlobal0X128,
//     //     _feeGrowthGlobal1X128
//     // );

//     // position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);

//     // // clear any tick data that is no longer needed
//     // if (liquidityDelta < 0) {
//     //     if (flippedLower) {
//     //         ticks.clear(tickLower);
//     //     }
//     //     if (flippedUpper) {
//     //         ticks.clear(tickUpper);
//     //     }
//     // }
// }

/// @notice comparator for 32-bit timestamps
/// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time
/// @param time A timestamp truncated to 32 bits
/// @param a A comparison timestamp from which to determine the relative position of `time`
/// @param b From which to determine the relative position of `time`
/// @return bool Whether `a` is chronologically <= `b`
view lte_tickBmpNITWOW_view(
    time: nat,
    a: nat,
    b: nat
) : bool {
    var retVal = false;
    // if there hasn't been overflow, no need to adjust
    if (a <= time and b <= time) then begin
        retVal := a <= b;
        return retVal
    end else begin
        const aAdjusted = a > time ? a : a + 1 <<| 32;
        const bAdjusted = b > time ? b : b + 1 <<| 32;

        retVal := aAdjusted <= bAdjusted;
        return retVal
    end
}

/// @notice comparator for 32-bit timestamps
/// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time
/// @param time A timestamp truncated to 32 bits
/// @param a A comparison timestamp from which to determine the relative position of `time`
/// @param b From which to determine the relative position of `time`
/// @return bool Whether `a` is chronologically <= `b`
function lte_tickBmpNITWOW(
    time: nat,
    a: nat,
    b: nat
) : bool {
    var retVal = false;
    // if there hasn't been overflow, no need to adjust
    if (a <= time and b <= time) then begin
        retVal := a <= b;
        return retVal
    end else begin
        const aAdjusted = a > time ? a : a + 1 <<| 32;
        const bAdjusted = b > time ? b : b + 1 <<| 32;

        retVal := aAdjusted <= bAdjusted;
        return retVal
    end
}

/// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.
/// The result may be the same observation, or adjacent observations.
/// @dev The answer must be contained in the array, used when the target is located within the stored observation
/// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation
/// @param self The stored oracle array
/// @param time The current block.timestamp
/// @param target The timestamp at which the reserved observation should be for
/// @param index The index of the observation that was most recently written to the observations array
/// @param cardinality The number of populated elements in the oracle array
/// @return beforeOrAt The observation recorded before, or at, the target
/// @return atOrAfter The observation recorded at, or after, the target
view binarySearch_view(
    time_binarySearch: nat,
    target_binarySearch: nat,
    index_binarySearch: nat,
    cardinality_binarySearch: nat
) : Observation * Observation {
    var l = (index_binarySearch + 1) % cardinality_binarySearch; // oldest observation
    var r = l + cardinality_binarySearch - 1; // newest observation
    var beforeOrAt: Observation = {0; 0; 0; false};
    var atOrAfter: Observation = {0; 0; 0; false};
    var i = 0;
    var condWhile = true;
    while condWhile do 
        i ?:= int_to_nat((l + r) div 2) : INVALID_NAT;

        beforeOrAt := observations[i % cardinality_binarySearch].observation_value;

        // we've landed on an uninitialized tick, keep searching higher (more recently)
        if (beforeOrAt.initialized_Obs = false) then
            l := i + 1
        else begin
            atOrAfter := observations[(i + 1) % cardinality_binarySearch].observation_value;

            var targetAtOrAfter ?= call_view<bool>(self_address, "lte_tickBmpNITWOW_view", (time_binarySearch, beforeOrAt.blockTimestamp_Obs, target_binarySearch)) : INVALID_RECORD;

            const cond_Val ?= call_view<bool>(self_address, "lte_tickBmpNITWOW_view", (time_binarySearch, target_binarySearch, atOrAfter.blockTimestamp_Obs)) : INVALID_RECORD;
            // check if we've found the answer!
            if (targetAtOrAfter and cond_Val) then
                condWhile := false;

            if (targetAtOrAfter = false) then r := i - 1
            else l := i + 1
        end;
    done;
    return ((beforeOrAt, atOrAfter))
}

/// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.
/// The result may be the same observation, or adjacent observations.
/// @dev The answer must be contained in the array, used when the target is located within the stored observation
/// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation
/// @param self The stored oracle array
/// @param time The current block.timestamp
/// @param target The timestamp at which the reserved observation should be for
/// @param index The index of the observation that was most recently written to the observations array
/// @param cardinality The number of populated elements in the oracle array
/// @return beforeOrAt The observation recorded before, or at, the target
/// @return atOrAfter The observation recorded at, or after, the target
function binarySearch(
    time_binarySearch: nat,
    target_binarySearch: nat,
    index_binarySearch: nat,
    cardinality_binarySearch: nat
) : Observation * Observation {
    var l = (index_binarySearch + 1) % cardinality_binarySearch; // oldest observation
    var r = l + cardinality_binarySearch - 1; // newest observation
    var beforeOrAt: Observation = {0; 0; 0; false};
    var atOrAfter: Observation = {0; 0; 0; false};
    var i = 0;
    var condWhile = true;
    while condWhile do 
        i ?:= int_to_nat((l + r) div 2) : INVALID_NAT;

        beforeOrAt := observations[i % cardinality_binarySearch].observation_value;

        // we've landed on an uninitialized tick, keep searching higher (more recently)
        if (beforeOrAt.initialized_Obs = false) then
            l := i + 1
        else begin
            atOrAfter := observations[(i + 1) % cardinality_binarySearch].observation_value;

            var targetAtOrAfter = lte_tickBmpNITWOW(time_binarySearch, beforeOrAt.blockTimestamp_Obs, target_binarySearch);

            // check if we've found the answer!
            if (targetAtOrAfter and lte_tickBmpNITWOW(time_binarySearch, target_binarySearch, atOrAfter.blockTimestamp_Obs)) then
                condWhile := false;

            if (targetAtOrAfter = false) then r := i - 1
            else l := i + 1
        end
    done;
    return ((beforeOrAt, atOrAfter))
}

view transform_view(
    last_transform_param: Observation,
    blockTimestamp_transform_param: nat,
    tick_transform_param: int,
    liquidity_transform_param: nat
) : Observation {
    const delta ?= int_to_nat(blockTimestamp_transform_param - last_transform_param.blockTimestamp_Obs) : INVALID_NAT;
    const tickCumulative_val = last_transform_param.tickCumulative_Obs + tick_transform_param * delta;
    const secondsPerLiquidityCumulativeX128_val = 
        last_transform_param.secondsPerLiquidityCumulativeX128_Obs + ((delta <<| 128) div (liquidity_transform_param > 0 ? liquidity_transform_param : 1));

    const retVal: Observation = {
        blockTimestamp_transform_param;
        tickCumulative_val;
        secondsPerLiquidityCumulativeX128_val;
        true
    };

    return retVal
}

function transform(
    last_transform_param: Observation,
    blockTimestamp_transform_param: nat,
    tick_transform_param: int,
    liquidity_transform_param: nat
) : Observation {
    const delta ?= int_to_nat(blockTimestamp_transform_param - last_transform_param.blockTimestamp_Obs) : INVALID_NAT;
    const tickCumulative_val = last_transform_param.tickCumulative_Obs + tick_transform_param * delta;
    const secondsPerLiquidityCumulativeX128_val = 
        last_transform_param.secondsPerLiquidityCumulativeX128_Obs + ((delta <<| 128) div (liquidity_transform_param > 0 ? liquidity_transform_param : 1));

    const retVal: Observation = {
        blockTimestamp_transform_param;
        tickCumulative_val;
        secondsPerLiquidityCumulativeX128_val;
        true
    };

    return retVal
}

view getSurroundingObservations_view(
    time_getSurroundingObservations: nat,
    target_getSurroundingObservations: nat,
    tick_getSurroundingObservations: int,
    index_getSurroundingObservations: nat,
    liquidity_getSurroundingObservations: nat,
    cardinality_getSurroundingObservations: nat
) : Observation * Observation {
    // optimistically set before to the newest observation
    var beforeOrAt: Observation = observations[index_getSurroundingObservations].observation_value;
    var atOrAfter: Observation = {0; 0; 0; false};

    // if the target is chronologically at or after the newest observation, we can early return
    if ((call_view<bool>(self_address, "lte_tickBmpNITWOW_view", 
                (time_getSurroundingObservations, beforeOrAt.blockTimestamp_Obs, target_getSurroundingObservations)) ? the : false)) then begin
        if (beforeOrAt.blockTimestamp_Obs = target_getSurroundingObservations) then
            // if newest observation equals target, we're in the same block, so we can ignore atOrAfter
            return ((beforeOrAt, atOrAfter))
        else begin
            // otherwise, we need to transform
            const retVal ?= call_view<Observation>(self_address, "transform_view", 
                (beforeOrAt, target_getSurroundingObservations, tick_getSurroundingObservations, liquidity_getSurroundingObservations)) : INVALID_RECORD;
            return ((beforeOrAt, retVal))
        end
    end else begin
        // now, set before to the oldest observation
        beforeOrAt := observations[(index_getSurroundingObservations + 1) % cardinality_getSurroundingObservations].observation_value;
        if (beforeOrAt.initialized_Obs = false) then beforeOrAt := observations[0].observation_value;

        // ensure that the target is chronologically at or after the oldest observation
        do_require(call_view<bool>(self_address, "lte_tickBmpNITWOW_view", (time_getSurroundingObservations, beforeOrAt.blockTimestamp_Obs, target_getSurroundingObservations)) ? the : false, "OLD");

        // if we've reached this point, we have to binary search
        const retVal_binarySearch ?= call_view<Observation * Observation>(self_address, "binarySearch_view", 
            (time_getSurroundingObservations, target_getSurroundingObservations, index_getSurroundingObservations, cardinality_getSurroundingObservations)) : INVALID_RECORD;
        return retVal_binarySearch
    end
}

function getSurroundingObservations(
    time_getSurroundingObservations: nat,
    target_getSurroundingObservations: nat,
    tick_getSurroundingObservations: int,
    index_getSurroundingObservations: nat,
    liquidity_getSurroundingObservations: nat,
    cardinality_getSurroundingObservations: nat
) : Observation * Observation {
    // optimistically set before to the newest observation
    var beforeOrAt: Observation = observations[index_getSurroundingObservations].observation_value;
    var atOrAfter: Observation = {0; 0; 0; false};

    // if the target is chronologically at or after the newest observation, we can early return
    if (lte_tickBmpNITWOW(time_getSurroundingObservations, beforeOrAt.blockTimestamp_Obs, target_getSurroundingObservations)) then begin
        if (beforeOrAt.blockTimestamp_Obs = target_getSurroundingObservations) then
            // if newest observation equals target, we're in the same block, so we can ignore atOrAfter
            return ((beforeOrAt, atOrAfter))
        else
            // otherwise, we need to transform
            return ((beforeOrAt, transform(beforeOrAt, target_getSurroundingObservations, tick_getSurroundingObservations, liquidity_getSurroundingObservations)))
    end else begin
        // now, set before to the oldest observation
        beforeOrAt := observations[(index_getSurroundingObservations + 1) % cardinality_getSurroundingObservations].observation_value;
        if (beforeOrAt.initialized_Obs = false) then beforeOrAt := observations[0].observation_value;

        // ensure that the target is chronologically at or after the oldest observation
        do_require(lte_tickBmpNITWOW(time_getSurroundingObservations, beforeOrAt.blockTimestamp_Obs, target_getSurroundingObservations), "OLD");

        // if we've reached this point, we have to binary search
        return binarySearch(time_getSurroundingObservations, target_getSurroundingObservations, index_getSurroundingObservations, cardinality_getSurroundingObservations)
    end
}

view observationsObserveSingle_view(
    time_observeSingle: nat,
    secondsAgo_observeSingle: nat,
    tick_observeSingle: int,
    index_observeSingle: nat,
    liquidity_observeSingle: nat,
    cardinality_observeSingle: nat
) : int * nat {
    if (secondsAgo_observeSingle = 0) then begin
        var last: Observation = observations[index_observeSingle].observation_value;
        if (last.blockTimestamp_Obs <> time_observeSingle) then 
            last ?:= call_view<Observation>(self_address, "transform_view", (last, time_observeSingle, tick_observeSingle, liquidity_observeSingle)) : INVALID_RECORD;
        const val1 = last.tickCumulative_Obs;
        const val2 = last.secondsPerLiquidityCumulativeX128_Obs;
        return ((val1, val2))
    end else begin
        var target ?= int_to_nat(time_observeSingle - secondsAgo_observeSingle) : INVALID_NAT;

        const retVal ?= call_view<Observation * Observation>(self_address, "getSurroundingObservations_view", (
            time_observeSingle,
            target,
            tick_observeSingle,
            index_observeSingle,
            liquidity_observeSingle,
            cardinality_observeSingle
        )) : INVALID_RECORD;
        const beforeOrAt = retVal[0];
        const atOrAfter = retVal[1];

        if (target = beforeOrAt.blockTimestamp_Obs) then 
            // we're at the left boundary
            return ((beforeOrAt.tickCumulative_Obs, beforeOrAt.secondsPerLiquidityCumulativeX128_Obs))
        else if (target = atOrAfter.blockTimestamp_Obs) then
            // we're at the right boundary
            return ((atOrAfter.tickCumulative_Obs, atOrAfter.secondsPerLiquidityCumulativeX128_Obs))
        else begin
            // we're in the middle
            const observationTimeDelta = atOrAfter.blockTimestamp_Obs - beforeOrAt.blockTimestamp_Obs;
            const targetDelta = target - beforeOrAt.blockTimestamp_Obs;
            const retVal1 = beforeOrAt.tickCumulative_Obs + ((atOrAfter.tickCumulative_Obs - beforeOrAt.tickCumulative_Obs) div observationTimeDelta) * targetDelta;
            const retVal2_int = 
                beforeOrAt.secondsPerLiquidityCumulativeX128_Obs + 
                (atOrAfter.secondsPerLiquidityCumulativeX128_Obs - beforeOrAt.secondsPerLiquidityCumulativeX128_Obs) * targetDelta div observationTimeDelta;
            const retVal2 ?= int_to_nat(retVal2_int) : INVALID_NAT;
            return ((retVal1, retVal2))
        end
    end
}

function observationsObserveSingle(
    time_observeSingle: nat,
    secondsAgo_observeSingle: nat,
    tick_observeSingle: int,
    index_observeSingle: nat,
    liquidity_observeSingle: nat,
    cardinality_observeSingle: nat
) : int * nat {
    if (secondsAgo_observeSingle = 0) then begin
        var last: Observation = observations[index_observeSingle].observation_value;
        if (last.blockTimestamp_Obs <> time_observeSingle) then 
            last := transform(last, time_observeSingle, tick_observeSingle, liquidity_observeSingle);
        const val1 = last.tickCumulative_Obs;
        const val2 = last.secondsPerLiquidityCumulativeX128_Obs;
        return ((val1, val2))
    end else begin

        var target ?= int_to_nat(time_observeSingle - secondsAgo_observeSingle) : INVALID_NAT;

        const retVal = getSurroundingObservations(
            time_observeSingle,
            target,
            tick_observeSingle,
            index_observeSingle,
            liquidity_observeSingle,
            cardinality_observeSingle
        );
        const beforeOrAt = retVal[0];
        const atOrAfter = retVal[1];

        if (target = beforeOrAt.blockTimestamp_Obs) then 
            // we're at the left boundary
            return ((beforeOrAt.tickCumulative_Obs, beforeOrAt.secondsPerLiquidityCumulativeX128_Obs))
        else if (target = atOrAfter.blockTimestamp_Obs) then
            // we're at the right boundary
            return ((atOrAfter.tickCumulative_Obs, atOrAfter.secondsPerLiquidityCumulativeX128_Obs))
        else begin
            // we're in the middle
            const observationTimeDelta = atOrAfter.blockTimestamp_Obs - beforeOrAt.blockTimestamp_Obs;
            const targetDelta = target - beforeOrAt.blockTimestamp_Obs;
            const retVal1 = beforeOrAt.tickCumulative_Obs + ((atOrAfter.tickCumulative_Obs - beforeOrAt.tickCumulative_Obs) div observationTimeDelta) * targetDelta;
            const retVal2_int = 
                beforeOrAt.secondsPerLiquidityCumulativeX128_Obs + 
                (atOrAfter.secondsPerLiquidityCumulativeX128_Obs - beforeOrAt.secondsPerLiquidityCumulativeX128_Obs) * targetDelta div observationTimeDelta;
            const retVal2 ?= int_to_nat(retVal2_int) : INVALID_NAT;
            return ((retVal1, retVal2))
        end
    end
}

// /// @notice Computes the position in the mapping where the initialized bit for a tick lives
// /// @param tick The tick for which to compute the position
// /// @return wordPos The key in the mapping containing the word in which the bit is stored
// /// @return bitPos The bit position in the word where the flag is stored
// function position(tick_: int) : int * nat {
//     const wordPos = tick_ div 256;
//     const bitPos = tick_ % 256;
//     return ((wordPos, bitPos))
// }

/// @notice Retrieves fee growth data
/// @param self The mapping containing all tick information for initialized ticks
/// @param tickLower The lower tick boundary of the position
/// @param tickUpper The upper tick boundary of the position
/// @param tickCurrent The current tick
/// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
/// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
/// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
/// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
function getFeeGrowthInside(
    tickLower_getFeeGrowthInside: int,
    tickUpper_getFeeGrowthInside: int,
    tickCurrent_getFeeGrowthInside: int,
    feeGrowthGlobal0X128_getFeeGrowthInside: nat,
    feeGrowthGlobal1X128_getFeeGrowthInside: nat
) : nat * nat {
    const lower = ticks[tickLower_getFeeGrowthInside].info;
    const upper = ticks[tickUpper_getFeeGrowthInside].info;

    // calculate fee growth below
    var feeGrowthBelow0X128 = 0;
    var feeGrowthBelow1X128 = 0;
    if (tickCurrent_getFeeGrowthInside >= tickLower_getFeeGrowthInside) then begin
        feeGrowthBelow0X128 := lower.feeGrowthOutside0X128;
        feeGrowthBelow1X128 := lower.feeGrowthOutside1X128;
    end else begin
        feeGrowthBelow0X128 ?:= int_to_nat(feeGrowthGlobal0X128_getFeeGrowthInside - lower.feeGrowthOutside0X128) : INVALID_NAT;
        feeGrowthBelow1X128 ?:= int_to_nat(feeGrowthGlobal1X128_getFeeGrowthInside - lower.feeGrowthOutside1X128) : INVALID_NAT;
    end;

    // calculate fee growth above
    var feeGrowthAbove0X128 = 0;
    var feeGrowthAbove1X128 = 0;
    if (tickCurrent_getFeeGrowthInside < tickUpper_getFeeGrowthInside) then begin
        feeGrowthAbove0X128 := upper.feeGrowthOutside0X128;
        feeGrowthAbove1X128 := upper.feeGrowthOutside1X128;
    end else begin
        feeGrowthAbove0X128 ?:= int_to_nat(feeGrowthGlobal0X128_getFeeGrowthInside - upper.feeGrowthOutside0X128) : INVALID_NAT;
        feeGrowthAbove1X128 ?:= int_to_nat(feeGrowthGlobal1X128_getFeeGrowthInside - upper.feeGrowthOutside1X128) : INVALID_NAT;
    end;

    const feeGrowthInside0X128 ?= int_to_nat(feeGrowthGlobal0X128_getFeeGrowthInside - feeGrowthBelow0X128 - feeGrowthAbove0X128) : INVALID_NAT;
    const feeGrowthInside1X128 ?= int_to_nat(feeGrowthGlobal1X128_getFeeGrowthInside - feeGrowthBelow1X128 - feeGrowthAbove1X128) : INVALID_NAT;
    return ((feeGrowthInside0X128, feeGrowthInside1X128))
}

/// @notice Gets the amount0 delta between two prices
/// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),
/// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))
/// @param sqrtRatioAX96_sPMGA0D A sqrt price
/// @param sqrtRatioBX96_sPMGA0D Another sqrt price
/// @param liquidity The amount of usable liquidity
/// @param roundUp_sPMGA0D Whether to round the amount up or down
/// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices
function sqrtPriceMathGetAmount0Delta_round(
    sqrtRatioAX96_sPMGA0D: nat,
    sqrtRatioBX96_sPMGA0D: nat,
    liquidity_sPMGA0D: nat,
    roundUp_sPMGA0D: bool
) : nat {
    var sqrtRatioAX96_val = sqrtRatioAX96_sPMGA0D;
    var sqrtRatioBX96_val = sqrtRatioBX96_sPMGA0D;
    if (sqrtRatioAX96_sPMGA0D > sqrtRatioBX96_sPMGA0D) then begin
        sqrtRatioAX96_val := sqrtRatioBX96_sPMGA0D;
        sqrtRatioBX96_val := sqrtRatioAX96_sPMGA0D
    end;

    const numerator1 = liquidity_sPMGA0D <<| RESOLUTION;
    const numerator2 ?= int_to_nat(sqrtRatioBX96_val - sqrtRatioAX96_val) : INVALID_NAT;

    do_require(sqrtRatioAX96_val > 0, "ERR");

    if roundUp_sPMGA0D then begin
        const val1 ?= int_to_nat(ceil(numerator1 * numerator2 / sqrtRatioBX96_val)) : INVALID_NAT;
        const val2 ?= int_to_nat(ceil(val1 / sqrtRatioAX96_val)) : INVALID_NAT;
        return val2
    end else begin
        return (numerator1 * numerator2 div sqrtRatioBX96_val div sqrtRatioAX96_val);
    end
}

/// @notice Helper that gets signed token0 delta
/// @param sqrtRatioAX96 A sqrt price
/// @param sqrtRatioBX96 Another sqrt price
/// @param liquidity The change in liquidity for which to compute the amount0 delta
/// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices
function sqrtPriceMathGetAmount0Delta(
    sqrtRatioAX96_sPMGA0D: nat,
    sqrtRatioBX96_sPMGA0D: nat,
    liquidity_sPMGA0D: int
) : int {
    if (liquidity_sPMGA0D < 0) then
        return (-sqrtPriceMathGetAmount0Delta_round(sqrtRatioAX96_sPMGA0D, sqrtRatioBX96_sPMGA0D, abs(liquidity_sPMGA0D), false))
    else
        return (sqrtPriceMathGetAmount0Delta_round(sqrtRatioAX96_sPMGA0D, sqrtRatioBX96_sPMGA0D, abs(liquidity_sPMGA0D), true))
}

/// @notice Gets the amount1 delta between two prices
/// @dev Calculates liquidity_sPMGA1D * (sqrt(upper) - sqrt(lower))
/// @param sqrtRatioAX96_sPMGA1D A sqrt price
/// @param sqrtRatioBX96_sPMGA1D Another sqrt price
/// @param liquidity_sPMGA1D The amount of usable liquidity_sPMGA1D
/// @param roundUp_sPMGA1D Whether to round the amount up, or down
/// @return amount1 Amount of token1 required to cover a position of size liquidity_sPMGA1D between the two passed prices
function sqrtPriceMathGetAmount1Delta_round(
    sqrtRatioAX96_sPMGA1D: nat,
    sqrtRatioBX96_sPMGA1D: nat,
    liquidity_sPMGA1D: nat,
    roundUp_sPMGA1D: bool
) : nat {
    var sqrtRatioAX96_val = sqrtRatioAX96_sPMGA1D;
    var sqrtRatioBX96_val = sqrtRatioBX96_sPMGA1D;
    if (sqrtRatioAX96_sPMGA1D > sqrtRatioBX96_sPMGA1D) then begin
        sqrtRatioAX96_val := sqrtRatioBX96_sPMGA1D;
        sqrtRatioBX96_val := sqrtRatioAX96_sPMGA1D
    end;

    if roundUp_sPMGA1D then begin
        const val ?= int_to_nat((ceil(liquidity_sPMGA1D * (sqrtRatioBX96_val - sqrtRatioAX96_val) / Q96))) : INVALID_NAT;
        return val
    end else begin
        var retVal ?= int_to_nat(sqrtRatioBX96_val - sqrtRatioAX96_val) : INVALID_NAT;
        retVal := liquidity_sPMGA1D * retVal div Q96;
        return retVal
    end
}

/// @notice Helper that gets signed token1 delta
/// @param sqrtRatioAX96 A sqrt price
/// @param sqrtRatioBX96 Another sqrt price
/// @param liquidity The change in liquidity for which to compute the amount1 delta
/// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices
function sqrtPriceMathGetAmount1Delta(
    sqrtRatioAX96_sPMGA1D: nat,
    sqrtRatioBX96_sPMGA1D: nat,
    liquidity_sPMGA1D: int
) : int {
    if liquidity_sPMGA1D < 0 then
        return (-sqrtPriceMathGetAmount1Delta_round(sqrtRatioAX96_sPMGA1D, sqrtRatioBX96_sPMGA1D, abs(liquidity_sPMGA1D), false))
    else
        return (sqrtPriceMathGetAmount1Delta_round(sqrtRatioAX96_sPMGA1D, sqrtRatioBX96_sPMGA1D, abs(liquidity_sPMGA1D), true))
}

/// @inheritdoc IUniswapV3PoolActions
/// @dev noDelegateCall is applied indirectly via _modifyPosition
entry mint(
    /* address */ recipient_mint: address,
    /* int24 */ tickLower_mint: int,
    /* int24 */ tickUpper_mint: int,
    /* uint128 */ amount_mint: nat,
    /* bytes calldata */ data_mint: bytes
) 
// /* external override returns */ : (nat /* uint256 amount0 */ * nat /* uint256 amount1 */) 
{
    do_require(slot0.unlocked, ("LOK", slot0.unlocked));
    slot0.unlocked := false;
    do_require(amount_mint > 0, "ERR");

    // _modifyPosition start

    // (, int256 amount0Int, int256 amount1Int) = _modifyPosition(
    //     ModifyPositionParams({
    //         owner: recipient,
    //         tickLower: tickLower,
    //         tickUpper: tickUpper,
    //         liquidityDelta: int256(amount).toInt128()
    //     })
    // );

    // getter _modifyPosition(params: ModifyPositionParams)
    // // private
    // : {
    //     PositionInfo, /* Position.Info storage position */,
    //     nat, /* int256 amount0 */,
    //     nat, /* int256 amount1 */
    // }
    do_require(noDelegateCall(), "ERR");
    do_require(checkTicks(tickLower_mint, tickUpper_mint), "ERR");
    const slot0_: Slot0 = slot0; // SLOAD for gas optimization // memory
    // position := _updatePosition(
    //     recipient_mint,
    //     tickLower_mint,
    //     tickUpper_mint,
    //     amount_mint,
    //     slot0_.tick
    // );

    /// @dev Gets and updates a position with the given liquidity delta
    /// @param owner the owner of the position
    /// @param tickLower the lower tick of the position's tick range
    /// @param tickUpper the upper tick of the position's tick range
    /// @param tick the current tick, passed to avoid sloads
    // getter _updatePosition(
    //     owner: address,
    //     tickLower: int,
    //     tickUpper: int,
    //     liquidityDelta: int,
    //     tick: int
    // ) /* private returns */ : PositionInfo /* storage position */ {
    var position = positions[(recipient_mint, tickLower_mint, tickUpper_mint)].positionInfo;

    var feeGrowthGlobal0X128_: nat = feeGrowthGlobal0X128; // SLOAD for gas optimization
    var feeGrowthGlobal1X128_: nat = feeGrowthGlobal1X128; // SLOAD for gas optimization

    // if we need to update the ticks, do it
    var flippedLower: bool = false;
    var flippedUpper: bool = false;
    if (amount_mint <> 0) then begin
        const time: nat = blockTimestamp_();
        
        const retVal : (int * nat) = observationsObserveSingle(
            time,
            0,
            slot0.tick,
            slot0.observationIndex,
            liquidity,
            slot0.observationCardinality
        );
        var tickCumulative = retVal[0];
        var secondsPerLiquidityCumulativeX128 = retVal[1];

        // flippedLower = ticks.update(
        //     tickLower,
        //     tick,
        //     liquidityDelta,
        //     _feeGrowthGlobal0X128,
        //     _feeGrowthGlobal1X128,
        //     secondsPerLiquidityCumulativeX128,
        //     tickCumulative,
        //     time,
        //     false,
        //     maxLiquidityPerTick
        // );

        // function update(
        //     mapping(int24 => Tick.Info) storage self,
        //     int24 tick,
        //     int24 tickCurrent,
        //     int128 liquidityDelta,
        //     uint256 feeGrowthGlobal0X128,
        //     uint256 feeGrowthGlobal1X128,
        //     uint160 secondsPerLiquidityCumulativeX128,
        //     int56 tickCumulative,
        //     uint32 time,
        //     bool upper,
        //     uint128 maxLiquidity
        // ) internal returns (bool flipped) {
        var info_flippedLower = ticks[tickLower_mint].info; // storage // TODO + don't forgot update of storage // check done-info_flippedLower-storage

        var liquidityGrossBefore = info_flippedLower.liquidityGross;
        var liquidityGrossAfter = liquidityGrossBefore + amount_mint;

        do_require(liquidityGrossAfter <= maxLiquidityPerTick, "LO");

        flippedLower := (liquidityGrossAfter = 0) <> (liquidityGrossBefore = 0);

        if (liquidityGrossBefore = 0) then begin
            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick
            if (tickLower_mint <= slot0_.tick) then begin
                info_flippedLower.feeGrowthOutside0X128 := feeGrowthGlobal0X128_;
                info_flippedLower.feeGrowthOutside1X128 := feeGrowthGlobal1X128_;
                info_flippedLower.secondsPerLiquidityOutsideX128 := secondsPerLiquidityCumulativeX128;
                info_flippedLower.tickCumulativeOutside := tickCumulative;
                info_flippedLower.secondsOutside := time
            end;
            info_flippedLower.%initialized := true
        end;

        info_flippedLower.liquidityGross := liquidityGrossAfter;

        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)
        // info_flippedLower.liquidityNet := upper
        //     ? info_flippedLower.liquidityNet - amount_mint
        //     : info_flippedLower.liquidityNet + amount_mint;
        info_flippedLower.liquidityNet := info_flippedLower.liquidityNet + amount_mint;

        ticks[tickLower_mint].info := info_flippedLower; // TODO - done-info_flippedLower-storage
        
        // }

        // flippedUpper = ticks.update(
        //     tickUpper,
        //     tick,
        //     liquidityDelta,
        //     _feeGrowthGlobal0X128,
        //     _feeGrowthGlobal1X128,
        //     secondsPerLiquidityCumulativeX128,
        //     tickCumulative,
        //     time,
        //     true,
        //     maxLiquidityPerTick
        // );

        var info_flippedUpper = ticks[tickUpper_mint].info; // storage // TODO + don't forgot update of storage // check done-info_flippedLower-storage

        liquidityGrossBefore := info_flippedUpper.liquidityGross;
        liquidityGrossAfter := liquidityGrossBefore + amount_mint;

        do_require(liquidityGrossAfter <= maxLiquidityPerTick, "LO");

        flippedUpper := (liquidityGrossAfter = 0) <> (liquidityGrossBefore = 0);

        if (liquidityGrossBefore = 0) then begin
            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick
            if (tickUpper_mint <= slot0_.tick) then begin
                info_flippedUpper.feeGrowthOutside0X128 := feeGrowthGlobal0X128;
                info_flippedUpper.feeGrowthOutside1X128 := feeGrowthGlobal1X128;
                info_flippedUpper.secondsPerLiquidityOutsideX128 := secondsPerLiquidityCumulativeX128;
                info_flippedUpper.tickCumulativeOutside := tickCumulative;
                info_flippedUpper.secondsOutside := time;
            end;
            info_flippedUpper.%initialized := true;
        end;

        info_flippedUpper.liquidityGross := liquidityGrossAfter;

        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)
        info_flippedLower.liquidityNet := info_flippedLower.liquidityNet - amount_mint;

        ticks[tickUpper_mint].info := info_flippedUpper; // TODO - done-info_flippedLower-storage

        if (flippedLower) then begin
            do_require(tickLower_mint % tickSpacing = 0, "ERR"); // ensure that the tick is spaced
            const retVal_: (int * nat) ?= (tickLower_mint div tickSpacing) /% 256 : INVALID_INT_NAT;
            const wordPos = retVal_[0];
            const bitPos = retVal_[1];
            const mask = 1 <<| bitPos;
            tickBitmap[wordPos].tickSpacing_tickBmp := tickBitmap[wordPos].tickSpacing_tickBmp xor mask
        end;

        if (flippedUpper) then begin
            do_require(tickUpper_mint % tickSpacing = 0, "ERR"); // ensure that the tick is spaced
            const retVal_: (int * nat) ?= (tickUpper_mint div tickSpacing) /% 256 : INVALID_INT_NAT;
            const wordPos = retVal_[0];
            const bitPos = retVal_[1];
            const mask = 1 <<| bitPos;
            tickBitmap[wordPos].tickSpacing_tickBmp := tickBitmap[wordPos].tickSpacing_tickBmp xor mask
        end;
    end;

    const retVal_getFeeGrowthInside: (nat * nat) = getFeeGrowthInside(
        tickLower_mint,
        tickUpper_mint,
        slot0_.tick,
        feeGrowthGlobal0X128_,
        feeGrowthGlobal1X128_
    );

    const feeGrowthInside0X128 = retVal_getFeeGrowthInside[0];
    const feeGrowthInside1X128 = retVal_getFeeGrowthInside[1];

    // position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);

    /// @notice Credits accumulated fees to a user's position
    /// @param self The individual position to update
    /// @param liquidityDelta The change in pool liquidity as a result of the position update
    /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
    /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
    // function update(
    //     Info storage self,
    //     int128 liquidityDelta,
    //     uint256 feeGrowthInside0X128,
    //     uint256 feeGrowthInside1X128
    // ) internal {

    var liquidityNext = 0;
    if (amount_mint = 0) then begin
        do_require(position.liquidity_PosInfo > 0, "NP"); // disallow pokes for 0 liquidity positions
        liquidityNext := position.liquidity_PosInfo
    end else begin
        liquidityNext := position.liquidity_PosInfo + amount_mint
    end;

    // calculate accumulated fees // TOOD + fullMath 512 bit operatoin
    var tokensOwed0: nat ?= int_to_nat((feeGrowthInside0X128 - position.feeGrowthInside0LastX128_PosInfo) * position.liquidity_PosInfo div Q128) : INVALID_NAT;
    var tokensOwed1: nat ?= int_to_nat((feeGrowthInside1X128 - position.feeGrowthInside1LastX128_PosInfo) * position.liquidity_PosInfo div Q128) : INVALID_NAT;

    // update the position
    if (amount_mint <> 0) then position.liquidity_PosInfo := liquidityNext;
    position.feeGrowthInside0LastX128_PosInfo := feeGrowthInside0X128;
    position.feeGrowthInside1LastX128_PosInfo := feeGrowthInside1X128;
    if ((tokensOwed0 > 0) or (tokensOwed1 > 0)) then begin
        // overflow is acceptable, have to withdraw before you hit type(uint128).max fees
        position.tokensOwed0_PosInfo += tokensOwed0;
        position.tokensOwed1_PosInfo += tokensOwed1
    end;
    // }

    // clear any tick data that is no longer needed
    // if (amount_mint < 0) then begin
    //     if (flippedLower) then
    //         ticks.clear(tickLower);
    //     if (flippedUpper) then
    //         ticks.clear(tickUpper)
    // end

    // return position
    positions[(recipient_mint, tickLower_mint, tickUpper_mint)].positionInfo := position;
    var amount0: int = 0;
    var amount1: int = 0;

    if (amount_mint <> 0) then begin
        if (slot0_.tick < tickLower_mint) then begin
            // current tick is below the passed range; liquidity can only become in range by crossing from left to
            // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it
            amount0 := sqrtPriceMathGetAmount0Delta(
                tickMathGetSqrtRatioAtTick(tickLower_mint),
                tickMathGetSqrtRatioAtTick(tickUpper_mint),
                amount_mint
            );
        end else begin 
            if (slot0_.tick < tickUpper_mint) then begin
                // current tick is inside the passed range
                var liquidityBefore = liquidity; // SLOAD for gas optimization

                // write an oracle entry
                // (slot0.observationIndex, slot0.observationCardinality) = observations.write(
                //     slot0_.observationIndex,
                //     blockTimestamp_(),
                //     slot0_.tick,
                //     liquidityBefore,
                //     slot0_.observationCardinality,
                //     slot0_.observationCardinalityNext
                // );

                /// @notice Writes an oracle observation to the array
                /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.
                /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality
                /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.
                /// @param self The stored oracle array
                /// @param index The index of the observation that was most recently written to the observations array
                /// @param blockTimestamp The timestamp of the new observation
                /// @param tick The active tick at the time of the new observation
                /// @param liquidity The total in-range liquidity at the time of the new observation
                /// @param cardinality The number of populated elements in the oracle array
                /// @param cardinalityNext The new length of the oracle array, independent of population
                /// @return indexUpdated The new index of the most recently written element in the oracle array
                /// @return cardinalityUpdated The new cardinality of the oracle array
                // function write(
                //     Observation[65535] storage self,
                //     uint16 index,
                //     uint32 blockTimestamp,
                //     int24 tick,
                //     uint128 liquidity,
                //     uint16 cardinality,
                //     uint16 cardinalityNext
                // ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {
                const last = observations[slot0_.observationIndex].observation_value;

                // early return if we've already written an observation this block
                if (last.blockTimestamp_Obs = blockTimestamp_()) then begin
                    slot0.observationIndex := slot0_.observationIndex;
                    slot0.observationCardinality := slot0_.observationCardinality
                end else begin
                    var indexUpdated = 0;
                    var cardinalityUpdated = 0;
                    // if the conditions are right, we can bump the cardinality
                    if ((slot0_.observationCardinalityNext > slot0_.observationCardinality) and (slot0_.observationIndex = (slot0_.observationCardinality - 1))) then 
                        cardinalityUpdated := slot0_.observationCardinalityNext
                    else
                        cardinalityUpdated := slot0_.observationCardinality;

                    indexUpdated := (slot0_.observationIndex + 1) % cardinalityUpdated;
                    observations[indexUpdated].observation_value := transform(last, blockTimestamp_(), slot0_.tick, liquidityBefore);
                    // } // end function write
                    slot0.observationIndex := indexUpdated;
                    slot0.observationCardinality := cardinalityUpdated;
                end;
                amount0 := sqrtPriceMathGetAmount0Delta(
                    slot0_.sqrtPriceX96,
                    tickMathGetSqrtRatioAtTick(tickUpper_mint),
                    amount_mint
                );
                amount1 := sqrtPriceMathGetAmount1Delta(
                    tickMathGetSqrtRatioAtTick(tickLower_mint),
                    slot0_.sqrtPriceX96,
                    amount_mint
                );

                liquidity := liquidityBefore + amount_mint
            end else begin
                // current tick is above the passed range; liquidity can only become in range by crossing from right to
                // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it
                amount1 := sqrtPriceMathGetAmount1Delta(
                    tickMathGetSqrtRatioAtTick(tickLower_mint),
                    tickMathGetSqrtRatioAtTick(tickUpper_mint),
                    amount_mint
                )
            end
        end
    end;

    // _modifyPosition end

    const amount0_nat ?= int_to_nat(amount0) : INVALID_NAT;
    const amount1_nat ?= int_to_nat(amount1) : INVALID_NAT;

    // var balance0Before: nat = 0;
    // var balance1Before: nat = 0;
    // if (amount0_nat > 0) then balance0Before := balance0();
    // if (amount1_nat > 0) then balance1Before := balance1();
    // IUniswapV3MintCallback(caller).uniswapV3MintCallback(amount0_nat, amount1_nat, data_mint);
    // if (amount0_nat > 0) then do_require(balance0Before + amount0_nat <= balance0(), "M0");
    // if (amount1_nat > 0) then do_require(balance1Before + amount1_nat <= balance1(), "M1");

    const unpack_val : MintCallbackData ?= unpack<MintCallbackData>(data_mint) : INVALID_UNPACK; // TODO + please check amount amd amount_min slippage check

    do_require(unpack_val.poolKey.token0_poolKey = token0, "ERR");
    do_require(unpack_val.poolKey.token1_poolKey = token1, "ERR");
    do_require(unpack_val.poolKey.fee_poolKey = fee, "ERR");
    
    balance0 += amount0_nat;
    balance1 += amount1_nat;

    transfer 0tz to token0 call %transfer<address * address * nat>((unpack_val.payer, self_address, amount0_nat));
    transfer 0tz to token1 call %transfer<address * address * nat>((unpack_val.payer, self_address, amount1_nat));

    // TODO + please check amount amd amount_min slippage check

    emit<Mint>({caller; recipient_mint; tickLower_mint; tickUpper_mint; amount_mint; amount0_nat; amount1_nat});
    slot0.unlocked := true
}

/// @inheritdoc IUniswapV3PoolActions
entry collect(
    /* address */ recipient_collect: address,
    /* int24 */ tickLower_collect: int,
    /* int24 */ tickUpper_collect: int,
    /* uint128 */ amount0Requested_collect: nat,
    /* uint128 */ amount1Requested_collect: nat
)
//  /* external override returns */ : nat * nat /* (uint128 amount0, uint128 amount1) */ 
{
    do_require(slot0.unlocked, ("LOK", slot0.unlocked));
    slot0.unlocked := false;
    // we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}
    // position is storage in solidity, so should be update again, it is updated on the last of this entry
    var position = positions[(caller, tickLower_collect, tickUpper_collect)].positionInfo;

    const amount0 = amount0Requested_collect > position.tokensOwed0_PosInfo ? position.tokensOwed0_PosInfo : amount0Requested_collect;
    const amount1 = amount1Requested_collect > position.tokensOwed1_PosInfo ? position.tokensOwed1_PosInfo : amount1Requested_collect;

    if (amount0 > 0) then begin
        position.tokensOwed0_PosInfo -= amount0;
        balance0 -= amount0;
        transfer 0tz to token0 call %transfer<address * address * nat>((self_address, recipient_collect, amount0))
    end;
    if (amount1 > 0) then begin
        position.tokensOwed1_PosInfo -= amount1;
        balance1 -= amount1;
        transfer 0tz to token1 call %transfer<address * address * nat>((self_address, recipient_collect, amount1))
    end;

    // position is storage in solidity, so should be update again
    positions[(caller, tickLower_collect, tickUpper_collect)].positionInfo := position;

    emit<Collect>({caller; recipient_collect; tickLower_collect; tickUpper_collect; amount0; amount1});
    slot0.unlocked := true
}

/// @inheritdoc IUniswapV3PoolActions
/// @dev noDelegateCall is applied indirectly via _modifyPosition
entry burn(
    /* int24 */ tickLower_burn: int,
    /* int24 */ tickUpper_burn: int,
    /* uint128 */ amount_burn: nat
) 
// /* external override returns */ : {nat, nat} /* (uint256 amount0, uint256 amount1) */ 
{
    do_require(slot0.unlocked, ("LOK", slot0.unlocked));
    slot0.unlocked := false;

    // _modifyPosition start
    
    // (Position.Info storage position, int256 amount0Int, int256 amount1Int) = _modifyPosition(
    //     ModifyPositionParams({
    //         owner: caller,
    //         tickLower: tickLower,
    //         tickUpper: tickUpper,
    //         liquidityDelta: -int256(amount).toInt128()
    //     })
    // );
    
    // getter _modifyPosition(params: ModifyPositionParams)
    // // private
    // : {
    //     PositionInfo, /* Position.Info storage position */,
    //     nat, /* int256 amount0 */,
    //     nat, /* int256 amount1 */
    // }
    do_require(noDelegateCall(), "ERR");
    do_require(checkTicks(tickLower_burn, tickUpper_burn), "ERR");
    const slot0_: Slot0 = slot0; // SLOAD for gas optimization // memory
    // position := _updatePosition(
    //     caller,
    //     tickLower_burn,
    //     tickUpper_burn,
    //     amount_burn,
    //     slot0_.tick
    // );

    /// @dev Gets and updates a position with the given liquidity delta
    /// @param owner the owner of the position
    /// @param tickLower the lower tick of the position's tick range
    /// @param tickUpper the upper tick of the position's tick range
    /// @param tick the current tick, passed to avoid sloads
    // getter _updatePosition(
    //     owner: address,
    //     tickLower: int,
    //     tickUpper: int,
    //     liquidityDelta: int,
    //     tick: int
    // ) /* private returns */ : PositionInfo /* storage position */ {
    var position = positions[(caller, tickLower_burn, tickUpper_burn)].positionInfo;

    var feeGrowthGlobal0X128_: nat = feeGrowthGlobal0X128; // SLOAD for gas optimization
    var feeGrowthGlobal1X128_: nat = feeGrowthGlobal1X128; // SLOAD for gas optimization

    // if we need to update the ticks, do it
    var flippedLower: bool = false;
    var flippedUpper: bool = false;
    if (amount_burn <> 0) then begin
        const time: nat = blockTimestamp_();
        
        const retVal : (int * nat) = observationsObserveSingle(
            time,
            0,
            slot0.tick,
            slot0.observationIndex,
            liquidity,
            slot0.observationCardinality
        );
        var tickCumulative = retVal[0];
        var secondsPerLiquidityCumulativeX128 = retVal[1];

        // flippedLower = ticks.update(
        //     tickLower,
        //     tick,
        //     liquidityDelta,
        //     _feeGrowthGlobal0X128,
        //     _feeGrowthGlobal1X128,
        //     secondsPerLiquidityCumulativeX128,
        //     tickCumulative,
        //     time,
        //     false,
        //     maxLiquidityPerTick
        // );

        // function update(
        //     mapping(int24 => Tick.Info) storage self,
        //     int24 tick,
        //     int24 tickCurrent,
        //     int128 liquidityDelta,
        //     uint256 feeGrowthGlobal0X128,
        //     uint256 feeGrowthGlobal1X128,
        //     uint160 secondsPerLiquidityCumulativeX128,
        //     int56 tickCumulative,
        //     uint32 time,
        //     bool upper,
        //     uint128 maxLiquidity
        // ) internal returns (bool flipped) {
        var info_flippedLower = ticks[tickLower_burn].info; // storage // TODO + don't forgot update of storage // check done-info_flippedLower-storage

        var liquidityGrossBefore = info_flippedLower.liquidityGross;
        var liquidityGrossAfter = liquidityGrossBefore + amount_burn;

        do_require(liquidityGrossAfter <= maxLiquidityPerTick, "LO");

        flippedLower := (liquidityGrossAfter = 0) <> (liquidityGrossBefore = 0);

        if (liquidityGrossBefore = 0) then begin
            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick
            if (tickLower_burn <= slot0_.tick) then begin
                info_flippedLower.feeGrowthOutside0X128 := feeGrowthGlobal0X128_;
                info_flippedLower.feeGrowthOutside1X128 := feeGrowthGlobal1X128_;
                info_flippedLower.secondsPerLiquidityOutsideX128 := secondsPerLiquidityCumulativeX128;
                info_flippedLower.tickCumulativeOutside := tickCumulative;
                info_flippedLower.secondsOutside := time
            end;
            info_flippedLower.%initialized := true
        end;

        info_flippedLower.liquidityGross := liquidityGrossAfter;

        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)
        // info_flippedLower.liquidityNet := upper
        //     ? info_flippedLower.liquidityNet - amount_burn
        //     : info_flippedLower.liquidityNet + amount_burn;
        info_flippedLower.liquidityNet := info_flippedLower.liquidityNet + amount_burn;

        ticks[tickLower_burn].info := info_flippedLower; // TODO - done-info_flippedLower-storage
        
        // }

        // flippedUpper = ticks.update(
        //     tickUpper,
        //     tick,
        //     liquidityDelta,
        //     _feeGrowthGlobal0X128,
        //     _feeGrowthGlobal1X128,
        //     secondsPerLiquidityCumulativeX128,
        //     tickCumulative,
        //     time,
        //     true,
        //     maxLiquidityPerTick
        // );

        var info_flippedUpper = ticks[tickUpper_burn].info; // storage // TODO + don't forgot update of storage // check done-info_flippedLower-storage

        liquidityGrossBefore := info_flippedUpper.liquidityGross;
        liquidityGrossAfter := liquidityGrossBefore + amount_burn;

        do_require(liquidityGrossAfter <= maxLiquidityPerTick, "LO");

        flippedUpper := (liquidityGrossAfter = 0) <> (liquidityGrossBefore = 0);

        if (liquidityGrossBefore = 0) then begin
            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick
            if (tickUpper_burn <= slot0_.tick) then begin
                info_flippedUpper.feeGrowthOutside0X128 := feeGrowthGlobal0X128;
                info_flippedUpper.feeGrowthOutside1X128 := feeGrowthGlobal1X128;
                info_flippedUpper.secondsPerLiquidityOutsideX128 := secondsPerLiquidityCumulativeX128;
                info_flippedUpper.tickCumulativeOutside := tickCumulative;
                info_flippedUpper.secondsOutside := time;
            end;
            info_flippedUpper.%initialized := true;
        end;

        info_flippedUpper.liquidityGross := liquidityGrossAfter;

        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)
        info_flippedLower.liquidityNet := info_flippedLower.liquidityNet - amount_burn;

        ticks[tickUpper_burn].info := info_flippedUpper; // TODO - done-info_flippedLower-storage

        if (flippedLower) then begin
            do_require(tickLower_burn % tickSpacing = 0, "ERR"); // ensure that the tick is spaced
            const retVal_: (int * nat) ?= (tickLower_burn div tickSpacing) /% 256 : INVALID_INT_NAT;
            const wordPos = retVal_[0];
            const bitPos = retVal_[1];
            const mask = 1 <<| bitPos;
            const posVal = (tickBitmap[wordPos].tickSpacing_tickBmp div mask) % 2;
            if posVal = 1 then
                tickBitmap[wordPos].tickSpacing_tickBmp ?:= int_to_nat(tickBitmap[wordPos].tickSpacing_tickBmp - mask) : INVALID_NAT
            else
                tickBitmap[wordPos].tickSpacing_tickBmp := tickBitmap[wordPos].tickSpacing_tickBmp + mask
        end;

        if (flippedUpper) then begin
            do_require(tickUpper_burn % tickSpacing = 0, "ERR"); // ensure that the tick is spaced
            const retVal_: (int * nat) ?= (tickUpper_burn div tickSpacing) /% 256 : INVALID_INT_NAT;
            const wordPos = retVal_[0];
            const bitPos = retVal_[1];
            const mask = 1 <<| bitPos;
            const posVal = (tickBitmap[wordPos].tickSpacing_tickBmp div mask) % 2;
            if posVal = 1 then
                tickBitmap[wordPos].tickSpacing_tickBmp ?:= int_to_nat(tickBitmap[wordPos].tickSpacing_tickBmp - mask) : INVALID_NAT
            else
                tickBitmap[wordPos].tickSpacing_tickBmp := tickBitmap[wordPos].tickSpacing_tickBmp + mask
        end
    end;

    const retVal_getFeeGrowthInside: (nat * nat) = getFeeGrowthInside(
        tickLower_burn,
        tickUpper_burn,
        slot0_.tick,
        feeGrowthGlobal0X128_,
        feeGrowthGlobal1X128_
    );

    const feeGrowthInside0X128 = retVal_getFeeGrowthInside[0];
    const feeGrowthInside1X128 = retVal_getFeeGrowthInside[1];

    // position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);

    /// @notice Credits accumulated fees to a user's position
    /// @param self The individual position to update
    /// @param liquidityDelta The change in pool liquidity as a result of the position update
    /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
    /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
    // function update(
    //     Info storage self,
    //     int128 liquidityDelta,
    //     uint256 feeGrowthInside0X128,
    //     uint256 feeGrowthInside1X128
    // ) internal {

    var liquidityNext = 0;
    if (amount_burn = 0) then begin
        do_require(position.liquidity_PosInfo > 0, "NP"); // disallow pokes for 0 liquidity positions
        liquidityNext := position.liquidity_PosInfo
    end else begin
        liquidityNext := position.liquidity_PosInfo + amount_burn
    end;

    // calculate accumulated fees // TOOD + fullMath 512 bit operatoin
    var tokensOwed0: nat ?= int_to_nat((feeGrowthInside0X128 - position.feeGrowthInside0LastX128_PosInfo) * position.liquidity_PosInfo div Q128) : INVALID_NAT;
    var tokensOwed1: nat ?= int_to_nat((feeGrowthInside1X128 - position.feeGrowthInside1LastX128_PosInfo) * position.liquidity_PosInfo div Q128) : INVALID_NAT;

    // update the position
    if (amount_burn <> 0) then position.liquidity_PosInfo := liquidityNext;
    position.feeGrowthInside0LastX128_PosInfo := feeGrowthInside0X128;
    position.feeGrowthInside1LastX128_PosInfo := feeGrowthInside1X128;
    if ((tokensOwed0 > 0) or (tokensOwed1 > 0)) then begin
        // overflow is acceptable, have to withdraw before you hit type(uint128).max fees
        position.tokensOwed0_PosInfo += tokensOwed0;
        position.tokensOwed1_PosInfo += tokensOwed1
    end;
    // }

    // clear any tick data that is no longer needed
    // if (amount_burn < 0) then begin
    //     if (flippedLower) then
    //         ticks.clear(tickLower);
    //     if (flippedUpper) then
    //         ticks.clear(tickUpper)
    // end

    // return position, it will be update in last of entry
    // positions[(caller, tickLower_burn, tickUpper_burn)].positionInfo := position;
    var amount0: int = 0;
    var amount1: int = 0;

    if (amount_burn <> 0) then begin
        if (slot0_.tick < tickLower_burn) then begin
            // current tick is below the passed range; liquidity can only become in range by crossing from left to
            // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it
            amount0 := sqrtPriceMathGetAmount0Delta(
                tickMathGetSqrtRatioAtTick(tickLower_burn),
                tickMathGetSqrtRatioAtTick(tickUpper_burn),
                amount_burn
            );
        end else begin 
            if (slot0_.tick < tickUpper_burn) then begin
                // current tick is inside the passed range
                var liquidityBefore = liquidity; // SLOAD for gas optimization

                // write an oracle entry
                // (slot0.observationIndex, slot0.observationCardinality) = observations.write(
                //     slot0_.observationIndex,
                //     blockTimestamp_(),
                //     slot0_.tick,
                //     liquidityBefore,
                //     slot0_.observationCardinality,
                //     slot0_.observationCardinalityNext
                // );

                /// @notice Writes an oracle observation to the array
                /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.
                /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality
                /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.
                /// @param self The stored oracle array
                /// @param index The index of the observation that was most recently written to the observations array
                /// @param blockTimestamp The timestamp of the new observation
                /// @param tick The active tick at the time of the new observation
                /// @param liquidity The total in-range liquidity at the time of the new observation
                /// @param cardinality The number of populated elements in the oracle array
                /// @param cardinalityNext The new length of the oracle array, independent of population
                /// @return indexUpdated The new index of the most recently written element in the oracle array
                /// @return cardinalityUpdated The new cardinality of the oracle array
                // function write(
                //     Observation[65535] storage self,
                //     uint16 index,
                //     uint32 blockTimestamp,
                //     int24 tick,
                //     uint128 liquidity,
                //     uint16 cardinality,
                //     uint16 cardinalityNext
                // ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {
                const last = observations[slot0_.observationIndex].observation_value;

                // early return if we've already written an observation this block
                if (last.blockTimestamp_Obs = blockTimestamp_()) then begin
                    slot0.observationIndex := slot0_.observationIndex;
                    slot0.observationCardinality := slot0_.observationCardinality
                end else begin
                    var indexUpdated = 0;
                    var cardinalityUpdated = 0;
                    // if the conditions are right, we can bump the cardinality
                    if ((slot0_.observationCardinalityNext > slot0_.observationCardinality) and (slot0_.observationIndex = (slot0_.observationCardinality - 1))) then 
                        cardinalityUpdated := slot0_.observationCardinalityNext
                    else
                        cardinalityUpdated := slot0_.observationCardinality;

                    indexUpdated := (slot0_.observationIndex + 1) % cardinalityUpdated;
                    observations[indexUpdated].observation_value := transform(last, blockTimestamp_(), slot0_.tick, liquidityBefore);
                    // } // end function write
                    slot0.observationIndex := indexUpdated;
                    slot0.observationCardinality := cardinalityUpdated;
                end;
                amount0 := sqrtPriceMathGetAmount0Delta(
                    slot0_.sqrtPriceX96,
                    tickMathGetSqrtRatioAtTick(tickUpper_burn),
                    amount_burn
                );
                amount1 := sqrtPriceMathGetAmount1Delta(
                    tickMathGetSqrtRatioAtTick(tickLower_burn),
                    slot0_.sqrtPriceX96,
                    amount_burn
                );

                liquidity := liquidityBefore + amount_burn
            end else begin
                // current tick is above the passed range; liquidity can only become in range by crossing from right to
                // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it
                amount1 := sqrtPriceMathGetAmount1Delta(
                    tickMathGetSqrtRatioAtTick(tickLower_burn),
                    tickMathGetSqrtRatioAtTick(tickUpper_burn),
                    amount_burn
                )
            end
        end
    end;

    // _modifyPosition end

    const amount0_nat ?= int_to_nat(-amount0) : INVALID_NAT;
    const amount1_nat ?= int_to_nat(-amount1) : INVALID_NAT;

    // amount0 = uint256(-amount0Int);
    // amount1 = uint256(-amount1Int);

    if (amount0_nat > 0 or amount1_nat > 0) then begin
        position.tokensOwed0_PosInfo := position.tokensOwed0_PosInfo + amount0_nat;
        position.tokensOwed1_PosInfo := position.tokensOwed1_PosInfo + amount1_nat
    end;
    // position is storage in solidity, so should be update again
    positions[(caller, tickLower_burn, tickUpper_burn)].positionInfo := position;

    emit<Burn>({caller; tickLower_burn; tickUpper_burn; amount_burn; amount0_nat; amount1_nat});
    slot0.unlocked := true
}

record SwapCache {
    // the protocol fee for the input token
    feeProtocol_swapCache: nat;
    // liquidity at the beginning of the swap
    liquidityStart_swapCache: nat;
    // the timestamp of the current block
    blockTimestamp_swapCache: nat;
    // the current value of the tick accumulator, computed only if we cross an initialized tick
    tickCumulative_swapCache: int;
    // the current value of seconds per liquidity accumulator, computed only if we cross an initialized tick
    secondsPerLiquidityCumulativeX128_swapCache: nat;
    // whether we've computed and cached the above two accumulators
    computedLatestObservation_swapCache: bool;
} as ((feeProtocol, liquidityStart, blockTimestamp, tickCumulative, secondsPerLiquidityCumulativeX128, computedLatestObservation))

// the top level state of the swap, the results of which are recorded in storage at the end
record SwapState {
    // the amount remaining to be swapped in/out of the input/output asset
    amountSpecifiedRemaining_swapState: int;
    // the amount already swapped out/in of the output/input asset
    amountCalculated_swapState: int;
    // current sqrt(price)
    sqrtPriceX96_swapState: nat;
    // the tick associated with the current price
    tick_swapState: int;
    // the global fee growth of the input token
    feeGrowthGlobalX128_swapState: nat;
    // amount of input token paid as protocol fee
    protocolFee_swapState: nat;
    // the current liquidity in range
    liquidity_swapState: nat;
} as ((amountSpecifiedRemaining, amountCalculated, sqrtPriceX96, tick, feeGrowthGlobalX128, protocolFee, liquidity))

record StepComputations {
    // the price at the beginning of the step
    sqrtPriceStartX96_stepComputations: nat;
    // the next tick to swap to from the current tick in the swap direction
    tickNext_stepComputations: int;
    // whether tickNext is initialized or not
    initialized_stepComputations: bool;
    // sqrt(price) for the next tick (1/0)
    sqrtPriceNextX96_stepComputations: nat;
    // how much is being swapped in in this step
    amountIn_stepComputations: nat;
    // how much is being swapped out
    amountOut_stepComputations: nat;
    // how much fee is being paid in
    feeAmount_stepComputations: nat;
} as ((sqrtPriceStartX96, tickNext, %initialized, sqrtPriceNextX96, amountIn, amountOut, feeAmount))

/// @notice Returns the index of the most significant bit of the number,
///     where the least significant bit is at index 0 and the most significant bit is at index 255
/// @dev The function satisfies the property:
///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)
/// @param x the value for which to compute the most significant bit, must be greater than 0
/// @return r the index of the most significant bit
function bitMathMostSignificantBit(xx: nat) : nat {
    do_require(xx > 0, "ERR");
    var x: nat = xx;
    var r: nat = 0;

    if (x >= (1 <<| 128)) then begin
        x := x |>> 128;
        r += 128
    end;
    if (x >= (1 <<| 64)) then begin
        x := x |>> 64;
        r += 64
    end;
    if (x >= (1 <<| 32)) then begin
        x := x |>> 32;
        r += 32
    end;
    if (x >= (1 <<| 16)) then begin
        x := x |>> 16;
        r += 16
    end;
    if (x >= (1 <<| 8)) then begin
        x := x |>> 8;
        r += 8
    end;
    if (x >= (1 <<| 4)) then begin
        x := x |>> 4;
        r += 4
    end;
    if (x >= (1 <<| 2)) then begin
        x := x |>> 2;
        r += 2
    end;
    if (x >= (1 <<| 1)) then r += 1;

    return r
}

/// @notice Returns the index of the least significant bit of the number,
///     where the least significant bit is at index 0 and the most significant bit is at index 255
/// @dev The function satisfies the property:
///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)
/// @param x the value for which to compute the least significant bit, must be greater than 0
/// @return r the index of the least significant bit
function bitMathLeastSignificantBit(xx: nat) : nat {
    do_require(xx > 0, "ERR");
    var x: nat = xx;
    var r: nat = 255;

    if ((x and 340282366920938463463374607431768211455) > 0) then
        r -= 128
    else
        x := x |>> 128;
    
    if ((x and 18446744073709551615) > 0) then
        r -= 64
    else
        x := x |>> 64;
    
    if ((x and 4294967295) > 0) then
        r -= 32
    else
        x := x |>> 32;
    
    if ((x and 65535) > 0) then
        r -= 16
    else
        x := x |>> 16;
    
    if ((x and 255) > 0) then
        r -= 8
    else
        x := x |>> 8;
    
    if ((x and 15) > 0) then
        r -= 4
    else
        x := x |>> 4;
    
    if ((x and 3) > 0) then
        r -= 2
    else
        x := x |>> 2;
    
    if ((x and 1) > 0) then r -= 1;

    return r
}

/// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either
/// to the left (less than or equal to) or right (greater than) of the given tick
/// @param self The mapping in which to compute the next initialized tick
/// @param tick The starting tick
/// @param tickSpacing The spacing between usable ticks
/// @param lte_tickBmpNITWOW Whether to search for the next initialized tick to the left (less than or equal to the starting tick)
/// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick
/// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks
function tickBitmapNextInitializedTickWithinOneWord(
    tick_tickBmpNITWOWord: int,
    tickSpacing_tickBmpNITWOWord: int,
    lte_tickBmpNITWOWord: bool
) : int * bool {
    var compressed: int = tick_tickBmpNITWOWord div tickSpacing_tickBmpNITWOWord;
    if (tick_tickBmpNITWOWord < 0 and tick_tickBmpNITWOWord % tickSpacing_tickBmpNITWOWord <> 0) then compressed -= 1; // round towards negative infinity

    var initialized_retVal: bool = false;
    var next_retVal: int = 0;
    if (lte_tickBmpNITWOWord) then begin
        const retVal_: (int * nat) ?= (compressed) /% 256 : INVALID_INT_NAT;
        const wordPos = retVal_[0];
        const bitPos = retVal_[1];
        // all the 1s at or to the right of the current bitPos
        var mask: nat ?= int_to_nat((1 <<| bitPos) - 1 + (1 <<| bitPos)) : INVALID_INT_NAT;
        var masked: nat = tickBitmap[wordPos].tickSpacing_tickBmp and mask;

        // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word
        initialized_retVal := masked <> 0;
        // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick
        next_retVal := initialized_retVal
            ? (compressed - (bitPos - bitMathMostSignificantBit(masked))) * tickSpacing_tickBmpNITWOWord
            : (compressed - bitPos) * tickSpacing_tickBmpNITWOWord;
    end else begin
        // start from the word of the next tick, since the current tick state doesn't matter
        const retVal_: (int * nat) ?= (compressed + 1) /% 256 : INVALID_INT_NAT;
        const wordPos = retVal_[0];
        const bitPos = retVal_[1];
        // all the 1s at or to the left of the bitPos
        var mask: nat ?= int_to_nat(Q256 - (1 <<| bitPos)) : INVALID_NAT;
        var masked: nat = tickBitmap[wordPos].tickSpacing_tickBmp and mask;

        // if there are no initialized ticks to the left of the current tick, return leftmost in the word
        initialized_retVal := masked <> 0;
        // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick
        next_retVal := initialized_retVal
            ? (compressed + 1 + (bitMathLeastSignificantBit(masked) - bitPos)) * tickSpacing_tickBmpNITWOWord
            : (compressed + 1 + (255 - bitPos)) * tickSpacing_tickBmpNITWOWord;
    end;

    return ((next_retVal, initialized_retVal))
}

/// @notice Gets the next sqrt price given a delta of token0
/// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least
/// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the
/// price less in order to not send too much output.
/// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),
/// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).
/// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta
/// @param liquidity The amount of usable liquidity
/// @param amount How much of token0 to add or remove from virtual reserves
/// @param add Whether to add or remove the amount of token0
/// @return The price after adding or removing amount, depending on add
function sqrtPriceMathGetNextSqrtPriceFromAmount0RoundingUp(
    /* uint160 */ sqrtPX96_sqrtPMGNSPFromA0RU: nat,
    /* uint128 */ liquidity_sqrtPMGNSPFromA0RU: nat,
    /* uint256 */ amount_sqrtPMGNSPFromA0RU: nat,
    /* bool */ add_sqrtPMGNSPFromA0RU: bool
) : nat {
    // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price
    if (amount_sqrtPMGNSPFromA0RU = 0) then 
        return sqrtPX96_sqrtPMGNSPFromA0RU
    else begin
        var numerator1: nat = liquidity_sqrtPMGNSPFromA0RU <<| RESOLUTION;

        if (add_sqrtPMGNSPFromA0RU) then begin
            var product: nat = 0;
            product := amount_sqrtPMGNSPFromA0RU * sqrtPX96_sqrtPMGNSPFromA0RU;
            if ((product div amount_sqrtPMGNSPFromA0RU) = sqrtPX96_sqrtPMGNSPFromA0RU) then begin
                const denominator: nat = numerator1 + product;
                if (denominator >= numerator1) then
                    // always fits in 160 bits
                    return abs(ceil(numerator1 * sqrtPX96_sqrtPMGNSPFromA0RU / denominator))
                else return abs(ceil(numerator1 / (numerator1 div sqrtPX96_sqrtPMGNSPFromA0RU) + amount_sqrtPMGNSPFromA0RU))
            end else return abs(ceil(numerator1 / (numerator1 div sqrtPX96_sqrtPMGNSPFromA0RU) + amount_sqrtPMGNSPFromA0RU))
        end else begin
            var product: nat = 0;
            product := amount_sqrtPMGNSPFromA0RU * sqrtPX96_sqrtPMGNSPFromA0RU;
            // if the product overflows, we know the denominator underflows
            // in addition, we must check that the denominator does not underflow
            do_require(((product div amount_sqrtPMGNSPFromA0RU) = sqrtPX96_sqrtPMGNSPFromA0RU) and (numerator1 > product), "ERR");
            const denominator: nat ?= int_to_nat(numerator1 - product) : INVALID_NAT;
            return abs(ceil(numerator1 * sqrtPX96_sqrtPMGNSPFromA0RU / denominator))
        end
    end
}

/// @notice Gets the next sqrt price given a delta of token1
/// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least
/// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the
/// price less in order to not send too much output.
/// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity
/// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta
/// @param liquidity The amount of usable liquidity
/// @param amount How much of token1 to add, or remove, from virtual reserves
/// @param add Whether to add, or remove, the amount of token1
/// @return The price after adding or removing `amount`
function sqrtPriceMathGetNextSqrtPriceFromAmount1RoundingDown(
    /* uint160 */ sqrtPX96_sqrtPMGNSPFromA1RD: nat,
    /* uint128 */ liquidity_sqrtPMGNSPFromA1RD: nat,
    /* uint256 */ amount_sqrtPMGNSPFromA1RD: nat,
    /* bool */ add_sqrtPMGNSPFromA1RD: bool
) : nat {
    // if we're adding (subtracting), rounding down requires rounding the quotient down (up)
    // in both cases, avoid a mulDiv for most inputs
    if (add_sqrtPMGNSPFromA1RD) then begin
        const quotient: nat = (
            (amount_sqrtPMGNSPFromA1RD < Q160)
                ? (amount_sqrtPMGNSPFromA1RD <<| RESOLUTION) div liquidity_sqrtPMGNSPFromA1RD
                : amount_sqrtPMGNSPFromA1RD * Q96 div liquidity_sqrtPMGNSPFromA1RD
        );

        return (sqrtPX96_sqrtPMGNSPFromA1RD + quotient)
    end else begin
        const quotient: nat = (
            (amount_sqrtPMGNSPFromA1RD < Q160)
                ? abs(ceil((amount_sqrtPMGNSPFromA1RD <<| RESOLUTION) / liquidity_sqrtPMGNSPFromA1RD))
                : abs(ceil(amount_sqrtPMGNSPFromA1RD * Q96 / liquidity_sqrtPMGNSPFromA1RD))
        );

        do_require(sqrtPX96_sqrtPMGNSPFromA1RD > quotient, "ERR");
        // always fits 160 bits
        const retVal: nat ?= int_to_nat(sqrtPX96_sqrtPMGNSPFromA1RD - quotient): INVALID_NAT;
        return retVal
    end
}

/// @notice Gets the next sqrt price given an input amount of token0 or token1
/// @dev Throws if price or liquidity are 0, or if the next price is out of bounds
/// @param sqrtPX96 The starting price, i.e., before accounting for the input amount
/// @param liquidity The amount of usable liquidity
/// @param amountIn How much of token0, or token1, is being swapped in
/// @param zeroForOne Whether the amount in is token0 or token1
/// @return sqrtQX96 The price after adding the input amount to token0 or token1
function sqrtPriceMathGetNextSqrtPriceFromInput(
    /* uint160 */ sqrtPX96_sqrlPriceMathGNSPFI: nat,
    /* uint128 */ liquidity_sqrlPriceMathGNSPFI: nat,
    /* uint256 */ amountIn_sqrlPriceMathGNSPFI: nat,
    /* bool */ zeroForOne_sqrlPriceMathGNSPFI: bool
) : nat
//  (uint160 sqrtQX96) 
{
    do_require(sqrtPX96_sqrlPriceMathGNSPFI > 0, "ERR");
    do_require(liquidity_sqrlPriceMathGNSPFI > 0, "ERR");

    // round to make sure that we don't pass the target price
    const retVal: nat = zeroForOne_sqrlPriceMathGNSPFI
        ? sqrtPriceMathGetNextSqrtPriceFromAmount0RoundingUp(sqrtPX96_sqrlPriceMathGNSPFI, liquidity_sqrlPriceMathGNSPFI, amountIn_sqrlPriceMathGNSPFI, true)
        : sqrtPriceMathGetNextSqrtPriceFromAmount1RoundingDown(sqrtPX96_sqrlPriceMathGNSPFI, liquidity_sqrlPriceMathGNSPFI, amountIn_sqrlPriceMathGNSPFI, true);
    
    return retVal
}

/// @notice Gets the next sqrt price given an output amount of token0 or token1
/// @dev Throws if price or liquidity are 0 or the next price is out of bounds
/// @param sqrtPX96 The starting price before accounting for the output amount
/// @param liquidity The amount of usable liquidity
/// @param amountOut How much of token0, or token1, is being swapped out
/// @param zeroForOne Whether the amount out is token0 or token1
/// @return sqrtQX96 The price after removing the output amount of token0 or token1
function sqrtPriceMathGetNextSqrtPriceFromOutput(
    /* uint160 */ sqrtPX96_sqrlPriceMathGNSPFO: nat,
    /* uint128 */ liquidity_sqrlPriceMathGNSPFO: nat,
    /* uint256 */ amountOut_sqrlPriceMathGNSPFO: nat,
    /* bool */ zeroForOne_sqrlPriceMathGNSPFO: bool
) : nat
//  (uint160 sqrtQX96) 
{
    do_require(sqrtPX96_sqrlPriceMathGNSPFO > 0, "ERR");
    do_require(liquidity_sqrlPriceMathGNSPFO > 0, "ERR");

    // round to make sure that we pass the target price
    const retVal: nat = zeroForOne_sqrlPriceMathGNSPFO
        ? sqrtPriceMathGetNextSqrtPriceFromAmount1RoundingDown(sqrtPX96_sqrlPriceMathGNSPFO, liquidity_sqrlPriceMathGNSPFO, amountOut_sqrlPriceMathGNSPFO, false)
        : sqrtPriceMathGetNextSqrtPriceFromAmount0RoundingUp(sqrtPX96_sqrlPriceMathGNSPFO, liquidity_sqrlPriceMathGNSPFO, amountOut_sqrlPriceMathGNSPFO, false);
    
    return retVal
}

/// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap
/// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive
/// @param sqrtRatioCurrentX96 The current sqrt price of the pool
/// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred
/// @param liquidity The usable liquidity
/// @param amountRemaining How much input or output amount is remaining to be swapped in/out
/// @param feePips The fee taken from the input amount, expressed in hundredths of a bip
/// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target
/// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap
/// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap
/// @return feeAmount The amount of input that will be taken as a fee
function swapMathComputeSwapStep(
    /* uint160 */ sqrtRatioCurrentX96: nat,
    /* uint160 */ sqrtRatioTargetX96: nat,
    /* uint128 */ liquidity_swapMathComputeSwapStep: nat,
    /* int256 */ amountRemaining: int,
    /* uint24 */ feePips: nat
) : nat * nat * nat * nat
    /* sqrtRatioNextX96, */
    /* amountIn, */
    /* amountOut, */
    /* feeAmount */
{
    var zeroForOne: bool = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;
    var exactIn: bool = amountRemaining >= 0;
    var sqrtRatioNextX96: nat = 0;
    var amountIn: nat = 0;
    var amountOut: nat = 0;
    var feeAmount: nat = 0;

    if exactIn then begin
        const amountRemainingLessFee: nat ?= int_to_nat(abs(amountRemaining) * (1_000_000 - feePips) div 1_000_000) : INVALID_NAT;
        amountIn := zeroForOne
            ? sqrtPriceMathGetAmount0Delta_round(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity_swapMathComputeSwapStep, true)
            : sqrtPriceMathGetAmount0Delta_round(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity_swapMathComputeSwapStep, true);
        if (amountRemainingLessFee >= amountIn) then
            sqrtRatioNextX96 := sqrtRatioTargetX96
        else
            sqrtRatioNextX96 := sqrtPriceMathGetNextSqrtPriceFromInput(
                sqrtRatioCurrentX96,
                liquidity_swapMathComputeSwapStep,
                amountRemainingLessFee,
                zeroForOne
            );
    end else begin
        amountOut := zeroForOne
            ? sqrtPriceMathGetAmount1Delta_round(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity_swapMathComputeSwapStep, false)
            : sqrtPriceMathGetAmount0Delta_round(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity_swapMathComputeSwapStep, false);
        if (abs(amountRemaining) >= amountOut) then
            sqrtRatioNextX96 := sqrtRatioTargetX96
        else
            sqrtRatioNextX96 := sqrtPriceMathGetNextSqrtPriceFromOutput(
                sqrtRatioCurrentX96,
                liquidity_swapMathComputeSwapStep,
                abs(amountRemaining),
                zeroForOne
            )
    end;

    const max_Val: bool = (sqrtRatioTargetX96 = sqrtRatioNextX96);

    // get the input/output amounts
    if (zeroForOne) then begin
        amountIn := (max_Val and exactIn)
            ? amountIn
            : sqrtPriceMathGetAmount0Delta_round(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);
        amountOut := (max_Val and (exactIn = false))
            ? amountOut
            : sqrtPriceMathGetAmount1Delta_round(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false)
    end else begin
        amountIn := (max_Val and exactIn)
            ? amountIn
            : sqrtPriceMathGetAmount1Delta_round(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);
        amountOut := (max_Val and (exactIn = false))
            ? amountOut
            : sqrtPriceMathGetAmount0Delta_round(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false)
    end;

    // cap the output amount to not exceed the remaining output amount
    if ((exactIn = false) and (amountOut > abs(amountRemaining))) then
        amountOut := abs(amountRemaining);

    if (exactIn and sqrtRatioNextX96 <> sqrtRatioTargetX96) then
        // we didn't reach the target, so take the remainder of the maximum input as fee
        feeAmount ?:= int_to_nat(abs(amountRemaining) - amountIn) : INVALID_NAT
    else 
        feeAmount := abs(ceil(amountIn * feePips / (1_000_000 - feePips)));

    return ((sqrtRatioNextX96, amountIn, amountOut, feeAmount))
}

/// @inheritdoc IUniswapV3PoolActions
entry swap(
    /* address */ recipient: address,
    /* bool */ zeroForOne: bool,
    /* int256 */ amountSpecified: int,
    /* uint160 */ sqrtPriceLimitX96: nat,
    /* bytes calldata */ data: bytes
) 
// /* external override returns */ : int * int /* (int256 amount0, int256 amount1) */ 
{
    require {swap_c1: noDelegateCall();}

    effect {
        do_require(amountSpecified <> 0, "AS");
        // memory is not storage
        var slot0Start: Slot0 = slot0;
        do_require(slot0Start.unlocked, "LOK");
        do_require(
            zeroForOne
                ? ((sqrtPriceLimitX96 < slot0Start.sqrtPriceX96) and (sqrtPriceLimitX96 > MIN_SQRT_RATIO))
                : ((sqrtPriceLimitX96 > slot0Start.sqrtPriceX96) and (sqrtPriceLimitX96 < MAX_SQRT_RATIO)),
            "SPL"
        );
        slot0.unlocked := false;

        // memory is not storage
        var cache: SwapCache = {
            liquidity;
            blockTimestamp_();
            (zeroForOne ? (slot0Start.feeProtocol % 16) : (slot0Start.feeProtocol |>> 4));
            0;
            0;
            false
        };

        var exactInput = amountSpecified > 0;

        // memory is not storage
        var state_swap_param: SwapState = {
            amountSpecified;
            0;
            slot0Start.sqrtPriceX96;
            slot0Start.tick;
            (zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128);
            0;
            cache.liquidityStart_swapCache
        };

        // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit
        while ((state_swap_param.amountSpecifiedRemaining_swapState <> 0) and (state_swap_param.sqrtPriceX96_swapState <> sqrtPriceLimitX96)) do
            // memory is not storage
            var step: StepComputations = {0; 0; false; 0; 0; 0; 0};

            step.sqrtPriceStartX96_stepComputations := state_swap_param.sqrtPriceX96_swapState;

            const retVal = tickBitmapNextInitializedTickWithinOneWord(
                state_swap_param.tick_swapState,
                tickSpacing,
                zeroForOne
            );

            step.tickNext_stepComputations := retVal[0];
            step.initialized_stepComputations := retVal[1];

            // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds
            if (step.tickNext_stepComputations < MIN_TICK) then
                step.tickNext_stepComputations := MIN_TICK
            else begin
                if (step.tickNext_stepComputations > MAX_TICK) then
                    step.tickNext_stepComputations := MAX_TICK
            end;

            // get the price for the next tick
            step.sqrtPriceNextX96_stepComputations := tickMathGetSqrtRatioAtTick(step.tickNext_stepComputations);

            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted
            const retVal_computeSwapStep = swapMathComputeSwapStep(
                state_swap_param.sqrtPriceX96_swapState,
                (zeroForOne ? step.sqrtPriceNextX96_stepComputations < sqrtPriceLimitX96 : step.sqrtPriceNextX96_stepComputations > sqrtPriceLimitX96)
                    ? sqrtPriceLimitX96
                    : step.sqrtPriceNextX96_stepComputations,
                state_swap_param.liquidity_swapState,
                state_swap_param.amountSpecifiedRemaining_swapState,
                fee
            );
            state_swap_param.sqrtPriceX96_swapState := retVal_computeSwapStep[0];
            step.amountIn_stepComputations := retVal_computeSwapStep[1];
            step.amountOut_stepComputations := retVal_computeSwapStep[2];
            step.feeAmount_stepComputations := retVal_computeSwapStep[3];

            if (exactInput) then begin
                state_swap_param.amountSpecifiedRemaining_swapState -= (step.amountIn_stepComputations + step.feeAmount_stepComputations);
                state_swap_param.amountCalculated_swapState := state_swap_param.amountCalculated_swapState - step.amountOut_stepComputations
            end else begin
                state_swap_param.amountSpecifiedRemaining_swapState += step.amountOut_stepComputations;
                state_swap_param.amountCalculated_swapState := state_swap_param.amountCalculated_swapState + step.amountIn_stepComputations + step.feeAmount_stepComputations
            end;

            // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee
            if (cache.feeProtocol_swapCache > 0) then begin
                const delta: nat = step.feeAmount_stepComputations div cache.feeProtocol_swapCache;
                step.feeAmount_stepComputations -= delta;
                state_swap_param.protocolFee_swapState += delta
            end;

            // update global fee tracker
            if (state_swap_param.liquidity_swapState > 0) then
                state_swap_param.feeGrowthGlobalX128_swapState += (step.feeAmount_stepComputations * Q128 div state_swap_param.liquidity_swapState);

            // shift tick if we reached the next price
            if (state_swap_param.sqrtPriceX96_swapState = step.sqrtPriceNextX96_stepComputations) then begin
                // if the tick is initialized, run the tick transition
                if (step.initialized_stepComputations) then begin
                    // check for the placeholder value, which we replace with the actual value the first time the swap
                    // crosses an initialized tick
                    if (cache.computedLatestObservation_swapCache = false) then begin
                        const retVal_observationsObserveSingle : (int * nat) = observationsObserveSingle(
                            cache.blockTimestamp_swapCache,
                            0,
                            slot0Start.tick,
                            slot0Start.observationIndex,
                            cache.liquidityStart_swapCache,
                            slot0Start.observationCardinality
                        );
                        cache.tickCumulative_swapCache := retVal_observationsObserveSingle[0];
                        cache.secondsPerLiquidityCumulativeX128_swapCache := retVal_observationsObserveSingle[1];
                        cache.computedLatestObservation_swapCache := true;
                    end;

                    // var liquidityNet: int = ticks.cross(
                    //     step.tickNext_stepComputations,
                    //     (zeroForOne ? state_swap_param.feeGrowthGlobalX128_swapState : feeGrowthGlobal0X128),
                    //     (zeroForOne ? feeGrowthGlobal1X128 : state_swap_param.feeGrowthGlobalX128_swapState),
                    //     cache.secondsPerLiquidityCumulativeX128_swapCache,
                    //     cache.tickCumulative_swapCache,
                    //     cache.blockTimestamp_swapCache
                    // );

                    /// @notice Transitions to next tick as needed by price movement
                    /// @param self The mapping containing all tick information for initialized ticks
                    /// @param tick The destination tick of the transition
                    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
                    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
                    /// @param secondsPerLiquidityCumulativeX128 The current seconds per liquidity
                    /// @param tickCumulative The tick * time elapsed since the pool was first initialized
                    /// @param time The current block.timestamp
                    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)
                    // function cross(
                    // mapping(int24 => Tick.Info) storage self,
                    // int24 tick,
                    // uint256 feeGrowthGlobal0X128,
                    // uint256 feeGrowthGlobal1X128,
                    // uint160 secondsPerLiquidityCumulativeX128,
                    // int56 tickCumulative,
                    // uint32 time
                    // ) internal returns (int128 liquidityNet) {
                    const tick_param: int = step.tickNext_stepComputations;
                    const feeGrowthGlobal0X128_param: nat = (zeroForOne ? state_swap_param.feeGrowthGlobalX128_swapState : feeGrowthGlobal0X128);
                    const feeGrowthGlobal1X128_param: nat = (zeroForOne ? feeGrowthGlobal1X128 : state_swap_param.feeGrowthGlobalX128_swapState);
                    const secondsPerLiquidityCumulativeX128_param: nat = cache.secondsPerLiquidityCumulativeX128_swapCache;
                    const tickCumulative_param: int = cache.tickCumulative_swapCache;
                    const time_param: nat = cache.blockTimestamp_swapCache;

                    const feeGrowthOutside0X128_param ?= int_to_nat(feeGrowthGlobal0X128_param - ticks[tick_param].info.feeGrowthOutside0X128) : INVALID_NAT;
                    const feeGrowthOutside1X128_param ?= int_to_nat(feeGrowthGlobal1X128_param - ticks[tick_param].info.feeGrowthOutside1X128) : INVALID_NAT;
                    const secondsPerLiquidityOutsideX128_param ?= int_to_nat(secondsPerLiquidityCumulativeX128_param - ticks[tick_param].info.secondsPerLiquidityOutsideX128) : INVALID_NAT;
                    const tickCumulativeOutside_param = tickCumulative_param - ticks[tick_param].info.tickCumulativeOutside;
                    const secondsOutside_param ?= int_to_nat(time_param - ticks[tick_param].info.secondsOutside) : INVALID_NAT;

                    ticks[tick_param].info := {
                        ticks[tick_param].info with 
                        feeGrowthOutside0X128 = feeGrowthOutside0X128_param;
                        feeGrowthOutside1X128 = feeGrowthOutside1X128_param;
                        secondsPerLiquidityOutsideX128 = secondsPerLiquidityOutsideX128_param;
                        tickCumulativeOutside = tickCumulativeOutside_param;
                        secondsOutside = secondsOutside_param
                    };
                    
                    var liquidityNet_param: int = ticks[tick_param].info.liquidityNet;
                    // }

                    // if we're moving leftward, we interpret liquidityNet as the opposite sign
                    // safe because liquidityNet cannot be type(int128).min
                    if (zeroForOne) then
                        liquidityNet_param := -liquidityNet_param;

                    state_swap_param.liquidity_swapState ?:= int_to_nat(state_swap_param.liquidity_swapState + liquidityNet_param) : INVALID_NAT
                end;

                state_swap_param.tick_swapState := zeroForOne ? (step.tickNext_stepComputations - 1) : step.tickNext_stepComputations
            end else begin 
                if (state_swap_param.sqrtPriceX96_swapState <> step.sqrtPriceStartX96_stepComputations) then
                    // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved
                    state_swap_param.tick_swapState := tickMathGetTickAtSqrtRatio(state_swap_param.sqrtPriceX96_swapState)
            end
        done;
        // update tick and write an oracle entry if the tick change
        if (state_swap_param.tick_swapState <> slot0Start.tick) then begin
            var observationIndex_param: nat = 0;
            var observationCardinality_param: nat = 0;
            // (uint16 observationIndex, uint16 observationCardinality) = observations.write(
            //     slot0Start.observationIndex,
            //     cache.blockTimestamp_swapCache,
            //     slot0Start.tick,
            //     cache.liquidityStart_swapCache,
            //     slot0Start.observationCardinality,
            //     slot0Start.observationCardinalityNext
            // );
            /// @notice Writes an oracle observation to the array
            /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.
            /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality
            /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.
            /// @param self The stored oracle array
            /// @param index The index of the observation that was most recently written to the observations array
            /// @param blockTimestamp The timestamp of the new observation
            /// @param tick The active tick at the time of the new observation
            /// @param liquidity The total in-range liquidity at the time of the new observation
            /// @param cardinality The number of populated elements in the oracle array
            /// @param cardinalityNext The new length of the oracle array, independent of population
            /// @return indexUpdated The new index of the most recently written element in the oracle array
            /// @return cardinalityUpdated The new cardinality of the oracle array
            // function write(
            //     Observation[65535] storage self,
            //     uint16 slot0Start.observationIndex,
            //     uint32 cache.blockTimestamp_swapCache,
            //     int24 slot0Start.tick,
            //     uint128 cache.liquidityStart_swapCache,
            //     uint16 slot0Start.observationCardinality,
            //     uint16 slot0Start.observationCardinalityNext
            // ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {
            const last = observations[slot0Start.observationIndex].observation_value;

            // early return if we've already written an observation this block
            if (last.blockTimestamp_Obs = cache.blockTimestamp_swapCache) then begin
                observationIndex_param := slot0Start.observationIndex;
                observationCardinality_param := slot0Start.observationCardinality
            end else begin
                var indexUpdated = 0;
                var cardinalityUpdated = 0;
                // if the conditions are right, we can bump the cardinality
                if ((slot0Start.observationCardinalityNext > slot0Start.observationCardinality) and (slot0Start.observationIndex = (slot0Start.observationCardinality - 1))) then 
                    cardinalityUpdated := slot0Start.observationCardinalityNext
                else
                    cardinalityUpdated := slot0Start.observationCardinality;

                indexUpdated := (slot0Start.observationIndex + 1) % cardinalityUpdated;
                observations[indexUpdated].observation_value := transform(last, cache.blockTimestamp_swapCache, slot0Start.tick, cache.liquidityStart_swapCache);
                // } // end function write
                observationIndex_param := indexUpdated;
                observationCardinality_param := cardinalityUpdated;
            end;
            slot0.sqrtPriceX96 := state_swap_param.sqrtPriceX96_swapState;
            slot0.tick := state_swap_param.tick_swapState;
            slot0.observationIndex := observationIndex_param;
            slot0.observationCardinality := observationCardinality_param
        end else
            // otherwise just update the price
            slot0.sqrtPriceX96 := state_swap_param.sqrtPriceX96_swapState;

        // update liquidity if it changed
        if (cache.liquidityStart_swapCache <> state_swap_param.liquidity_swapState) then
            liquidity := state_swap_param.liquidity_swapState;

        // update fee growth global and, if necessary, protocol fees
        // overflow is acceptable, protocol has to withdraw before it hits type(uint128).max fees
        if zeroForOne then begin
            feeGrowthGlobal0X128 := state_swap_param.feeGrowthGlobalX128_swapState;
            if (state_swap_param.protocolFee_swapState > 0) then 
                protocolFees.token0_fees += state_swap_param.protocolFee_swapState
        end else begin
            feeGrowthGlobal1X128 := state_swap_param.feeGrowthGlobalX128_swapState;
            if (state_swap_param.protocolFee_swapState > 0) then 
                protocolFees.token1_fees += state_swap_param.protocolFee_swapState
        end;

        const amount0: int = (zeroForOne = exactInput)
            ? (amountSpecified - state_swap_param.amountSpecifiedRemaining_swapState)
            : state_swap_param.amountCalculated_swapState;
        const amount1: int = (zeroForOne = exactInput)
            ? state_swap_param.amountCalculated_swapState
            : (amountSpecified - state_swap_param.amountSpecifiedRemaining_swapState);

        // TODO + please check amount amd amount_min slippage check
    
        // do the transfers and collect payment
        if zeroForOne then begin
            if (amount1 < 0) then begin
                // TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));
                balance1 ?:= int_to_nat(balance1 - abs(amount1)) : INVALID_NAT;
                transfer 0tz to token1 call %transfer<address * address * nat>((self_address, recipient, abs(amount1)))
            end;

            // uint256 balance0Before = balance0();
            var data_: SwapCallbackData ?= unpack<SwapCallbackData>(data) : INVALID_UNPACK;
            const amount0_nat ?= int_to_nat(amount0) : INVALID_NAT;
            balance0 ?:= int_to_nat(balance0 + amount0) : INVALID_NAT;
            transfer 0tz to token0 call %transfer<address * address * nat>((data_.payer_SwapCallbackData, self_address, amount0_nat));
            // should be remove token transfer part
            // IUniswapV3SwapCallback(caller).uniswapV3SwapCallback(amount0, amount1, data);
            transfer 0tz to caller call uniswapV3SwapCallback<int * int * bytes>((amount0, amount1, data))
            
            // do_require(balance0Before.add(uint256(amount0)) <= balance0(), "IIA");
        end else begin
            if (amount0 < 0) then begin
                // TransferHelper.safeTransfer(token0, recipient, uint256(-amount0));
                balance0 ?:= int_to_nat(balance0 - abs(amount0)) : INVALID_NAT;
                transfer 0tz to token0 call %transfer<address * address * nat>((self_address, recipient, abs(amount0)))
            end;

            // uint256 balance1Before = balance1();
            var data_: SwapCallbackData ?= unpack<SwapCallbackData>(data) : INVALID_UNPACK;
            const amount1_nat ?= int_to_nat(amount1) : INVALID_NAT;
            balance0 ?:= int_to_nat(balance0 + amount1) : INVALID_NAT;
            transfer 0tz to token1 call %transfer<address * address * nat>((data_.payer_SwapCallbackData, self_address, amount1_nat));
            // should be remove token transfer part
            // IUniswapV3SwapCallback(caller).uniswapV3SwapCallback(amount0, amount1, data);
            transfer 0tz to caller call uniswapV3SwapCallback<int * int * bytes>((amount0, amount1, data))
            
            // do_require(balance1Before.add(uint256(amount1)) <= balance1(), "IIA");
        end;

        emit<Swap>({caller; recipient; amount0; amount1; state_swap_param.sqrtPriceX96_swapState; state_swap_param.liquidity_swapState; state_swap_param.tick_swapState});
        slot0.unlocked := true;
    }
}

/// @inheritdoc IUniswapV3PoolActions
// entry flash(
//     /* address */ recipient: address,
//     /* uint256 */ amount0: nat,
//     /* uint256 */ amount1: nat,
//     /* bytes calldata */ data: bytes
// ) /* external override */ {
//     require {flash_c1: noDelegateCall();}

//     effect {
//         do_require(slot0.unlocked, ("LOK", slot0.unlocked));
//         slot0.unlocked := false;
        
//         var liquidity_: nat = liquidity;
//         do_require(liquidity_ > 0, "L");

//         const fee0_param: nat /* uint256 */  = abs(ceil(amount0 * fee / 1_000_000));
//         const fee1_param: nat /* uint256 */  = abs(ceil(amount1 * fee / 1_000_000));
//         // const balance0Before_param: nat /* uint256 */  = balance0;
//         // const balance1Before_param: nat /* uint256 */  = balance1;

//         if (amount0 > 0) then begin
//             // TransferHelper.safeTransfer(token0, recipient, amount0);
//             transfer 0tz to token0 call %transfer<address * address * nat>((self_address, recipient, amount0))
//         end;
//         if (amount1 > 0) then begin
//             // TransferHelper.safeTransfer(token1, recipient, amount1);
//             transfer 0tz to token1 call %transfer<address * address * nat>((self_address, recipient, amount1));
//         end;

//         // IUniswapV3FlashCallback(caller).uniswapV3FlashCallback(fee0, fee1, data);

//         // uint256 balance0After = balance0();
//         // uint256 balance1After = balance1();

//         // require(balance0Before.add(fee0) <= balance0After, 'F0');
//         // require(balance1Before.add(fee1) <= balance1After, 'F1');

//         // // sub is safe because we know balanceAfter is gt balanceBefore by at least fee
//         // uint256 paid0 = balance0After - balance0Before;
//         // uint256 paid1 = balance1After - balance1Before;

//         // if (paid0 > 0) {
//         //     uint8 feeProtocol0 = slot0.feeProtocol % 16;
//         //     uint256 fees0 = feeProtocol0 = 0 ? 0 : paid0 / feeProtocol0;
//         //     if (uint128(fees0) > 0) protocolFees.token0 += uint128(fees0);
//         //     feeGrowthGlobal0X128 += FullMath.mulDiv(paid0 - fees0, FixedPoint128.Q128, liquidity_);
//         // }
//         // if (paid1 > 0) {
//         //     uint8 feeProtocol1 = slot0.feeProtocol >> 4;
//         //     uint256 fees1 = feeProtocol1 = 0 ? 0 : paid1 / feeProtocol1;
//         //     if (uint128(fees1) > 0) protocolFees.token1 += uint128(fees1);
//         //     feeGrowthGlobal1X128 += FullMath.mulDiv(paid1 - fees1, FixedPoint128.Q128, liquidity_);
//         // }

//         // emit<Flash>({caller; recipient; amount0; amount1; paid0; paid1});
//         slot0.unlocked := true
//     }
// }

/// @inheritdoc IUniswapV3PoolOwnerActions
entry setFeeProtocol(feeProtocol0: nat, feeProtocol1: nat) /* external override */ {
    do_require(slot0.unlocked, ("LOK", slot0.unlocked));
    slot0.unlocked := false;
    do_require(onlyFactoryOwner(), "ERR");
    do_require((feeProtocol0 = 0 or (feeProtocol0 >= 4 and feeProtocol0 <= 10)) and (feeProtocol1 = 0 or (feeProtocol1 >= 4 and feeProtocol1 <= 10)), "ERR");
    const feeProtocolOld = slot0.feeProtocol;
    slot0.feeProtocol := feeProtocol0 + (feeProtocol1 <<| 4);
    emit<SetFeeProtocol>({(feeProtocolOld % 16); (feeProtocolOld |>> 4); feeProtocol0; feeProtocol1});
    slot0.unlocked := true
}

/// @inheritdoc IUniswapV3PoolOwnerActions
entry collectProtocol(
    /* address */ recipient: address,
    /* uint128 */ amount0Requested: nat,
    /* uint128 */ amount1Requested: nat
) 
// /* external override returns (uint128 amount0, uint128 amount1) */ : (nat * nat) 
{
    do_require(slot0.unlocked, ("LOK", slot0.unlocked));
    slot0.unlocked := false;
    do_require(onlyFactoryOwner(), "ERR");
    var amount0 = amount0Requested > protocolFees.token0_fees ? protocolFees.token0_fees : amount0Requested;
    var amount1 = amount1Requested > protocolFees.token1_fees ? protocolFees.token1_fees : amount1Requested;

    if (amount0 > 0) then begin
        if (amount0 = protocolFees.token0_fees) then
            amount0 -= 1; // ensure that the slot is not cleared, for gas savings
        protocolFees.token0_fees -= amount0;
        balance0 -= amount0;
        transfer 0tz to token0 call %transfer<address * address * nat>((self_address, recipient, amount0));
    end;
    if (amount1 > 0) then begin
        if (amount1 = protocolFees.token1_fees) then 
            amount1 -= 1; // ensure that the slot is not cleared, for gas savings
        protocolFees.token1_fees -= amount1;
        balance1 -= amount1;
        transfer 0tz to token1 call %transfer<address * address * nat>((self_address, recipient, amount1));
    end;

    emit<CollectProtocol>({caller; recipient; amount0; amount1});
    slot0.unlocked := true
}
