archetype uniswapV3Pool(factory: address, token0: address, token1: address)

// import LowGasSafeMath from "./libraries/LowGasSafeMath.tz"
// import SafeCast from "./libraries/SafeCast.tz"
// import Tick from "./libraries/Tick.tz"
// import TickBitmap from "./libraries/TickBitmap.tz"
// import Position from "./libraries/Position.tz"
// import Oracle from "./libraries/Oracle.tz"
// import FullMath from "./libraries/FullMath.tz"
// import FixedPoint128 from "./libraries/FixedPoint128.tz"
// import TransferHelper from "./libraries/TransferHelper.tz"
// import TickMath from "./libraries/TickMath.tz"
// import LiquidityMath from "./libraries/LiquidityMath.tz"
// import SqrtPriceMath from "./libraries/SqrtPriceMath.tz"
// import SwapMath from "./libraries/SwapMath.tz"
// import IUniswapV3PoolDeployer from "./interfaces/IUniswapV3PoolDeployer.tz"
// import IUniswapV3Factory from "./interfaces/IUniswapV3Factory.tz"
// import IERC20Minimal from "./interfaces/IERC20Minimal.tz"
// import IUniswapV3MintCallback from "./interfaces/callback/IUniswapV3MintCallback.tz"
// import IUniswapV3SwapCallback from "./interfaces/callback/IUniswapV3SwapCallback.tz"
// import IUniswapV3FlashCallback from "./interfaces/callback/IUniswapV3FlashCallback.tz"

constant INVALID_NAT             : string = "INVALID_NAT"
constant INVALID_INT_NAT         : string = "INVALID_INT_NAT"
constant INVALID_UNPACK          : string = "INVALID_UNPACK"

constant TickMathMIN_TICK: int = -887272
constant TickMathMAX_TICK: int = -TickMathMIN_TICK
constant MAX_HISTORY: nat = 65536
constant RESOLUTION: nat = 96
constant Q96: nat = 1 <<| 96
constant Q128: nat = 1 <<| 128
constant Q256: nat = 1 <<| 256
constant UnixStartTime: date = 1970-01-01
constant original: address = self_address

record PoolKey {
    token0_poolKey: address;
    token1_poolKey: address;
    fee_poolKey: nat
} as (((token0, token1), fee))

record MintCallbackData {
    poolKey: PoolKey;
    payer: address; 
}

function noDelegateCall() : bool {
    do_fail_if(self_address <> original, ("DelegateCall", original));
    return true
}

variable fee: nat = 0
variable tickSpacing: int = 0
variable maxLiquidityPerTick: nat = 0

variable balance0: nat = 0
variable balance1: nat = 0

// using LowGasSafeMath for uint256;
// using LowGasSafeMath for int256;
// using SafeCast for uint256;
// using SafeCast for int256;
// using Tick for mapping(int24 => Tick.Info);
// using TickBitmap for mapping(int16 => uint256);
// using Position for mapping(bytes32 => Position.Info);
// using Position for Position.Info;
// using Oracle for Oracle.Observation[65535];

/// @inheritdoc IUniswapV3PoolState
record Slot0 {
    // the current price
    sqrtPriceX96: nat;
    // the current tick
    tick: int;
    // the most-recently updated index of the observations array
    observationIndex: nat;
    // the current maximum number of observations that are being stored
    observationCardinality: nat;
    // the next maximum number of observations to store, triggered in observations.write
    observationCardinalityNext: nat;
    // the current protocol fee as a percentage of the swap fee taken on withdrawal
    // represented as an integer denominator (1/x)%
    feeProtocol: nat;
    // whether the pool is locked
    unlocked: bool;
}

variable slot0: Slot0 = {
    sqrtPriceX96                = 0;
    tick                        = 0;
    observationIndex            = 0;
    observationCardinality      = 0;
    observationCardinalityNext  = 0;
    feeProtocol                 = 0;
    unlocked                    = false
}

/// @inheritdoc IUniswapV3PoolState
variable feeGrowthGlobal0X128 : nat = 0
/// @inheritdoc IUniswapV3PoolState
variable feeGrowthGlobal1X128 : nat = 0

// accumulated protocol fees in token0/token1 units
record ProtocolFees {
    token0_fees: nat;
    token1_fees: nat;
} as ((token0, token1))
/// @inheritdoc IUniswapV3PoolState
variable protocolFees: ProtocolFees = {
    token0_fees = 0;
    token1_fees = 0
}

/// @inheritdoc IUniswapV3PoolState
variable liquidity : nat = 0

// info stored for each initialized individual tick
record TickInfo {
    // the total position liquidity that references this tick
    liquidityGross: nat;
    // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),
    liquidityNet: int;
    // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    feeGrowthOutside0X128: nat;
    feeGrowthOutside1X128: nat;
    // the cumulative tick value on the other side of the tick
    tickCumulativeOutside: int;
    // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    secondsPerLiquidityOutsideX128: nat;
    // the seconds spent on the other side of the tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    secondsOutside: nat;
    // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0
    // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks
    %initialized: bool;
}

/// @inheritdoc IUniswapV3PoolState
asset ticks identified by tickId to big_map {
    tickId: int;
    info: TickInfo;
}
/// @inheritdoc IUniswapV3PoolState
asset tickBitmap identified by tick_tickBmp to big_map {
    tick_tickBmp : int;
    tickSpacing_tickBmp: nat = 0;
}
record PositionInfo {
    // the amount of liquidity owned by this position
    liquidity_PosInfo: nat;
    // fee growth per unit of liquidity as of the last update to liquidity or fees owed
    feeGrowthInside0LastX128_PosInfo: nat;
    feeGrowthInside1LastX128_PosInfo: nat;
    // the fees owed to the position owner in token0/token1
    tokensOwed0_PosInfo: nat;
    tokensOwed1_PosInfo: nat;
} as ((liquidity, (feeGrowthInside0LastX128, feeGrowthInside1LastX128), (tokensOwed0, tokensOwed1)))
/// @inheritdoc IUniswapV3PoolState
asset positions identified by positionId_owner positionId_tickLower positionId_tickUpper to big_map {
    positionId_owner: address;
    positionId_tickLower: int;
    positionId_tickUpper: int;
    positionInfo: PositionInfo;
}
record Observation {
    // the block timestamp of the observation
    blockTimestamp_Obs: nat;
    // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized
    tickCumulative_Obs: int;
    // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized
    secondsPerLiquidityCumulativeX128_Obs: nat;
    // whether or not the observation is initialized
    initialized_Obs: bool;
} as ((blockTimestamp, (tickCumulative, secondsPerLiquidityCumulativeX128, %initialized)))
/// @inheritdoc IUniswapV3PoolState
// Oracle.Observation[65535] public override observations;
asset observations identified by observation_key to big_map {
    observation_key: nat;
    observation_value: Observation;
}

/// @dev Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance
/// to a function before the pool is initialized. The reentrancy guard is required throughout the contract because
/// we use balance checks to determine the payment status of interactions such as mint, swap and flash.
// function lock() {
//     // do_require(slot0.unlocked, ("LOK", slot0.unlocked));
//     // slot0.unlocked := false;
//     // _;
//     // slot0.unlocked := true;
// }

/// @dev Prevents calling a function from anyone except the address returned by IUniswapV3Factory#owner()
function onlyFactoryOwner(): bool {
    const factoryOwner ?= call_view<address>(factory, "getOwner", Unit) : "VIEW_OWNER_ERR";
    do_require(caller = factoryOwner, "ONLY_FACTORY_OWNER_ERR");
    return true
}

/// @dev Common checks for valid tick inputs.
function checkTicks(tickLower: int, tickUpper: int): bool {
    do_require(tickLower < tickUpper, "TLU");
    do_require(tickLower >= TickMathMIN_TICK, "TLM");
    do_require(tickUpper <= TickMathMAX_TICK, "TUM");
    return true
}

/// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.
view blockTimestamp_(): nat {
    const timestamp ?= int_to_nat((now - UnixStartTime) div 1s) : INVALID_NAT;
    return timestamp
    // return uint32(block.timestamp); // truncation is desired
}

/// @dev Get the pool's balance of token0
/// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
/// check
// view balance0() /* private view returns */ : nat {
//     // (bool success, bytes memory data) = token0.staticcall(
//     //     abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this))
//     // );
//     // require(success && data.length >= 32);
//     // return abi.decode(data, (uint256));
//     return 0
// }

// /// @dev Get the pool's balance of token1
// /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
// /// check
// view balance1() /* private view returns */ : nat {
//     // (bool success, bytes memory data) = token1.staticcall(
//     //     abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this))
//     // );
//     // require(success && data.length >= 32);
//     // return abi.decode(data, (uint256));
//     return 0
// }

/// @inheritdoc IUniswapV3PoolDerivedState
// view snapshotCumulativesInside(tickLower: int, tickUpper: int): (
//         /* tickCumulativeInside: */ int *
//         /* secondsPerLiquidityInsideX128: */ nat *
//         /* secondsInside: */ nat
// )
// {
//     var retVal: (int * nat * nat) = (0,0,0);
//     if noDelegateCall() = false then
//         return retVal
//     // return (0,0,0)
//     // if checkTicks(tickLower, tickUpper) = false then
//     //     return (0,0,0)

//     // tickCumulativeLower: int;
//     // tickCumulativeUpper: int;
//     // secondsPerLiquidityOutsideLowerX128: nat;
//     // secondsPerLiquidityOutsideUpperX128: nat;
//     // secondsOutsideLower: nat;
//     // secondsOutsideUpper: nat;

//     // {
//     //     var lower: TickInfo = ticks[tickLower];
//     //     var upper: TickInfo = ticks[tickUpper];
//     //     bool initializedLower;
//     //     (tickCumulativeLower, secondsPerLiquidityOutsideLowerX128, secondsOutsideLower, initializedLower) = (
//     //         lower.tickCumulativeOutside,
//     //         lower.secondsPerLiquidityOutsideX128,
//     //         lower.secondsOutside,
//     //         lower.initialized
//     //     );
//     //     require(initializedLower);

//     //     bool initializedUpper;
//     //     (tickCumulativeUpper, secondsPerLiquidityOutsideUpperX128, secondsOutsideUpper, initializedUpper) = (
//     //         upper.tickCumulativeOutside,
//     //         upper.secondsPerLiquidityOutsideX128,
//     //         upper.secondsOutside,
//     //         upper.initialized
//     //     );
//     //     require(initializedUpper);
//     // }

//     // Slot0 memory _slot0 = slot0;

//     // if (_slot0.tick < tickLower) {
//     //     return (
//     //         tickCumulativeLower - tickCumulativeUpper,
//     //         secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128,
//     //         secondsOutsideLower - secondsOutsideUpper
//     //     );
//     // } else if (_slot0.tick < tickUpper) {
//     //     uint32 time = blockTimestamp_();
//     //     (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(
//     //         time,
//     //         0,
//     //         _slot0.tick,
//     //         _slot0.observationIndex,
//     //         liquidity,
//     //         _slot0.observationCardinality
//     //     );
//     //     return (
//     //         tickCumulative - tickCumulativeLower - tickCumulativeUpper,
//     //         secondsPerLiquidityCumulativeX128 -
//     //             secondsPerLiquidityOutsideLowerX128 -
//     //             secondsPerLiquidityOutsideUpperX128,
//     //         time - secondsOutsideLower - secondsOutsideUpper
//     //     );
//     // } else {
//     //     return (
//     //         tickCumulativeUpper - tickCumulativeLower,
//     //         secondsPerLiquidityOutsideUpperX128 - secondsPerLiquidityOutsideLowerX128,
//     //         secondsOutsideUpper - secondsOutsideLower
//     //     );
//     // }
// }

// /// @inheritdoc IUniswapV3PoolDerivedState
// view observe(uint32[] calldata secondsAgos)
//     /* external
//     view
//     override
//     returns */ : {int[] /* int56[] memory tickCumulatives */, nat[] /* uint160[] memory secondsPerLiquidityCumulativeX128s */}
// {
//     require {observe: noDelegateCall();}
//     // return
//     //     observations.observe(
//     //         blockTimestamp_(),
//     //         secondsAgos,
//     //         slot0.tick,
//     //         slot0.observationIndex,
//     //         liquidity,
//     //         slot0.observationCardinality
//     //     );
// }

// /// @inheritdoc IUniswapV3PoolActions
// entry increaseObservationCardinalityNext(observationCardinalityNext: nat)
//     // external
//     // override
// {
//     do_require(slot0.unlocked, ("LOK", slot0.unlocked));
//     slot0.unlocked := false;
//     require {increaseObservationCardinalityNext: noDelegateCall();}
//     // uint16 observationCardinalityNextOld = slot0.observationCardinalityNext; // for the event
//     // uint16 observationCardinalityNextNew = observations.grow(
//     //     observationCardinalityNextOld,
//     //     observationCardinalityNext
//     // );
//     // slot0.observationCardinalityNext = observationCardinalityNextNew;
//     // if (observationCardinalityNextOld != observationCardinalityNextNew)
//     //     emit IncreaseObservationCardinalityNext(observationCardinalityNextOld, observationCardinalityNextNew);
//     slot0.unlocked := true;
// }

// // /// @inheritdoc IUniswapV3PoolActions
// // /// @dev not locked because it initializes unlocked
// // entry initialize(sqrtPriceX96: nat) /* external override */ {
// //     // require(slot0.sqrtPriceX96 == 0, 'AI');

// //     // int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);

// //     // (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(blockTimestamp_());

// //     // slot0 = Slot0({
// //     //     sqrtPriceX96: sqrtPriceX96,
// //     //     tick: tick,
// //     //     observationIndex: 0,
// //     //     observationCardinality: cardinality,
// //     //     observationCardinalityNext: cardinalityNext,
// //     //     feeProtocol: 0,
// //     //     unlocked: true
// //     // });

// //     // emit Initialize(sqrtPriceX96, tick);
// // }

record ModifyPositionParams {
    // the address that owns the position
    owner_ModifyPosParam: address;
    // the lower and upper tick of the position
    tickLower_ModifyPosParam: int;
    tickUpper_ModifyPosParam: int;
    // any change in liquidity
    liquidityDelta_ModifyPosParam: int;
} as ((owner, tickLower, tickUpper, liquidityDelta))

/// @dev Effect some changes to a position
/// @param params the position details and the change to the position's liquidity to effect
/// @return position a storage pointer referencing the position with the given owner and tick range
/// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient
/// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient
// getter _modifyPosition(params: ModifyPositionParams)
//     // private
//     : {
//         PositionInfo, /* Position.Info storage position */,
//         nat, /* int256 amount0 */,
//         nat, /* int256 amount1 */
//     }
// {
//     require {_modifyPosition1: noDelegateCall();}
//     require {_modifyPosition2: checkTicks(params.tickLower, params.tickUpper);}

//     // Slot0 memory _slot0 = slot0; // SLOAD for gas optimization

//     // position = _updatePosition(
//     //     params.owner,
//     //     params.tickLower,
//     //     params.tickUpper,
//     //     params.liquidityDelta,
//     //     _slot0.tick
//     // );

//     // if (params.liquidityDelta != 0) {
//     //     if (_slot0.tick < params.tickLower) {
//     //         // current tick is below the passed range; liquidity can only become in range by crossing from left to
//     //         // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it
//     //         amount0 = SqrtPriceMath.getAmount0Delta(
//     //             TickMath.getSqrtRatioAtTick(params.tickLower),
//     //             TickMath.getSqrtRatioAtTick(params.tickUpper),
//     //             params.liquidityDelta
//     //         );
//     //     } else if (_slot0.tick < params.tickUpper) {
//     //         // current tick is inside the passed range
//     //         uint128 liquidityBefore = liquidity; // SLOAD for gas optimization

//     //         // write an oracle entry
//     //         (slot0.observationIndex, slot0.observationCardinality) = observations.write(
//     //             _slot0.observationIndex,
//     //             blockTimestamp_(),
//     //             _slot0.tick,
//     //             liquidityBefore,
//     //             _slot0.observationCardinality,
//     //             _slot0.observationCardinalityNext
//     //         );

//     //         amount0 = SqrtPriceMath.getAmount0Delta(
//     //             _slot0.sqrtPriceX96,
//     //             TickMath.getSqrtRatioAtTick(params.tickUpper),
//     //             params.liquidityDelta
//     //         );
//     //         amount1 = SqrtPriceMath.getAmount1Delta(
//     //             TickMath.getSqrtRatioAtTick(params.tickLower),
//     //             _slot0.sqrtPriceX96,
//     //             params.liquidityDelta
//     //         );

//     //         liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);
//     //     } else {
//     //         // current tick is above the passed range; liquidity can only become in range by crossing from right to
//     //         // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it
//     //         amount1 = SqrtPriceMath.getAmount1Delta(
//     //             TickMath.getSqrtRatioAtTick(params.tickLower),
//     //             TickMath.getSqrtRatioAtTick(params.tickUpper),
//     //             params.liquidityDelta
//     //         );
//     //     }
//     // }
// }

/// @dev Gets and updates a position with the given liquidity delta
/// @param owner the owner of the position
/// @param tickLower the lower tick of the position's tick range
/// @param tickUpper the upper tick of the position's tick range
/// @param tick the current tick, passed to avoid sloads
// getter _updatePosition(
//     owner: address,
//     tickLower: int,
//     tickUpper: int,
//     liquidityDelta: int,
//     tick: int
// ) /* private returns */ : PositionInfo /* storage position */ {
//     // position = positions.get(owner, tickLower, tickUpper);

//     // uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128; // SLOAD for gas optimization
//     // uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128; // SLOAD for gas optimization

//     // // if we need to update the ticks, do it
//     // bool flippedLower;
//     // bool flippedUpper;
//     // if (liquidityDelta != 0) {
//     //     uint32 time = blockTimestamp_();
//     //     (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(
//     //         time,
//     //         0,
//     //         slot0.tick,
//     //         slot0.observationIndex,
//     //         liquidity,
//     //         slot0.observationCardinality
//     //     );

//     //     flippedLower = ticks.update(
//     //         tickLower,
//     //         tick,
//     //         liquidityDelta,
//     //         _feeGrowthGlobal0X128,
//     //         _feeGrowthGlobal1X128,
//     //         secondsPerLiquidityCumulativeX128,
//     //         tickCumulative,
//     //         time,
//     //         false,
//     //         maxLiquidityPerTick
//     //     );
//     //     flippedUpper = ticks.update(
//     //         tickUpper,
//     //         tick,
//     //         liquidityDelta,
//     //         _feeGrowthGlobal0X128,
//     //         _feeGrowthGlobal1X128,
//     //         secondsPerLiquidityCumulativeX128,
//     //         tickCumulative,
//     //         time,
//     //         true,
//     //         maxLiquidityPerTick
//     //     );

//     //     if (flippedLower) {
//     //         tickBitmap.flipTick(tickLower, tickSpacing);
//     //     }
//     //     if (flippedUpper) {
//     //         tickBitmap.flipTick(tickUpper, tickSpacing);
//     //     }
//     // }

//     // (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = ticks.getFeeGrowthInside(
//     //     tickLower,
//     //     tickUpper,
//     //     tick,
//     //     _feeGrowthGlobal0X128,
//     //     _feeGrowthGlobal1X128
//     // );

//     // position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);

//     // // clear any tick data that is no longer needed
//     // if (liquidityDelta < 0) {
//     //     if (flippedLower) {
//     //         ticks.clear(tickLower);
//     //     }
//     //     if (flippedUpper) {
//     //         ticks.clear(tickUpper);
//     //     }
//     // }
// }

event Mint {
    sender_mint_event: address;
    owner_mint_event: address;
    tickLower_mint_event: int;
    tickUpper_mint_event: int;
    amount_mint_event: nat;
    amount0_mint_event: nat;
    amount1_mint_event: nat;
}

event Burn{
    owner_burn_event: address;
    tickLower_burn_event: int;
    tickUpper_burn_event: int;
    amount_burn_event: nat;
    amount0_burn_event: nat;
    amount1_burn_event: nat;
}

/// @notice comparator for 32-bit timestamps
/// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time
/// @param time A timestamp truncated to 32 bits
/// @param a A comparison timestamp from which to determine the relative position of `time`
/// @param b From which to determine the relative position of `time`
/// @return bool Whether `a` is chronologically <= `b`
function lte(
    time: nat,
    a: nat,
    b: nat
) : bool {
    var retVal = false;
    // if there hasn't been overflow, no need to adjust
    if (a <= time and b <= time) then begin
        retVal := a <= b;
        return retVal
    end;

    const aAdjusted = a > time ? a : a + 1 <<| 32;
    const bAdjusted = b > time ? b : b + 1 <<| 32;

    retVal := aAdjusted <= bAdjusted;
    return retVal
}

/// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.
/// The result may be the same observation, or adjacent observations.
/// @dev The answer must be contained in the array, used when the target is located within the stored observation
/// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation
/// @param self The stored oracle array
/// @param time The current block.timestamp
/// @param target The timestamp at which the reserved observation should be for
/// @param index The index of the observation that was most recently written to the observations array
/// @param cardinality The number of populated elements in the oracle array
/// @return beforeOrAt The observation recorded before, or at, the target
/// @return atOrAfter The observation recorded at, or after, the target
function binarySearch(
    time_binarySearch: nat,
    target_binarySearch: nat,
    index_binarySearch: nat,
    cardinality_binarySearch: nat
) : Observation * Observation {
    var l = (index_binarySearch + 1) % cardinality_binarySearch; // oldest observation
    var r = l + cardinality_binarySearch - 1; // newest observation
    var beforeOrAt: Observation = {0; 0; 0; false};
    var atOrAfter: Observation = {0; 0; 0; false};
    var i = 0;
    while true do 
        i ?:= int_to_nat((l + r) div 2) : INVALID_NAT;

        beforeOrAt := observations[i % cardinality_binarySearch].observation_value;

        // we've landed on an uninitialized tick, keep searching higher (more recently)
        if (beforeOrAt.initialized_Obs = false) then
            l := i + 1
        else begin
            atOrAfter := observations[(i + 1) % cardinality_binarySearch].observation_value;

            var targetAtOrAfter = lte(time_binarySearch, beforeOrAt.blockTimestamp_Obs, target_binarySearch);

            // check if we've found the answer!
            if (targetAtOrAfter and lte(time_binarySearch, target_binarySearch, atOrAfter.blockTimestamp_Obs)) then
                return ((beforeOrAt, atOrAfter));

            if (targetAtOrAfter = false) then r := i - 1
            else l := i + 1
        end;
    done
}

function transform(
    last_transform_param: Observation,
    blockTimestamp_transform_param: nat,
    tick_transform_param: int,
    liquidity_transform_param: nat
) : Observation {
    const delta ?= int_to_nat(blockTimestamp_transform_param - last_transform_param.blockTimestamp_Obs) : INVALID_NAT;
    const tickCumulative_val = last_transform_param.tickCumulative_Obs + tick_transform_param * delta;
    const secondsPerLiquidityCumulativeX128_val = 
        last_transform_param.secondsPerLiquidityCumulativeX128_Obs + ((delta <<| 128) div (liquidity_transform_param > 0 ? liquidity_transform_param : 1));

    const retVal: Observation = {
        blockTimestamp_transform_param;
        tickCumulative_val;
        secondsPerLiquidityCumulativeX128_val;
        true
    };

    return retVal
}

function getSurroundingObservations(
    time_getSurroundingObservations: nat,
    target_getSurroundingObservations: nat,
    tick_getSurroundingObservations: int,
    index_getSurroundingObservations: nat,
    liquidity_getSurroundingObservations: nat,
    cardinality_getSurroundingObservations: nat
) : Observation * Observation {
    // optimistically set before to the newest observation
    var beforeOrAt: Observation = observations[index_getSurroundingObservations].observation_value;
    var atOrAfter: Observation = {0; 0; 0; false};

    // if the target is chronologically at or after the newest observation, we can early return
    if (lte(time_getSurroundingObservations, beforeOrAt.blockTimestamp_Obs, target_getSurroundingObservations)) then begin
        if (beforeOrAt.blockTimestamp_Obs = target_getSurroundingObservations) then
            // if newest observation equals target, we're in the same block, so we can ignore atOrAfter
            return ((beforeOrAt, atOrAfter))
        else
            // otherwise, we need to transform
            return ((beforeOrAt, transform(beforeOrAt, target_getSurroundingObservations, tick_getSurroundingObservations, liquidity_getSurroundingObservations)))
    end;

    // now, set before to the oldest observation
    beforeOrAt := observations[(index_getSurroundingObservations + 1) % cardinality_getSurroundingObservations].observation_value;
    if (beforeOrAt.initialized_Obs = false) then beforeOrAt := observations[0].observation_value;

    // ensure that the target is chronologically at or after the oldest observation
    do_require(lte(time_getSurroundingObservations, beforeOrAt.blockTimestamp_Obs, target_getSurroundingObservations), "OLD");

    // if we've reached this point, we have to binary search
    return binarySearch(time_getSurroundingObservations, target_getSurroundingObservations, index_getSurroundingObservations, cardinality_getSurroundingObservations)
}

function observeSingle(
    time_observeSingle: nat,
    secondsAgo_observeSingle: nat,
    tick_observeSingle: int,
    index_observeSingle: nat,
    liquidity_observeSingle: nat,
    cardinality_observeSingle: nat
) : int * nat {
    if (secondsAgo_observeSingle = 0) then begin
        var last: Observation = observations[index_observeSingle].observation_value;
        if (last.blockTimestamp_Obs <> time_observeSingle) then 
            last := transform(last, time_observeSingle, tick_observeSingle, liquidity_observeSingle);
        const val1 = last.tickCumulative_Obs;
        const val2 = last.secondsPerLiquidityCumulativeX128_Obs;
        return ((val1, val2))
    end;

    var target ?= int_to_nat(time_observeSingle - secondsAgo_observeSingle) : INVALID_NAT;

    const retVal = getSurroundingObservations(
        time_observeSingle,
        target,
        tick_observeSingle,
        index_observeSingle,
        liquidity_observeSingle,
        cardinality_observeSingle
    );
    const beforeOrAt = retVal[0];
    const atOrAfter = retVal[1];

    if (target = beforeOrAt.blockTimestamp_Obs) then 
        // we're at the left boundary
        return ((beforeOrAt.tickCumulative_Obs, beforeOrAt.secondsPerLiquidityCumulativeX128_Obs));
    if (target = atOrAfter.blockTimestamp_Obs) then
        // we're at the right boundary
        return ((atOrAfter.tickCumulative_Obs, atOrAfter.secondsPerLiquidityCumulativeX128_Obs));
    // we're in the middle
    const observationTimeDelta = atOrAfter.blockTimestamp_Obs - beforeOrAt.blockTimestamp_Obs;
    const targetDelta = target - beforeOrAt.blockTimestamp_Obs;
    const retVal1 = beforeOrAt.tickCumulative_Obs + ((atOrAfter.tickCumulative_Obs - beforeOrAt.tickCumulative_Obs) div observationTimeDelta) * targetDelta;
    const retVal2_int = 
        beforeOrAt.secondsPerLiquidityCumulativeX128_Obs + 
        (atOrAfter.secondsPerLiquidityCumulativeX128_Obs - beforeOrAt.secondsPerLiquidityCumulativeX128_Obs) * targetDelta div observationTimeDelta;
    const retVal2 ?= int_to_nat(retVal2_int) : INVALID_NAT;
    return ((retVal1, retVal2))
}

// /// @notice Computes the position in the mapping where the initialized bit for a tick lives
// /// @param tick The tick for which to compute the position
// /// @return wordPos The key in the mapping containing the word in which the bit is stored
// /// @return bitPos The bit position in the word where the flag is stored
// function position(tick_: int) : int * nat {
//     const wordPos = tick_ div 256;
//     const bitPos = tick_ % 256;
//     return ((wordPos, bitPos))
// }

/// @notice Retrieves fee growth data
/// @param self The mapping containing all tick information for initialized ticks
/// @param tickLower The lower tick boundary of the position
/// @param tickUpper The upper tick boundary of the position
/// @param tickCurrent The current tick
/// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
/// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
/// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
/// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
function getFeeGrowthInside(
    tickLower_getFeeGrowthInside: int,
    tickUpper_getFeeGrowthInside: int,
    tickCurrent_getFeeGrowthInside: int,
    feeGrowthGlobal0X128_getFeeGrowthInside: nat,
    feeGrowthGlobal1X128_getFeeGrowthInside: nat
) : nat * nat {
    const lower = ticks[tickLower_getFeeGrowthInside].info;
    const upper = ticks[tickUpper_getFeeGrowthInside].info;

    // calculate fee growth below
    var feeGrowthBelow0X128 = 0;
    var feeGrowthBelow1X128 = 0;
    if (tickCurrent_getFeeGrowthInside >= tickLower_getFeeGrowthInside) then begin
        feeGrowthBelow0X128 := lower.feeGrowthOutside0X128;
        feeGrowthBelow1X128 := lower.feeGrowthOutside1X128;
    end else begin
        feeGrowthBelow0X128 ?:= int_to_nat(feeGrowthGlobal0X128_getFeeGrowthInside - lower.feeGrowthOutside0X128) : INVALID_NAT;
        feeGrowthBelow1X128 ?:= int_to_nat(feeGrowthGlobal1X128_getFeeGrowthInside - lower.feeGrowthOutside1X128) : INVALID_NAT;
    end;

    // calculate fee growth above
    var feeGrowthAbove0X128 = 0;
    var feeGrowthAbove1X128 = 0;
    if (tickCurrent_getFeeGrowthInside < tickUpper_getFeeGrowthInside) then begin
        feeGrowthAbove0X128 := upper.feeGrowthOutside0X128;
        feeGrowthAbove1X128 := upper.feeGrowthOutside1X128;
    end else begin
        feeGrowthAbove0X128 ?:= int_to_nat(feeGrowthGlobal0X128_getFeeGrowthInside - upper.feeGrowthOutside0X128) : INVALID_NAT;
        feeGrowthAbove1X128 ?:= int_to_nat(feeGrowthGlobal1X128_getFeeGrowthInside - upper.feeGrowthOutside1X128) : INVALID_NAT;
    end;

    const feeGrowthInside0X128 ?= int_to_nat(feeGrowthGlobal0X128_getFeeGrowthInside - feeGrowthBelow0X128 - feeGrowthAbove0X128) : INVALID_NAT;
    const feeGrowthInside1X128 ?= int_to_nat(feeGrowthGlobal1X128_getFeeGrowthInside - feeGrowthBelow1X128 - feeGrowthAbove1X128) : INVALID_NAT;
    return ((feeGrowthInside0X128, feeGrowthInside1X128))
}

/// @notice Calculates sqrt(1.0001^tick) * 2^96
/// @dev Throws if |tick| > max tick
/// @param tick The input tick for the above formula
/// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
/// at the given tick
function tickMathGetSqrtRatioAtTick(tick_tickMathGetSqrtRatioAtTick: int) : nat {
    var absTick = abs(tick_tickMathGetSqrtRatioAtTick);
    do_require(absTick <= TickMathMAX_TICK, "T");

    var ratio = absTick % 2 <> 0 ? 340265354078544963557816517032075149313 : 340282366920938463463374607431768211456;
    if ((absTick div (1 <<| 1)) % 2 <> 0) then ratio := (ratio * 340248342086729790484326174814286782778) |>> 128;
    if ((absTick div (1 <<| 2)) % 2 <> 0) then ratio := (ratio * 340214320654664324051920982716015181260) |>> 128;
    if ((absTick div (1 <<| 3)) % 2 <> 0) then ratio := (ratio * 340146287995602323631171512101879684304) |>> 128;
    if ((absTick div (1 <<| 4)) % 2 <> 0) then ratio := (ratio * 340010263488231146823593991679159461444) |>> 128;
    if ((absTick div (1 <<| 5)) % 2 <> 0) then ratio := (ratio * 339738377640345403697157401104375502016) |>> 128;
    if ((absTick div (1 <<| 6)) % 2 <> 0) then ratio := (ratio * 339195258003219555707034227454543997025) |>> 128;
    if ((absTick div (1 <<| 7)) % 2 <> 0) then ratio := (ratio * 338111622100601834656805679988414885971) |>> 128;
    if ((absTick div (1 <<| 8)) % 2 <> 0) then ratio := (ratio * 335954724994790223023589805789778977700) |>> 128;
    if ((absTick div (1 <<| 9)) % 2 <> 0) then ratio := (ratio * 331682121138379247127172139078559817300) |>> 128;
    if ((absTick div (1 <<| 10)) % 2 <> 0) then ratio := (ratio * 323299236684853023288211250268160618739) |>> 128;
    if ((absTick div (1 <<| 11)) % 2 <> 0) then ratio := (ratio * 307163716377032989948697243942600083929) |>> 128;
    if ((absTick div (1 <<| 12)) % 2 <> 0) then ratio := (ratio * 277268403626896220162999269216087595045) |>> 128;
    if ((absTick div (1 <<| 13)) % 2 <> 0) then ratio := (ratio * 225923453940442621947126027127485391333) |>> 128;
    if ((absTick div (1 <<| 14)) % 2 <> 0) then ratio := (ratio * 149997214084966997727330242082538205943) |>> 128;
    if ((absTick div (1 <<| 15)) % 2 <> 0) then ratio := (ratio * 66119101136024775622716233608466517926) |>> 128;
    if ((absTick div (1 <<| 16)) % 2 <> 0) then ratio := (ratio * 12847376061809297530290974190478138313) |>> 128;
    if ((absTick div (1 <<| 17)) % 2 <> 0) then ratio := (ratio * 485053260817066172746253684029974020) |>> 128;
    if ((absTick div (1 <<| 18)) % 2 <> 0) then ratio := (ratio * 691415978906521570653435304214168) |>> 128;
    if ((absTick div (1 <<| 19)) % 2 <> 0) then ratio := (ratio * 1404880482679654955896180642) |>> 128;

    if (tick_tickMathGetSqrtRatioAtTick > 0) then ratio := abs(Q256 - 1) div ratio;

    // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
    const sqrtPriceX96_val = (ratio |>> 32) + ((ratio % (1 <<| 32) = 0) ? 0 : 1);

    return sqrtPriceX96_val
}

/// @notice Gets the amount0 delta between two prices
/// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),
/// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))
/// @param sqrtRatioAX96_sPMGA0D A sqrt price
/// @param sqrtRatioBX96_sPMGA0D Another sqrt price
/// @param liquidity The amount of usable liquidity
/// @param roundUp_sPMGA0D Whether to round the amount up or down
/// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices
function sqrtPriceMathGetAmount0Delta_round(
    sqrtRatioAX96_sPMGA0D: nat,
    sqrtRatioBX96_sPMGA0D: nat,
    liquidity_sPMGA0D: nat,
    roundUp_sPMGA0D: bool
) : nat {
    var sqrtRatioAX96_val = sqrtRatioAX96_sPMGA0D;
    var sqrtRatioBX96_val = sqrtRatioBX96_sPMGA0D;
    if (sqrtRatioAX96_sPMGA0D > sqrtRatioBX96_sPMGA0D) then begin
        sqrtRatioAX96_val := sqrtRatioBX96_sPMGA0D;
        sqrtRatioBX96_val := sqrtRatioAX96_sPMGA0D
    end;

    const numerator1 = liquidity_sPMGA0D <<| RESOLUTION;
    const numerator2 ?= int_to_nat(sqrtRatioBX96_val - sqrtRatioAX96_val) : INVALID_NAT;

    do_require(sqrtRatioAX96_val > 0, ());

    if roundUp_sPMGA0D then begin
        const val1 ?= int_to_nat(ceil(numerator1 * numerator2 / sqrtRatioBX96_val)) : INVALID_NAT;
        const val2 ?= int_to_nat(ceil(val1 / sqrtRatioAX96_val)) : INVALID_NAT;
        return val2
    end;
    const retVal = numerator1 * numerator2 div sqrtRatioBX96_val div sqrtRatioAX96_val;
    return retVal
}

/// @notice Helper that gets signed token0 delta
/// @param sqrtRatioAX96 A sqrt price
/// @param sqrtRatioBX96 Another sqrt price
/// @param liquidity The change in liquidity for which to compute the amount0 delta
/// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices
function sqrtPriceMathGetAmount0Delta(
    sqrtRatioAX96_sPMGA0D: nat,
    sqrtRatioBX96_sPMGA0D: nat,
    liquidity_sPMGA0D: int
) : int {
    if liquidity_sPMGA0D < 0 then begin
        const retVal = -sqrtPriceMathGetAmount0Delta_round(sqrtRatioAX96_sPMGA0D, sqrtRatioBX96_sPMGA0D, abs(liquidity_sPMGA0D), false);
        return retVal
    end;
    return sqrtPriceMathGetAmount0Delta_round(sqrtRatioAX96_sPMGA0D, sqrtRatioBX96_sPMGA0D, abs(liquidity_sPMGA0D), true)
}

/// @notice Gets the amount1 delta between two prices
/// @dev Calculates liquidity_sPMGA1D * (sqrt(upper) - sqrt(lower))
/// @param sqrtRatioAX96_sPMGA1D A sqrt price
/// @param sqrtRatioBX96_sPMGA1D Another sqrt price
/// @param liquidity_sPMGA1D The amount of usable liquidity_sPMGA1D
/// @param roundUp_sPMGA1D Whether to round the amount up, or down
/// @return amount1 Amount of token1 required to cover a position of size liquidity_sPMGA1D between the two passed prices
function sqrtPriceMathGetAmount1Delta_round(
    sqrtRatioAX96_sPMGA1D: nat,
    sqrtRatioBX96_sPMGA1D: nat,
    liquidity_sPMGA1D: nat,
    roundUp_sPMGA1D: bool
) : nat {
    var sqrtRatioAX96_val = sqrtRatioAX96_sPMGA1D;
    var sqrtRatioBX96_val = sqrtRatioBX96_sPMGA1D;
    if (sqrtRatioAX96_sPMGA1D > sqrtRatioBX96_sPMGA1D) then begin
        sqrtRatioAX96_val := sqrtRatioBX96_sPMGA1D;
        sqrtRatioBX96_val := sqrtRatioAX96_sPMGA1D
    end;

    if roundUp_sPMGA1D then begin
        const val ?= int_to_nat((ceil(liquidity_sPMGA1D * (sqrtRatioBX96_val - sqrtRatioAX96_val) / Q96))) : INVALID_NAT;
        return val
    end;
    var retVal ?= int_to_nat(sqrtRatioBX96_val - sqrtRatioAX96_val) : INVALID_NAT;
    retVal := liquidity_sPMGA1D * retVal div Q96;
    return retVal
}

/// @notice Helper that gets signed token1 delta
/// @param sqrtRatioAX96 A sqrt price
/// @param sqrtRatioBX96 Another sqrt price
/// @param liquidity The change in liquidity for which to compute the amount1 delta
/// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices
function sqrtPriceMathGetAmount1Delta(
    sqrtRatioAX96_sPMGA1D: nat,
    sqrtRatioBX96_sPMGA1D: nat,
    liquidity_sPMGA1D: int
) : int {
    if liquidity_sPMGA1D < 0 then begin
        const retVal = -sqrtPriceMathGetAmount1Delta_round(sqrtRatioAX96_sPMGA1D, sqrtRatioBX96_sPMGA1D, abs(liquidity_sPMGA1D), false);
        return retVal
    end;
    return sqrtPriceMathGetAmount1Delta_round(sqrtRatioAX96_sPMGA1D, sqrtRatioBX96_sPMGA1D, abs(liquidity_sPMGA1D), true)
}

/// @inheritdoc IUniswapV3PoolActions
/// @dev noDelegateCall is applied indirectly via _modifyPosition
entry mint(
    /* address */ recipient_mint: address,
    /* int24 */ tickLower_mint: int,
    /* int24 */ tickUpper_mint: int,
    /* uint128 */ amount_mint: nat,
    /* bytes calldata */ data_mint: bytes
) 
// /* external override returns */ : (nat /* uint256 amount0 */ * nat /* uint256 amount1 */) 
{
    effect {
        do_require(slot0.unlocked, ("LOK", slot0.unlocked));
        slot0.unlocked := false;
        do_require(amount_mint > 0, ());

        // (, int256 amount0Int, int256 amount1Int) = _modifyPosition(
        //     ModifyPositionParams({
        //         owner: recipient,
        //         tickLower: tickLower,
        //         tickUpper: tickUpper,
        //         liquidityDelta: int256(amount).toInt128()
        //     })
        // );

        // getter _modifyPosition(params: ModifyPositionParams)
        // // private
        // : {
        //     PositionInfo, /* Position.Info storage position */,
        //     nat, /* int256 amount0 */,
        //     nat, /* int256 amount1 */
        // }
        do_require(noDelegateCall(), ());
        do_require(checkTicks(tickLower_mint, tickUpper_mint), ());
        const slot0_: Slot0 = slot0; // SLOAD for gas optimization // memory
        // position := _updatePosition(
        //     recipient_mint,
        //     tickLower_mint,
        //     tickUpper_mint,
        //     amount_mint,
        //     slot0_.tick
        // );
        

        /// @dev Gets and updates a position with the given liquidity delta
        /// @param owner the owner of the position
        /// @param tickLower the lower tick of the position's tick range
        /// @param tickUpper the upper tick of the position's tick range
        /// @param tick the current tick, passed to avoid sloads
        // getter _updatePosition(
        //     owner: address,
        //     tickLower: int,
        //     tickUpper: int,
        //     liquidityDelta: int,
        //     tick: int
        // ) /* private returns */ : PositionInfo /* storage position */ {
        var position = positions[(recipient_mint, tickLower_mint, tickUpper_mint)].positionInfo;

        var feeGrowthGlobal0X128_: nat = feeGrowthGlobal0X128; // SLOAD for gas optimization
        var feeGrowthGlobal1X128_: nat = feeGrowthGlobal1X128; // SLOAD for gas optimization

        // if we need to update the ticks, do it
        var flippedLower: bool = false;
        var flippedUpper: bool = false;
        if (amount_mint <> 0) then begin
            const time: nat = blockTimestamp_();
            
            const retVal : (int * nat) = observeSingle(
                time,
                0,
                slot0.tick,
                slot0.observationIndex,
                liquidity,
                slot0.observationCardinality
            );
            var tickCumulative = retVal[0];
            var secondsPerLiquidityCumulativeX128 = retVal[1];

            // flippedLower = ticks.update(
            //     tickLower,
            //     tick,
            //     liquidityDelta,
            //     _feeGrowthGlobal0X128,
            //     _feeGrowthGlobal1X128,
            //     secondsPerLiquidityCumulativeX128,
            //     tickCumulative,
            //     time,
            //     false,
            //     maxLiquidityPerTick
            // );

            // function update(
            //     mapping(int24 => Tick.Info) storage self,
            //     int24 tick,
            //     int24 tickCurrent,
            //     int128 liquidityDelta,
            //     uint256 feeGrowthGlobal0X128,
            //     uint256 feeGrowthGlobal1X128,
            //     uint160 secondsPerLiquidityCumulativeX128,
            //     int56 tickCumulative,
            //     uint32 time,
            //     bool upper,
            //     uint128 maxLiquidity
            // ) internal returns (bool flipped) {
            var info_flippedLower = ticks[tickLower_mint].info; // storage // TODO + don't forgot update of storage // check done-info_flippedLower-storage

            var liquidityGrossBefore = info_flippedLower.liquidityGross;
            var liquidityGrossAfter = liquidityGrossBefore + amount_mint;

            do_require(liquidityGrossAfter <= maxLiquidityPerTick, "LO");

            flippedLower := (liquidityGrossAfter = 0) <> (liquidityGrossBefore = 0);

            if (liquidityGrossBefore = 0) then begin
                // by convention, we assume that all growth before a tick was initialized happened _below_ the tick
                if (tickLower_mint <= slot0_.tick) then begin
                    info_flippedLower.feeGrowthOutside0X128 := feeGrowthGlobal0X128_;
                    info_flippedLower.feeGrowthOutside1X128 := feeGrowthGlobal1X128_;
                    info_flippedLower.secondsPerLiquidityOutsideX128 := secondsPerLiquidityCumulativeX128;
                    info_flippedLower.tickCumulativeOutside := tickCumulative;
                    info_flippedLower.secondsOutside := time
                end;
                info_flippedLower.%initialized := true
            end;

            info_flippedLower.liquidityGross := liquidityGrossAfter;

            // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)
            // info_flippedLower.liquidityNet := upper
            //     ? info_flippedLower.liquidityNet - amount_mint
            //     : info_flippedLower.liquidityNet + amount_mint;
            info_flippedLower.liquidityNet := info_flippedLower.liquidityNet + amount_mint;

            ticks[tickLower_mint].info := info_flippedLower; // TODO - done-info_flippedLower-storage
            
            // }

            // flippedUpper = ticks.update(
            //     tickUpper,
            //     tick,
            //     liquidityDelta,
            //     _feeGrowthGlobal0X128,
            //     _feeGrowthGlobal1X128,
            //     secondsPerLiquidityCumulativeX128,
            //     tickCumulative,
            //     time,
            //     true,
            //     maxLiquidityPerTick
            // );

            var info_flippedUpper = ticks[tickUpper_mint].info; // storage // TODO + don't forgot update of storage // check done-info_flippedLower-storage

            liquidityGrossBefore := info_flippedUpper.liquidityGross;
            liquidityGrossAfter := liquidityGrossBefore + amount_mint;

            do_require(liquidityGrossAfter <= maxLiquidityPerTick, "LO");

            flippedUpper := (liquidityGrossAfter = 0) <> (liquidityGrossBefore = 0);

            if (liquidityGrossBefore = 0) then begin
                // by convention, we assume that all growth before a tick was initialized happened _below_ the tick
                if (tickUpper_mint <= slot0_.tick) then begin
                    info_flippedUpper.feeGrowthOutside0X128 := feeGrowthGlobal0X128;
                    info_flippedUpper.feeGrowthOutside1X128 := feeGrowthGlobal1X128;
                    info_flippedUpper.secondsPerLiquidityOutsideX128 := secondsPerLiquidityCumulativeX128;
                    info_flippedUpper.tickCumulativeOutside := tickCumulative;
                    info_flippedUpper.secondsOutside := time;
                end;
                info_flippedUpper.%initialized := true;
            end;

            info_flippedUpper.liquidityGross := liquidityGrossAfter;

            // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)
            info_flippedLower.liquidityNet := info_flippedLower.liquidityNet - amount_mint;

            ticks[tickUpper_mint].info := info_flippedUpper; // TODO - done-info_flippedLower-storage

            if (flippedLower) then begin
                do_require(tickLower_mint % tickSpacing = 0, ()); // ensure that the tick is spaced
                const retVal_: (int * nat) ?= (tickLower_mint div tickSpacing) /% 256 : INVALID_INT_NAT;
                const wordPos = retVal_[0];
                const bitPos = retVal_[1];
                const mask = 1 <<| bitPos;
                const posVal = (tickBitmap[wordPos].tickSpacing_tickBmp div mask) % 2;
                if posVal = 1 then
                    tickBitmap[wordPos].tickSpacing_tickBmp ?:= int_to_nat(tickBitmap[wordPos].tickSpacing_tickBmp - mask) : INVALID_NAT
                else
                    tickBitmap[wordPos].tickSpacing_tickBmp := tickBitmap[wordPos].tickSpacing_tickBmp + mask
            end;

            if (flippedUpper) then begin
                do_require(tickUpper_mint % tickSpacing = 0, ()); // ensure that the tick is spaced
                const retVal_: (int * nat) ?= (tickUpper_mint div tickSpacing) /% 256 : INVALID_INT_NAT;
                const wordPos = retVal_[0];
                const bitPos = retVal_[1];
                const mask = 1 <<| bitPos;
                const posVal = (tickBitmap[wordPos].tickSpacing_tickBmp div mask) % 2;
                if posVal = 1 then
                    tickBitmap[wordPos].tickSpacing_tickBmp ?:= int_to_nat(tickBitmap[wordPos].tickSpacing_tickBmp - mask) : INVALID_NAT
                else
                    tickBitmap[wordPos].tickSpacing_tickBmp := tickBitmap[wordPos].tickSpacing_tickBmp + mask
            end;
        end;

        const retVal_getFeeGrowthInside: (nat * nat) = getFeeGrowthInside(
            tickLower_mint,
            tickUpper_mint,
            slot0_.tick,
            feeGrowthGlobal0X128_,
            feeGrowthGlobal1X128_
        );

        const feeGrowthInside0X128 = retVal_getFeeGrowthInside[0];
        const feeGrowthInside1X128 = retVal_getFeeGrowthInside[1];

        // position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);

        /// @notice Credits accumulated fees to a user's position
        /// @param self The individual position to update
        /// @param liquidityDelta The change in pool liquidity as a result of the position update
        /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
        /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
        // function update(
        //     Info storage self,
        //     int128 liquidityDelta,
        //     uint256 feeGrowthInside0X128,
        //     uint256 feeGrowthInside1X128
        // ) internal {

        var liquidityNext = 0;
        if (amount_mint = 0) then begin
            do_require(position.liquidity_PosInfo > 0, "NP"); // disallow pokes for 0 liquidity positions
            liquidityNext := position.liquidity_PosInfo
        end else begin
            liquidityNext := position.liquidity_PosInfo + amount_mint
        end;

        // calculate accumulated fees // TOOD + fullMath 512 bit operatoin
        var tokensOwed0 = (feeGrowthInside0X128 - position.feeGrowthInside0LastX128_PosInfo) * position.liquidity_PosInfo div Q128;
        var tokensOwed1 = (feeGrowthInside1X128 - position.feeGrowthInside1LastX128_PosInfo) * position.liquidity_PosInfo div Q128;

        // update the position
        if (amount_mint <> 0) then position.liquidity_PosInfo := liquidityNext;
        position.feeGrowthInside0LastX128_PosInfo := feeGrowthInside0X128;
        position.feeGrowthInside1LastX128_PosInfo := feeGrowthInside1X128;
        if (tokensOwed0 > 0 or tokensOwed1 > 0) then begin
            // overflow is acceptable, have to withdraw before you hit type(uint128).max fees
            position.tokensOwed0_PosInfo += tokensOwed0;
            position.tokensOwed1_PosInfo += tokensOwed1;
        end;
        // }

        // clear any tick data that is no longer needed
        // if (amount_mint < 0) then begin
        //     if (flippedLower) then
        //         ticks.clear(tickLower);
        //     if (flippedUpper) then
        //         ticks.clear(tickUpper)
        // end

        // return position
        positions[(recipient_mint, tickLower_mint, tickUpper_mint)].positionInfo := position;
        var amount0: int = 0;
        var amount1: int = 0;

        if (amount_mint <> 0) then begin
            if (slot0_.tick < tickLower_mint) then begin
                // current tick is below the passed range; liquidity can only become in range by crossing from left to
                // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it
                amount0 := sqrtPriceMathGetAmount0Delta(
                    tickMathGetSqrtRatioAtTick(tickLower_mint),
                    tickMathGetSqrtRatioAtTick(tickUpper_mint),
                    amount_mint
                );
            end else begin 
                if (slot0_.tick < tickUpper_mint) then begin
                    // current tick is inside the passed range
                    var liquidityBefore = liquidity; // SLOAD for gas optimization

                    // write an oracle entry
                    // (slot0.observationIndex, slot0.observationCardinality) = observations.write(
                    //     slot0_.observationIndex,
                    //     blockTimestamp_(),
                    //     slot0_.tick,
                    //     liquidityBefore,
                    //     slot0_.observationCardinality,
                    //     slot0_.observationCardinalityNext
                    // );

                    /// @notice Writes an oracle observation to the array
                    /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.
                    /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality
                    /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.
                    /// @param self The stored oracle array
                    /// @param index The index of the observation that was most recently written to the observations array
                    /// @param blockTimestamp The timestamp of the new observation
                    /// @param tick The active tick at the time of the new observation
                    /// @param liquidity The total in-range liquidity at the time of the new observation
                    /// @param cardinality The number of populated elements in the oracle array
                    /// @param cardinalityNext The new length of the oracle array, independent of population
                    /// @return indexUpdated The new index of the most recently written element in the oracle array
                    /// @return cardinalityUpdated The new cardinality of the oracle array
                    // function write(
                    //     Observation[65535] storage self,
                    //     uint16 index,
                    //     uint32 blockTimestamp,
                    //     int24 tick,
                    //     uint128 liquidity,
                    //     uint16 cardinality,
                    //     uint16 cardinalityNext
                    // ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {
                    const last = observations[slot0_.observationIndex].observation_value;

                    // early return if we've already written an observation this block
                    if (last.blockTimestamp_Obs = blockTimestamp_()) then begin
                        slot0.observationIndex := slot0_.observationIndex;
                        slot0.observationCardinality := slot0_.observationCardinality
                    end;

                    var indexUpdated = 0;
                    var cardinalityUpdated = 0;
                    // if the conditions are right, we can bump the cardinality
                    if (slot0_.observationCardinalityNext > slot0_.observationCardinality and slot0_.observationIndex = (slot0_.observationCardinality - 1)) then 
                        cardinalityUpdated := slot0_.observationCardinalityNext
                    else
                        cardinalityUpdated := slot0_.observationCardinality;

                    indexUpdated := (slot0_.observationIndex + 1) % cardinalityUpdated;
                    observations[indexUpdated].observation_value := transform(last, blockTimestamp_(), slot0_.tick, liquidityBefore);
                    slot0.observationIndex := indexUpdated;
                    slot0.observationCardinality := cardinalityUpdated;
                    // }

                    amount0 := sqrtPriceMathGetAmount0Delta(
                        slot0_.sqrtPriceX96,
                        tickMathGetSqrtRatioAtTick(tickUpper_mint),
                        amount_mint
                    );
                    amount1 := sqrtPriceMathGetAmount1Delta(
                        tickMathGetSqrtRatioAtTick(tickLower_mint),
                        slot0_.sqrtPriceX96,
                        amount_mint
                    );

                    liquidity := liquidityBefore + amount_mint
                end else begin
                    // current tick is above the passed range; liquidity can only become in range by crossing from right to
                    // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it
                    amount1 := sqrtPriceMathGetAmount1Delta(
                        tickMathGetSqrtRatioAtTick(tickLower_mint),
                        tickMathGetSqrtRatioAtTick(tickUpper_mint),
                        amount_mint
                    )
                end
            end
        end;

        const amount0_nat ?= int_to_nat(amount0) : INVALID_NAT;
        const amount1_nat ?= int_to_nat(amount1) : INVALID_NAT;

        // var balance0Before: nat = 0;
        // var balance1Before: nat = 0;
        // if (amount0_nat > 0) then balance0Before := balance0();
        // if (amount1_nat > 0) then balance1Before := balance1();
        // IUniswapV3MintCallback(caller).uniswapV3MintCallback(amount0_nat, amount1_nat, data_mint);
        // if (amount0_nat > 0) then do_require(balance0Before + amount0_nat <= balance0(), "M0");
        // if (amount1_nat > 0) then do_require(balance1Before + amount1_nat <= balance1(), "M1");

        const unpack_val : MintCallbackData ?= unpack<MintCallbackData>(data_mint) : INVALID_UNPACK; // TODO + please check amount amd amount_min slippage check

        do_require(unpack_val.poolKey.token0_poolKey = token0, ());
        do_require(unpack_val.poolKey.token1_poolKey = token1, ());
        do_require(unpack_val.poolKey.fee_poolKey = fee, ());
        
        balance0 += amount0_nat;
        balance1 += amount1_nat;

        transfer 0tz to token0 call %transfer<address * address * nat>((unpack_val.payer, self_address, amount0_nat));
        transfer 0tz to token1 call %transfer<address * address * nat>((unpack_val.payer, self_address, amount1_nat));

        // TODO + please check amount amd amount_min slippage check

        emit<Mint>({caller; recipient_mint; tickLower_mint; tickUpper_mint; amount_mint; amount0_nat; amount1_nat});
        slot0.unlocked := true
    }
}

// /// @inheritdoc IUniswapV3PoolActions
// getter collect(
//     /* address */ recipient: address,
//     /* int24 */ tickLower: int,
//     /* int24 */ tickUpper: int,
//     /* uint128 */ amount0Requested: nat,
//     /* uint128 */ amount1Requested: nat
// ) /* external override returns */ : {nat, nat} /* (uint128 amount0, uint128 amount1) */ {
//     do_require(slot0.unlocked, ("LOK", slot0.unlocked));
//     slot0.unlocked := false;
//     // // we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}
//     // Position.Info storage position = positions.get(caller, tickLower, tickUpper);

//     // amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;
//     // amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;

//     // if (amount0 > 0) {
//     //     position.tokensOwed0 -= amount0;
//     //     TransferHelper.safeTransfer(token0, recipient, amount0);
//     // }
//     // if (amount1 > 0) {
//     //     position.tokensOwed1 -= amount1;
//     //     TransferHelper.safeTransfer(token1, recipient, amount1);
//     // }

//     // emit Collect(caller, recipient, tickLower, tickUpper, amount0, amount1);
//     slot0.unlocked := true;
// }

/// @inheritdoc IUniswapV3PoolActions
/// @dev noDelegateCall is applied indirectly via _modifyPosition
getter burn(
    /* int24 */ tickLower_burn: int,
    /* int24 */ tickUpper_burn: int,
    /* uint128 */ amount_burn: nat
) 
// /* external override returns */ : {nat, nat} /* (uint256 amount0, uint256 amount1) */ 
{
    do_require(slot0.unlocked, ("LOK", slot0.unlocked));
    slot0.unlocked := false;
    // (Position.Info storage position, int256 amount0Int, int256 amount1Int) = _modifyPosition(
    //     ModifyPositionParams({
    //         owner: caller,
    //         tickLower: tickLower,
    //         tickUpper: tickUpper,
    //         liquidityDelta: -int256(amount).toInt128()
    //     })
    // );

    // const amount0_nat = abs(amount0);
    // const amount1_nat = abs(amount1);

    // amount0 = uint256(-amount0Int);
    // amount1 = uint256(-amount1Int);

    // if (amount0 > 0 || amount1 > 0) {
    //     (position.tokensOwed0, position.tokensOwed1) = (
    //         position.tokensOwed0 + uint128(amount0),
    //         position.tokensOwed1 + uint128(amount1)
    //     );
    // }

    // emit <Burn>({caller; tickLower_burn; tickUpper_burn; amount_burn; amount0_nat; amount1_nat});
    slot0.unlocked := true
}

// // record SwapCache {
// //     // the protocol fee for the input token
// //     feeProtocol: nat;
// //     // liquidity at the beginning of the swap
// //     liquidityStart: nat;
// //     // the timestamp of the current block
// //     blockTimestamp: nat;
// //     // the current value of the tick accumulator, computed only if we cross an initialized tick
// //     tickCumulative: int;
// //     // the current value of seconds per liquidity accumulator, computed only if we cross an initialized tick
// //     secondsPerLiquidityCumulativeX128: nat;
// //     // whether we've computed and cached the above two accumulators
// //     computedLatestObservation: bool;
// // }

// // // the top level state of the swap, the results of which are recorded in storage at the end
// // record SwapState {
// //     // the amount remaining to be swapped in/out of the input/output asset
// //     amountSpecifiedRemaining: int;
// //     // the amount already swapped out/in of the output/input asset
// //     amountCalculated: int;
// //     // current sqrt(price)
// //     sqrtPriceX96: nat;
// //     // the tick associated with the current price
// //     tick: int;
// //     // the global fee growth of the input token
// //     feeGrowthGlobalX128: nat;
// //     // amount of input token paid as protocol fee
// //     protocolFee: nat;
// //     // the current liquidity in range
// //     liquidity: nat;
// // }

// // record StepComputations {
// //     // the price at the beginning of the step
// //     sqrtPriceStartX96: nat;
// //     // the next tick to swap to from the current tick in the swap direction
// //     tickNext: int;
// //     // whether tickNext is initialized or not
// //     %initialized: bool;
// //     // sqrt(price) for the next tick (1/0)
// //     sqrtPriceNextX96: nat;
// //     // how much is being swapped in in this step
// //     amountIn: nat;
// //     // how much is being swapped out
// //     amountOut: nat;
// //     // how much fee is being paid in
// //     feeAmount: nat;
// // }

// /// @inheritdoc IUniswapV3PoolActions
// getter swap(
//     /* address */ recipient: address,
//     /* bool */ zeroForOne: bool,
//     /* int256 */ amountSpecified: int,
//     /* uint160 */ sqrtPriceLimitX96: nat,
//     /* bytes calldata */ data: bytes
// ) /* external override returns */ : {int, int} /* (int256 amount0, int256 amount1) */ {
//     require {swap: noDelegateCall();}
    
//     // require(amountSpecified != 0, 'AS');

//     // Slot0 memory slot0Start = slot0;

//     // require(slot0Start.unlocked, 'LOK');
//     // require(
//     //     zeroForOne
//     //         ? sqrtPriceLimitX96 < slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 > TickMath.MIN_SQRT_RATIO
//     //         : sqrtPriceLimitX96 > slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 < TickMath.MAX_SQRT_RATIO,
//     //     'SPL'
//     // );

//     // slot0.unlocked := false;

//     // SwapCache memory cache = SwapCache({
//     //     liquidityStart: liquidity,
//     //     blockTimestamp: blockTimestamp_(),
//     //     feeProtocol: zeroForOne ? (slot0Start.feeProtocol % 16) : (slot0Start.feeProtocol >> 4),
//     //     secondsPerLiquidityCumulativeX128: 0,
//     //     tickCumulative: 0,
//     //     computedLatestObservation: false
//     // });

//     // bool exactInput = amountSpecified > 0;

//     // SwapState memory state = SwapState({
//     //     amountSpecifiedRemaining: amountSpecified,
//     //     amountCalculated: 0,
//     //     sqrtPriceX96: slot0Start.sqrtPriceX96,
//     //     tick: slot0Start.tick,
//     //     feeGrowthGlobalX128: zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128,
//     //     protocolFee: 0,
//     //     liquidity: cache.liquidityStart
//     // });

//     // // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit
//     // while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != sqrtPriceLimitX96) {
//     //     StepComputations memory step;

//     //     step.sqrtPriceStartX96 = state.sqrtPriceX96;

//     //     (step.tickNext, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord(
//     //         state.tick,
//     //         tickSpacing,
//     //         zeroForOne
//     //     );

//     //     // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds
//     //     if (step.tickNext < TickMath.MIN_TICK) {
//     //         step.tickNext = TickMath.MIN_TICK;
//     //     } else if (step.tickNext > TickMath.MAX_TICK) {
//     //         step.tickNext = TickMath.MAX_TICK;
//     //     }

//     //     // get the price for the next tick
//     //     step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);

//     //     // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted
//     //     (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(
//     //         state.sqrtPriceX96,
//     //         (zeroForOne ? step.sqrtPriceNextX96 < sqrtPriceLimitX96 : step.sqrtPriceNextX96 > sqrtPriceLimitX96)
//     //             ? sqrtPriceLimitX96
//     //             : step.sqrtPriceNextX96,
//     //         state.liquidity,
//     //         state.amountSpecifiedRemaining,
//     //         fee
//     //     );

//     //     if (exactInput) {
//     //         state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();
//     //         state.amountCalculated = state.amountCalculated.sub(step.amountOut.toInt256());
//     //     } else {
//     //         state.amountSpecifiedRemaining += step.amountOut.toInt256();
//     //         state.amountCalculated = state.amountCalculated.add((step.amountIn + step.feeAmount).toInt256());
//     //     }

//     //     // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee
//     //     if (cache.feeProtocol > 0) {
//     //         uint256 delta = step.feeAmount / cache.feeProtocol;
//     //         step.feeAmount -= delta;
//     //         state.protocolFee += uint128(delta);
//     //     }

//     //     // update global fee tracker
//     //     if (state.liquidity > 0)
//     //         state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);

//     //     // shift tick if we reached the next price
//     //     if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {
//     //         // if the tick is initialized, run the tick transition
//     //         if (step.initialized) {
//     //             // check for the placeholder value, which we replace with the actual value the first time the swap
//     //             // crosses an initialized tick
//     //             if (!cache.computedLatestObservation) {
//     //                 (cache.tickCumulative, cache.secondsPerLiquidityCumulativeX128) = observations.observeSingle(
//     //                     cache.blockTimestamp,
//     //                     0,
//     //                     slot0Start.tick,
//     //                     slot0Start.observationIndex,
//     //                     cache.liquidityStart,
//     //                     slot0Start.observationCardinality
//     //                 );
//     //                 cache.computedLatestObservation = true;
//     //             }
//     //             int128 liquidityNet = ticks.cross(
//     //                 step.tickNext,
//     //                 (zeroForOne ? state.feeGrowthGlobalX128 : feeGrowthGlobal0X128),
//     //                 (zeroForOne ? feeGrowthGlobal1X128 : state.feeGrowthGlobalX128),
//     //                 cache.secondsPerLiquidityCumulativeX128,
//     //                 cache.tickCumulative,
//     //                 cache.blockTimestamp
//     //             );
//     //             // if we're moving leftward, we interpret liquidityNet as the opposite sign
//     //             // safe because liquidityNet cannot be type(int128).min
//     //             if (zeroForOne) liquidityNet = -liquidityNet;

//     //             state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);
//     //         }

//     //         state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
//     //     } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {
//     //         // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved
//     //         state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);
//     //     }
//     // }

//     // // update tick and write an oracle entry if the tick change
//     // if (state.tick != slot0Start.tick) {
//     //     (uint16 observationIndex, uint16 observationCardinality) = observations.write(
//     //         slot0Start.observationIndex,
//     //         cache.blockTimestamp,
//     //         slot0Start.tick,
//     //         cache.liquidityStart,
//     //         slot0Start.observationCardinality,
//     //         slot0Start.observationCardinalityNext
//     //     );
//     //     (slot0.sqrtPriceX96, slot0.tick, slot0.observationIndex, slot0.observationCardinality) = (
//     //         state.sqrtPriceX96,
//     //         state.tick,
//     //         observationIndex,
//     //         observationCardinality
//     //     );
//     // } else {
//     //     // otherwise just update the price
//     //     slot0.sqrtPriceX96 = state.sqrtPriceX96;
//     // }

//     // // update liquidity if it changed
//     // if (cache.liquidityStart != state.liquidity) liquidity = state.liquidity;

//     // // update fee growth global and, if necessary, protocol fees
//     // // overflow is acceptable, protocol has to withdraw before it hits type(uint128).max fees
//     // if (zeroForOne) {
//     //     feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;
//     //     if (state.protocolFee > 0) protocolFees.token0 += state.protocolFee;
//     // } else {
//     //     feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;
//     //     if (state.protocolFee > 0) protocolFees.token1 += state.protocolFee;
//     // }

//     // (amount0, amount1) = zeroForOne == exactInput
//     //     ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)
//     //     : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);

//     // // do the transfers and collect payment
//     // if (zeroForOne) {
//     //     if (amount1 < 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));

//     //     uint256 balance0Before = balance0();
//     //     IUniswapV3SwapCallback(caller).uniswapV3SwapCallback(amount0, amount1, data);
//     //     require(balance0Before.add(uint256(amount0)) <= balance0(), 'IIA');
//     // } else {
//     //     if (amount0 < 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0));

//     //     uint256 balance1Before = balance1();
//     //     IUniswapV3SwapCallback(caller).uniswapV3SwapCallback(amount0, amount1, data);
//     //     require(balance1Before.add(uint256(amount1)) <= balance1(), 'IIA');
//     // }

//     // emit Swap(caller, recipient, amount0, amount1, state.sqrtPriceX96, state.liquidity, state.tick);
//     // slot0.unlocked := true;
// }

// /// @inheritdoc IUniswapV3PoolActions
// entry flash(
//     /* address */ recipient: address,
//     /* uint256 */ amount0: nat,
//     /* uint256 */ amount1: nat,
//     /* bytes calldata */ data: bytes
// ) /* external override */ {
//     do_require(slot0.unlocked, ("LOK", slot0.unlocked));
//     slot0.unlocked := false;
//     require {flash: noDelegateCall();}
//     // uint128 _liquidity = liquidity;
//     // require(_liquidity > 0, 'L');

//     // uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e6);
//     // uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e6);
//     // uint256 balance0Before = balance0();
//     // uint256 balance1Before = balance1();

//     // if (amount0 > 0) TransferHelper.safeTransfer(token0, recipient, amount0);
//     // if (amount1 > 0) TransferHelper.safeTransfer(token1, recipient, amount1);

//     // IUniswapV3FlashCallback(caller).uniswapV3FlashCallback(fee0, fee1, data);

//     // uint256 balance0After = balance0();
//     // uint256 balance1After = balance1();

//     // require(balance0Before.add(fee0) <= balance0After, 'F0');
//     // require(balance1Before.add(fee1) <= balance1After, 'F1');

//     // // sub is safe because we know balanceAfter is gt balanceBefore by at least fee
//     // uint256 paid0 = balance0After - balance0Before;
//     // uint256 paid1 = balance1After - balance1Before;

//     // if (paid0 > 0) {
//     //     uint8 feeProtocol0 = slot0.feeProtocol % 16;
//     //     uint256 fees0 = feeProtocol0 == 0 ? 0 : paid0 / feeProtocol0;
//     //     if (uint128(fees0) > 0) protocolFees.token0 += uint128(fees0);
//     //     feeGrowthGlobal0X128 += FullMath.mulDiv(paid0 - fees0, FixedPoint128.Q128, _liquidity);
//     // }
//     // if (paid1 > 0) {
//     //     uint8 feeProtocol1 = slot0.feeProtocol >> 4;
//     //     uint256 fees1 = feeProtocol1 == 0 ? 0 : paid1 / feeProtocol1;
//     //     if (uint128(fees1) > 0) protocolFees.token1 += uint128(fees1);
//     //     feeGrowthGlobal1X128 += FullMath.mulDiv(paid1 - fees1, FixedPoint128.Q128, _liquidity);
//     // }

//     // emit Flash(caller, recipient, amount0, amount1, paid0, paid1);
//     slot0.unlocked := true;
// }

// /// @inheritdoc IUniswapV3PoolOwnerActions
// entry setFeeProtocol(feeProtocol0: nat, feeProtocol1: nat) /* external override */ {
//     do_require(slot0.unlocked, ("LOK", slot0.unlocked));
//     slot0.unlocked := false;
//     require {setFeeProtocol: onlyFactoryOwner();}
//     // require(
//     //     (feeProtocol0 == 0 || (feeProtocol0 >= 4 && feeProtocol0 <= 10)) &&
//     //         (feeProtocol1 == 0 || (feeProtocol1 >= 4 && feeProtocol1 <= 10))
//     // );
//     // uint8 feeProtocolOld = slot0.feeProtocol;
//     // slot0.feeProtocol = feeProtocol0 + (feeProtocol1 << 4);
//     // emit SetFeeProtocol(feeProtocolOld % 16, feeProtocolOld >> 4, feeProtocol0, feeProtocol1);
//     slot0.unlocked := true;
// }

// /// @inheritdoc IUniswapV3PoolOwnerActions
// getter collectProtocol(
//     /* address */ recipient: address,
//     /* uint128 */ amount0Requested: nat,
//     /* uint128 */ amount1Requested: nat
// ) /* external override returns (uint128 amount0, uint128 amount1) */ : {nat, nat} {
//     do_require(slot0.unlocked, ("LOK", slot0.unlocked));
//     slot0.unlocked := false;
//     require {collectProtocol: onlyFactoryOwner();}
//     // amount0 = amount0Requested > protocolFees.token0 ? protocolFees.token0 : amount0Requested;
//     // amount1 = amount1Requested > protocolFees.token1 ? protocolFees.token1 : amount1Requested;

//     // if (amount0 > 0) {
//     //     if (amount0 == protocolFees.token0) amount0--; // ensure that the slot is not cleared, for gas savings
//     //     protocolFees.token0 -= amount0;
//     //     TransferHelper.safeTransfer(token0, recipient, amount0);
//     // }
//     // if (amount1 > 0) {
//     //     if (amount1 == protocolFees.token1) amount1--; // ensure that the slot is not cleared, for gas savings
//     //     protocolFees.token1 -= amount1;
//     //     TransferHelper.safeTransfer(token1, recipient, amount1);
//     // }

//     // emit CollectProtocol(caller, recipient, amount0, amount1);
//     slot0.unlocked := true;
// }
